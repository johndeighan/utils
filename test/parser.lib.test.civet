# parser.lib.test.civet

import {
	hash, getCmdArgs, DBG, o,
	} from '../src/lib/utils.lib.ts'
import {
	KeppelGrammar,
	} from './parser/keppel.grammar.ts'
import {
	TState, getNewState, StringMatcher, RegexMatcher,
	All, Any, Plus, Optional, Star,
	getParser, Node, getLineAndColumn,
	} from '../src/lib/parser.lib.ts'
import {
	equal, same, like, succeeds, fails, truthy, falsy,
	matches, isType, notType, objListLike,
	} from '../src/lib/unit-test.lib.ts'

getCmdArgs()
htmlParse := getParser<hash>(KeppelGrammar)

# ---------------------------------------------------------------------------
# --- test getLineAndColumn()

equal getLineAndColumn('abc\ndef\nghi', 5), [2, 2]
equal getLineAndColumn('abcd\nefgh\nijkl', 5), [2, 1]

# ---------------------------------------------------------------------------
# --- test getNewState()

equal getNewState('abc'), {
	text: 'abc'
	ignore: []
	stack: []
	sp: 0
	lastPos: 0
	pos: 0
	}

equal getNewState('abc', 2), {
	text: 'abc'
	ignore: []
	stack: []
	sp: 0
	lastPos: 0
	pos: 2
	}

# ---------------------------------------------------------------------------
# --- test StringMatcher()

(() =>
	rule := StringMatcher('abc')
	like rule(getNewState('abcdef')), {pos: 3}
	fails () => rule(getNewState('abcdef', 3))
	)()

(() =>
	rule := StringMatcher('def')
	like rule(getNewState('abcdef')), {pos: 0}
	like rule(getNewState('abcdef', 3)), {pos: 6}

	# --- On failure to match, should return the same TState
	$ := getNewState('abcdef')
	same rule($), $
	)()

# ---------------------------------------------------------------------------
# --- test RegexMatcher()

(() =>
	rule := RegexMatcher(/^[\.\#]\s/)
	like rule(getNewState('. abc')), {pos: 2}
	fails () => rule(getNewState('. abc', 1))
	)()

(() =>
	rule := RegexMatcher(/^[\.\#]\s/)
	like rule(getNewState('abc . def')), {pos: 0}
	like rule(getNewState('abc . def', 4)), {pos: 6}

	# --- On failure to match, should return the same TState
	$ := getNewState('abc . abc')
	same rule($), $
	)()

# ---------------------------------------------------------------------------
# --- test Node<T>

(() =>
	reducer := (
			lMatches: string[]
			$: TState
			$next: TState
			): string =>
		return 'X'

	# --- This rule will attempt to match the string 'abc'
	#     when it matches, the reducer is called, and
	#     what it returns is put on the stack
	rule := Node<string>('abc', reducer)

	$ := getNewState('abcdef')
	equal rule($), {
	   "text": "abcdef",
	   "ignore": [],
	   "stack": ['X'],
	   "sp": 1,
	   "lastPos": 0
		"pos": 3
		}
	)()

# ---------------------------------------------------------------------------
# Build and test some very simple rules

ident := ///^( [a-zA-Z_$] [a-zA-Z0-9_$]* ) ///
number := ///^
	(
		(?:
			[0-9]+ \.? [0-9]* | \. [0-9]+
			)
		(?:
			[eE] [-+]? [0-9]+
			)?
		)\b
	///
op := /[+\-*\/]/

# --- Define the grammer productions

value := [ident, number] |> Any
stmt := Any [
	[ident, '=', value]
	[value, op, value]
	]
program := [stmt, [';', stmt] |> Star]

(() =>
	parse := getParser(ident)
	succeeds () => parse 'abc'
	succeeds () => parse ' abc'  # --- whitespace skipped
	fails    () => parse '1abc'
	fails    () => parse 'abc def'
	succeeds () => getParser(ident, o'partial') 'abc def'
	)()

(() =>
	parse := getParser(op)
	succeeds () => parse '+'
	succeeds () => parse '  -  '
	succeeds () => parse '*'
	succeeds () => parse '  /  '
	fails    () => parse '!'
	)()

(() =>
	parse := getParser(value)
	succeeds () => parse 'n'
	succeeds () => parse '  n  '
	succeeds () => parse '42'
	succeeds () => parse '  42  '
	fails    () => parse '!'
	)()

(() =>
	parse := getParser(stmt)
	succeeds () => parse 'n = 42'
	succeeds () => parse '  n=42  '
	succeeds () => parse 'a=b'
	succeeds () => parse '  a = b  '
	fails    () => parse '!'
	)()

(() =>
	parse := getParser(number)
	succeeds () => parse '42'
	succeeds () => parse '  42  '
	succeeds () => parse '3.14'
	succeeds () => parse '  3.14  '
	succeeds () => parse '3.14e5'
	succeeds () => parse '  3.14E5  '
	fails    () => parse '!'
	)()

(() =>
	parse := getParser(program)
	succeeds () => parse 'x = 42; y = 33; x*y'
	succeeds () => parse """
		x = 42;
		y = 33;
		x * y
		"""
	)()
# ---------------------------------------------------------------------------

# equal htmlParse('p'), {
# 	type: 'element'
# 	tag: 'p'
# 	}
#
# keppelStr99 := """
# 	body [    // I am a comment
# 	  div #navbar .navbar.navbar-inverse.navbar-fixed-top [
# 		 div.navbar-inner [
# 			a(href="#", test="My test").brand ['Awesome']
# 			ul.nav [
# 			  li[ a(href="#") ['Item 1'] ]
# 			  li[ a(href="#") ['Item 2'] ]
# 			]
# 		 ]
# 	  ]
# 	]
# 	// I am a comment in the end of input
# 	"""
