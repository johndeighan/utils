# walker.lib.civet

import {
	undef, defined, notdefined, integer, TConstructor,
	isArray, isObject, isPrimitive,
	} from 'datatypes'
import {OL} from 'llutils'
import {DBG} from 'logger'

# ---------------------------------------------------------------------------

export type TNodeInfo<T> = {
	node: T
	level: integer
	parent: T?
	}

type TConstructor<T> = new (...args: any[]) => T

# ---------------------------------------------------------------------------

export class Walker<T extends object = object>

	# --- Keep track of nodes visited to avoid infinite loops
	setVisited: WeakSet<T> = new WeakSet<T>()

	# --- If constructor is provided, only objects with that
	#     constuctor will be yielded

	nodeConstructor: TConstructor<T>?

	# ..........................................................

	constructor(@nodeConstructor: TConstructor<T>? = undef)

	# ..........................................................

	isNode(x: object): x is T

		return (
			isObject(x)  # not undef, null, regex, array
				&& (
						not @nodeConstructor
					|| (x instanceof @nodeConstructor)
					)
			)

	# ..........................................................

	useNode(x: object): boolean

		return @isNode(x)

	# ..........................................................
	# GENERATOR

	walk(
			item: unknown
			parent: T? = undef
			level: number = 0
			): Generator<TNodeInfo<T>, void, void>

		if isObject(item) && @useNode item
			DBG "NODE: #{OL(item)}"
			yield {
				node: item as T
				parent
				level
				index
				}

		if Array.isArray item
			for x of item
				yield* @walk x, parent, level+1
		else if (typeof item == 'object')
			for x of Object.values(item)
				yield* @walk x, (@isNode(item) ? item : parent), level+1
