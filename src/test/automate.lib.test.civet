# automate.lib.test.civet

import {defined, isHash, isFunction} from 'datatypes'
import {o} from 'llutils'
import {getCmdArgs} from 'cmd-args'
import {withExt, TPathInfo} from 'fsys'
import {DBG} from 'logger'
import {execCmd, getCmdOutput} from 'exec'
import {
	TTesterFunc, TCompileStatus, TCompilerFunc, TPostProcessor,
	TCompilerConfig, isCompilerConfig,
	TCompilerInfo, isCompilerInfo,
	TCompileResult, TUnitTestResult,
	getCompilerConfig, getCompilerInfo, getPostProcessor,
	compileFile,
	runUnitTestsFor, runAllUnitTests,
	installCmd, uninstallCmd,
	} from 'automate'
import {
	equal, like, succeeds, fails, truthy, falsy, setDirTree,
	matches, isType, notType, objListLike, strListLike,
	} from 'unit-test'

getCmdArgs()

# ---------------------------------------------------------------------------

setup := (): void =>

	setDirTree('src/test/automate', """
		test1.cielo
			# test1.cielo

			LOG := (str) => console.log str
			LOG "Hello, World!"

		test2.civet
			# test2.civet

			LOG := (str) => console.log str
			LOG "Hello, World!"

		test3.coffee
			# test3.coffee

			LOG = (str) => console.log str
			LOG "Hello, World!"

		graph.dot
			EE -> EO | OE | OO
			EO -> EE
			OE -> EE
			OO -> EE
		hello.ts
			console.log("Hello, World!");
		comp.config.civet
			import {withExt} from 'fsys'
			export default new Object {
				hCompilers: {
					'.test': {
						getOutPaths: (path: string) => [withExt(path, '.out')],
						tester: () => true,
						compiler: (path: string) => undefined
						}
					},
				hPostProcessors: {}
				}
		""", o'clear')
	return

setup()

# ---------------------------------------------------------------------------

DBG "type TTesterFunc"

isType 'TTesterFunc', () =>
	console.log "Hello, World!"
	return true

DBG "type TCompileStatus"

isType 'TCompileStatus', 'temp'
isType 'TCompileStatus', 'exists'
isType 'TCompileStatus', 'compiled'
notType 'TCompileStatus', 'dummy'

DBG "type TCompilerFunc"

isType 'TCompilerFunc', (path: string) =>
	console.log path
	return 'compiled'

DBG "type TPostProcessor"

(() =>
	logit := (hInfo: TPathInfo) =>
		console.log "done"
		return
	isType 'TPostProcessor', logit
	)()

DBG "type TCompilerInfo"

isType 'TCompilerInfo', {
	tester: () => true,
	compiler: (path: string) => return 'compiled',
	getOutPaths: (path: string) => return ['temp.ts']
	}

DBG "type TCompilerConfig", "isCompilerConfig()"

isType 'TCompilerConfig', {
	hCompilers: {}
	hPostProcessors: {}
	}

DBG "type TCompileResult"

isType 'TCompileResult', {
	status: 'compiled'
	path: 'temp.civet'
	}

DBG "type TUnitTestResult"

isType 'TUnitTestResult', {
	stub: 'temp'
	success: true
	}

DBG "getCompilerConfig(path)"

(() =>
	civetPath := 'src/test/compile/comp.config.civet'
	hConfig := getCompilerConfig(civetPath)
	isType 'TCompilerConfig', hConfig, isCompilerConfig
	)()

DBG "getCompilerInfo()"

isType 'TCompilerInfo', getCompilerInfo('.dot'), isCompilerInfo

DBG "getPostProcessor()"

(() =>
	pp := getPostProcessor('test')
	truthy defined(pp)
	truthy isFunction(pp)
	)()

(() =>
	pp := getPostProcessor('lib')
	truthy defined(pp)
	truthy isFunction(pp)
	)()

(() =>
	pp := getPostProcessor('cmd')
	truthy defined(pp)
	truthy isFunction(pp)
	)()

DBG "compileFile()"

fails () => compileFile 'nosuchfile.civet'

(() =>
	hResult := compileFile('src/test/compile/test1.cielo', o'nopp')
	# truthy isFile('test/compile/test1.civet')
	)()

DBG "runUnitTestsFor(stub)"

(() =>
	lResults := Array.from(runUnitTestsFor('llutils.lib'))
	objListLike lResults, [
		{stub: 'llutils.lib', success: true}
		]
	)()

DBG "runAllUnitTests()"

succeeds () =>
	runAllUnitTests()
	return

# DBG "installCmd()", "uninstallCmd()"

# await installCmd 'src/test/compile/hello.ts', 'hello'
# hResult := await getCmdOutput 'hello', []
# str := hResult.stdout
# equal str, "Hello, World!\n"
# await uninstallCmd 'hello'
