"use strict";
// typescript.lib.test.civet

import {stripAnsiCode} from "@std/fmt/colors"
import {SourceFile} from 'npm:typescript'

import {
	undef, isHash, isEmpty, nonEmpty, normalizeCode,
	} from 'datatypes'
import {pass, o, s, t} from 'llutils'
import {DBG} from 'logger'
import {getCmdArgs} from 'cmd-args'
import {slurp, withExt} from 'fsys'
import {
	typeCheckCode, splitFuncStr, getSymbolsFromType,
	getImportCode, getTsCode, checkType,
	ts2ast, ast2ts, typeCheckFiles, astAsString, analyze,
	} from 'typescript'
import {civet2ts, a} from 'civet'
import {
	equal, like, succeeds, fails, truthy, falsy, isType, setDirTree,
	} from 'unit-test'

getCmdArgs()

// ---------------------------------------------------------------------------

const setup = (): void => {

	DBG("setDirTree()")

	setDirTree('src/test/typescript', `tstest.ts
	const str: string = 'abc'
tstest2.ts
	const func1 = (str: string): boolean =>
		return true`)
}

setup()

// ---------------------------------------------------------------------------

DBG("typeCheckCode(tsCode)")

truthy(isEmpty(typeCheckCode("let s: string = 'abc';")))
truthy(nonEmpty(typeCheckCode("let s: string = 42;")))

DBG("ts2ast(tsCode)", "astAsString(ast)")

const ast = ts2ast(slurp('src/test/typescript/tstest2.ts'))
equal(stripAnsiCode(astAsString(ast)), s`kind: 308 (SourceFile)
statements:
	-
	❘  kind: 244 (FirstStatement)
	❘  declarationList:
	❘     kind: 262 (VariableDeclarationList)
	❘     declarations:
	❘     ❘  -
	❘     ❘     kind: 261 (VariableDeclaration)
	❘     ❘     name:
	❘     ❘     ❘  kind: 80 (Identifier)
	❘     ❘     ❘  escapedText: func1
	❘     ❘     initializer:
	❘     ❘     ❘  kind: 220 (ArrowFunction)
	❘     ❘     ❘  parameters:
	❘     ❘     ❘     -
	❘     ❘     ❘     ❘  kind: 170 (Parameter)
	❘     ❘     ❘     ❘  name:
	❘     ❘     ❘     ❘     kind: 80 (Identifier)
	❘     ❘     ❘     ❘     escapedText: str
	❘     ❘     ❘     ❘  type:
	❘     ❘     ❘     ❘     kind: 154 (StringKeyword)
	❘     ❘     ❘  type:
	❘     ❘     ❘     kind: 136 (BooleanKeyword)
	❘     ❘     ❘  equalsGreaterThanToken:
	❘     ❘     ❘     kind: 39 (EqualsGreaterThanToken)
	❘     ❘     ❘  body:
	❘     ❘     ❘     kind: 242 (Block)
	❘     ❘     ❘     statements:
	❘     ❘     ❘     ❘  -
	❘     ❘     ❘     ❘     kind: 254 (ReturnStatement)
	❘     ❘     ❘     ❘     expression:
	❘     ❘     ❘     ❘     ❘  kind: 112 (TrueKeyword)
	❘     ❘     ❘     multiLine: .true
endOfFileToken:
	kind: 1 (EndOfFileToken)
text: const˳func1˳=˳(str:˳string):˳boolean˳=>↓→return˳true
fileName: temp.ts
scriptKind: 3
isDeclarationFile: .false
nodeCount: 16
identifierCount: 3
symbolCount: 0
parseDiagnostics:
	-
	❘  file: .ref root
	❘  start: 41
	❘  length: 6
	❘  messageText: '{'˳expected.
	❘  category: 1
	❘  code: 1005
	-
	❘  file: .ref root
	❘  start: 52
	❘  length: 0
	❘  messageText: '}'˳expected.
	❘  category: 1
	❘  code: 1005`)
DBG("getSymbolsFromType(typeStr)")

equal(getSymbolsFromType('integer'), ['integer'])
equal(getSymbolsFromType('hashof<integer>'), ['hashof','integer'])

DBG("getImportCode(typeStr)")

equal(getImportCode('integer'), `import {integer} from 'datatypes';`)
equal(getImportCode('hashof<integer>'), `import {hashof, integer} from 'datatypes';`)

DBG("splitFuncStr(valueStr)")

equal(splitFuncStr("abc"), undef)
equal(splitFuncStr("() => true"), [[], 'true'])
equal(splitFuncStr("(  ) => true"), [[], 'true'])
equal(splitFuncStr("(a,b,c) => false"), [
	['a','b','c'],
	'false'
	])
equal(splitFuncStr("( a , b,c ) => false"), [
	['a','b','c'],
	'false'
	])
equal(splitFuncStr("(a: string, b)=>true"), [
	['a: string', 'b'],
	'true'
	])

DBG("getTsCode(typeStr, valueStr)")

equal(getTsCode('integer', '42'), 'const x: integer = 42')
equal(getTsCode('TFilterFunc', '(x) => true'),
	'const x: TFilterFunc = (x: unknown) => true')

DBG("checkType(x, typeStr)")

equal(checkType(42, 'number'), [])

DBG("analyze(tsCode, hOptions)")

equal(a`x := y + z + func(min)`, s`MISSING: y z func min
EXTRA: x`)

equal(a`import {defined, notdefined} from 'datatypes'`, s`IMPORTS: datatypes: defined notdefined
EXTRA: defined notdefined`)

equal(a`x := y + z + func(min)`, s`MISSING: y z func min
EXTRA: x`)

equal(a`import {defined, notdefined} from 'datatypes'`, s`IMPORTS: datatypes: defined notdefined
EXTRA: defined notdefined`)

equal(a`export meaning := 42`, s`EXPORTS: meaning`)

equal(a`func "Hello"`, s`MISSING: func`)

equal(a`func x, y+z`, s`MISSING: func x y z`)

// --- imports are not needed

equal(a`import {func} from 'willy'

func x, y+z`, s`IMPORTS: willy: func
MISSING: x y z`)

// --- Only t is needed, s is a parameter

equal(a`func := (s: string): string =>
	return s + t + '.txt'
func('abc')`, s`MISSING: t`)

// --- Same, only using 'function' keyword

equal(a`function func(s: string): string
	return s + t + '.txt'
func('abc')`, s`MISSING: t`)

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiQzovVXNlcnMvam9obmQvdXRpbHMvc3JjL3Rlc3QvdHlwZXNjcmlwdC5saWIudGVzdC5jaXZldC50c3giLCJzb3VyY2VzIjpbIkM6L1VzZXJzL2pvaG5kL3V0aWxzL3NyYy90ZXN0L3R5cGVzY3JpcHQubGliLnRlc3QuY2l2ZXQiXSwibWFwcGluZ3MiOiI7QUFBQSw0QkFBMkI7QUFDM0IsQUFBQTtBQUNBLEFBQUEsTUFBTSxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsSUFBSSxDQUFDLGlCQUFpQjtBQUM3QyxBQUFBLEFBQUEsTUFBTSxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsSUFBSSxDQUFDLGdCQUFnQjtBQUN6QyxBQUFBO0FBQ0EsQUFBQSxBQUFBLE1BQU0sQ0FBQyxDQUFDO0FBQ1IsQ0FBQyxLQUFLLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxhQUFhLENBQUM7QUFDakQsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVc7QUFDbkIsQUFBQSxBQUFBLE1BQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTO0FBQ3JDLEFBQUEsQUFBQSxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsUUFBUTtBQUMxQixBQUFBLEFBQUEsTUFBTSxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsSUFBSSxDQUFDLFVBQVU7QUFDbkMsQUFBQSxBQUFBLE1BQU0sQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNO0FBQ25DLEFBQUEsQUFBQSxNQUFNLENBQUMsQ0FBQztBQUNSLENBQUMsYUFBYSxDQUFDLENBQUMsWUFBWSxDQUFDLENBQUMsa0JBQWtCLENBQUM7QUFDakQsQ0FBQyxhQUFhLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxTQUFTLENB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QSxBQUFBLEFBQUEsS0FBSyxDQUFBLEFBQUMsQ0FBQyxDQUFHLDZDQUVULENBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBRztBQUNWLHlCQUVHLENBQUcsQ0FBQTtBQUNOLEFBQUE7QUFDQSxBQUFBLEFBQUEsS0FBSyxDQUFBLEFBQUMsQ0FBQyxDQUFHLG9CQUVULENBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBRyxnQkFFVCxDQUFHLENBQUE7QUFDSixBQUFBO0FBQ0EsQUFBQSxBQUFBLEtBQUssQ0FBQSxBQUFDLENBQUMsQ0FBRyxZQUVULENBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBRyxhQUVULENBQUcsQ0FBQTtBQUNKLEFBQUE7QUFDQSxBQUFBLEFBQUEsS0FBSyxDQUFBLEFBQUMsQ0FBQyxDQUFHLFdBRVQsQ0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFHLG1CQUVULENBQUcsQ0FBQTtBQUNKLEFBQUE7QUFDQSxBQUFBLDZCQUE0QjtBQUM1QixBQUFBO0FBQ0EsQUFBQSxBQUFBLEtBQUssQ0FBQSxBQUFDLENBQUMsQ0FBRztBQUNWO0FBQ0EsV0FFQyxDQUFHLENBQUMsQ0FBQyxDQUFDLENBQUc7QUFDVixjQUVDLENBQUcsQ0FBQTtBQUNKLEFBQUE7QUFDQSxBQUFBLHlDQUF3QztBQUN4QyxBQUFBO0FBQ0EsQUFBQSxBQUFBLEtBQUssQ0FBQSxBQUFDLENBQUMsQ0FBRztBQUNWO0FBQ0EsV0FFQyxDQUFHLENBQUMsQ0FBQyxDQUFDLENBQUcsVUFFVCxDQUFHLENBQUE7QUFDSixBQUFBO0FBQ0EsQUFBQSwwQ0FBeUM7QUFDekMsQUFBQTtBQUNBLEFBQUEsQUFBQSxLQUFLLENBQUEsQUFBQyxDQUFDLENBQUc7QUFDVjtBQUNBLFdBRUMsQ0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFHLFVBRVQsQ0FBRyxDQUFBO0FBQ0oiLCJuYW1lcyI6W10sInNvdXJjZXNDb250ZW50IjpbIiMgdHlwZXNjcmlwdC5saWIudGVzdC5jaXZldFxyXG5cclxuaW1wb3J0IHtzdHJpcEFuc2lDb2RlfSBmcm9tIFwiQHN0ZC9mbXQvY29sb3JzXCJcclxuaW1wb3J0IHtTb3VyY2VGaWxlfSBmcm9tICducG06dHlwZXNjcmlwdCdcclxuXHJcbmltcG9ydCB7XHJcblx0dW5kZWYsIGlzSGFzaCwgaXNFbXB0eSwgbm9uRW1wdHksIG5vcm1hbGl6ZUNvZGUsXHJcblx0fSBmcm9tICdkYXRhdHlwZXMnXHJcbmltcG9ydCB7cGFzcywgbywgcywgdH0gZnJvbSAnbGx1dGlscydcclxuaW1wb3J0IHtEQkd9IGZyb20gJ2xvZ2dlcidcclxuaW1wb3J0IHtnZXRDbWRBcmdzfSBmcm9tICdjbWQtYXJncydcclxuaW1wb3J0IHtzbHVycCwgd2l0aEV4dH0gZnJvbSAnZnN5cydcclxuaW1wb3J0IHtcclxuXHR0eXBlQ2hlY2tDb2RlLCBzcGxpdEZ1bmNTdHIsIGdldFN5bWJvbHNGcm9tVHlwZSxcclxuXHRnZXRJbXBvcnRDb2RlLCBnZXRUc0NvZGUsIGNoZWNrVHlwZSxcclxuXHR0czJhc3QsIGFzdDJ0cywgdHlwZUNoZWNrRmlsZXMsIGFzdEFzU3RyaW5nLCBhbmFseXplLFxyXG5cdH0gZnJvbSAndHlwZXNjcmlwdCdcclxuaW1wb3J0IHtjaXZldDJ0cywgYX0gZnJvbSAnY2l2ZXQnXHJcbmltcG9ydCB7XHJcblx0ZXF1YWwsIGxpa2UsIHN1Y2NlZWRzLCBmYWlscywgdHJ1dGh5LCBmYWxzeSwgaXNUeXBlLCBzZXREaXJUcmVlLFxyXG5cdH0gZnJvbSAndW5pdC10ZXN0J1xyXG5cclxuZ2V0Q21kQXJncygpXHJcblxyXG4jIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cclxuc2V0dXAgOj0gKCk6IHZvaWQgPT5cclxuXHJcblx0REJHIFwic2V0RGlyVHJlZSgpXCJcclxuXHJcblx0c2V0RGlyVHJlZSAnc3JjL3Rlc3QvdHlwZXNjcmlwdCcsIFwiXCJcIlxyXG5cdFx0dHN0ZXN0LnRzXHJcblx0XHRcdGNvbnN0IHN0cjogc3RyaW5nID0gJ2FiYydcclxuXHRcdHRzdGVzdDIudHNcclxuXHRcdFx0Y29uc3QgZnVuYzEgPSAoc3RyOiBzdHJpbmcpOiBib29sZWFuID0+XHJcblx0XHRcdFx0cmV0dXJuIHRydWVcclxuXHRcdFwiXCJcIlxyXG5cclxuc2V0dXAoKVxyXG5cclxuIyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHJcbkRCRyBcInR5cGVDaGVja0NvZGUodHNDb2RlKVwiXHJcblxyXG50cnV0aHkgaXNFbXB0eSh0eXBlQ2hlY2tDb2RlKFwibGV0IHM6IHN0cmluZyA9ICdhYmMnO1wiKSlcclxudHJ1dGh5IG5vbkVtcHR5KHR5cGVDaGVja0NvZGUoXCJsZXQgczogc3RyaW5nID0gNDI7XCIpKVxyXG5cclxuREJHIFwidHMyYXN0KHRzQ29kZSlcIiwgXCJhc3RBc1N0cmluZyhhc3QpXCJcclxuXHJcbmFzdCA6PSB0czJhc3Qoc2x1cnAoJ3NyYy90ZXN0L3R5cGVzY3JpcHQvdHN0ZXN0Mi50cycpKVxyXG5lcXVhbCBzdHJpcEFuc2lDb2RlKGFzdEFzU3RyaW5nKGFzdCkpLCBzXCJcIlwiXHJcblx0a2luZDogMzA4IChTb3VyY2VGaWxlKVxyXG5cdHN0YXRlbWVudHM6XHJcblx0XHQtXHJcblx0XHTinZggIGtpbmQ6IDI0NCAoRmlyc3RTdGF0ZW1lbnQpXHJcblx0XHTinZggIGRlY2xhcmF0aW9uTGlzdDpcclxuXHRcdOKdmCAgICAga2luZDogMjYyIChWYXJpYWJsZURlY2xhcmF0aW9uTGlzdClcclxuXHRcdOKdmCAgICAgZGVjbGFyYXRpb25zOlxyXG5cdFx04p2YICAgICDinZggIC1cclxuXHRcdOKdmCAgICAg4p2YICAgICBraW5kOiAyNjEgKFZhcmlhYmxlRGVjbGFyYXRpb24pXHJcblx0XHTinZggICAgIOKdmCAgICAgbmFtZTpcclxuXHRcdOKdmCAgICAg4p2YICAgICDinZggIGtpbmQ6IDgwIChJZGVudGlmaWVyKVxyXG5cdFx04p2YICAgICDinZggICAgIOKdmCAgZXNjYXBlZFRleHQ6IGZ1bmMxXHJcblx0XHTinZggICAgIOKdmCAgICAgaW5pdGlhbGl6ZXI6XHJcblx0XHTinZggICAgIOKdmCAgICAg4p2YICBraW5kOiAyMjAgKEFycm93RnVuY3Rpb24pXHJcblx0XHTinZggICAgIOKdmCAgICAg4p2YICBwYXJhbWV0ZXJzOlxyXG5cdFx04p2YICAgICDinZggICAgIOKdmCAgICAgLVxyXG5cdFx04p2YICAgICDinZggICAgIOKdmCAgICAg4p2YICBraW5kOiAxNzAgKFBhcmFtZXRlcilcclxuXHRcdOKdmCAgICAg4p2YICAgICDinZggICAgIOKdmCAgbmFtZTpcclxuXHRcdOKdmCAgICAg4p2YICAgICDinZggICAgIOKdmCAgICAga2luZDogODAgKElkZW50aWZpZXIpXHJcblx0XHTinZggICAgIOKdmCAgICAg4p2YICAgICDinZggICAgIGVzY2FwZWRUZXh0OiBzdHJcclxuXHRcdOKdmCAgICAg4p2YICAgICDinZggICAgIOKdmCAgdHlwZTpcclxuXHRcdOKdmCAgICAg4p2YICAgICDinZggICAgIOKdmCAgICAga2luZDogMTU0IChTdHJpbmdLZXl3b3JkKVxyXG5cdFx04p2YICAgICDinZggICAgIOKdmCAgdHlwZTpcclxuXHRcdOKdmCAgICAg4p2YICAgICDinZggICAgIGtpbmQ6IDEzNiAoQm9vbGVhbktleXdvcmQpXHJcblx0XHTinZggICAgIOKdmCAgICAg4p2YICBlcXVhbHNHcmVhdGVyVGhhblRva2VuOlxyXG5cdFx04p2YICAgICDinZggICAgIOKdmCAgICAga2luZDogMzkgKEVxdWFsc0dyZWF0ZXJUaGFuVG9rZW4pXHJcblx0XHTinZggICAgIOKdmCAgICAg4p2YICBib2R5OlxyXG5cdFx04p2YICAgICDinZggICAgIOKdmCAgICAga2luZDogMjQyIChCbG9jaylcclxuXHRcdOKdmCAgICAg4p2YICAgICDinZggICAgIHN0YXRlbWVudHM6XHJcblx0XHTinZggICAgIOKdmCAgICAg4p2YICAgICDinZggIC1cclxuXHRcdOKdmCAgICAg4p2YICAgICDinZggICAgIOKdmCAgICAga2luZDogMjU0IChSZXR1cm5TdGF0ZW1lbnQpXHJcblx0XHTinZggICAgIOKdmCAgICAg4p2YICAgICDinZggICAgIGV4cHJlc3Npb246XHJcblx0XHTinZggICAgIOKdmCAgICAg4p2YICAgICDinZggICAgIOKdmCAga2luZDogMTEyIChUcnVlS2V5d29yZClcclxuXHRcdOKdmCAgICAg4p2YICAgICDinZggICAgIG11bHRpTGluZTogLnRydWVcclxuXHRlbmRPZkZpbGVUb2tlbjpcclxuXHRcdGtpbmQ6IDEgKEVuZE9mRmlsZVRva2VuKVxyXG5cdHRleHQ6IGNvbnN0y7NmdW5jMcuzPcuzKHN0cjrLs3N0cmluZyk6y7Nib29sZWFuy7M9PuKGk+KGknJldHVybsuzdHJ1ZVxyXG5cdGZpbGVOYW1lOiB0ZW1wLnRzXHJcblx0c2NyaXB0S2luZDogM1xyXG5cdGlzRGVjbGFyYXRpb25GaWxlOiAuZmFsc2VcclxuXHRub2RlQ291bnQ6IDE2XHJcblx0aWRlbnRpZmllckNvdW50OiAzXHJcblx0c3ltYm9sQ291bnQ6IDBcclxuXHRwYXJzZURpYWdub3N0aWNzOlxyXG5cdFx0LVxyXG5cdFx04p2YICBmaWxlOiAucmVmIHJvb3RcclxuXHRcdOKdmCAgc3RhcnQ6IDQxXHJcblx0XHTinZggIGxlbmd0aDogNlxyXG5cdFx04p2YICBtZXNzYWdlVGV4dDogJ3sny7NleHBlY3RlZC5cclxuXHRcdOKdmCAgY2F0ZWdvcnk6IDFcclxuXHRcdOKdmCAgY29kZTogMTAwNVxyXG5cdFx0LVxyXG5cdFx04p2YICBmaWxlOiAucmVmIHJvb3RcclxuXHRcdOKdmCAgc3RhcnQ6IDUyXHJcblx0XHTinZggIGxlbmd0aDogMFxyXG5cdFx04p2YICBtZXNzYWdlVGV4dDogJ30ny7NleHBlY3RlZC5cclxuXHRcdOKdmCAgY2F0ZWdvcnk6IDFcclxuXHRcdOKdmCAgY29kZTogMTAwNVxyXG5cdFwiXCJcIlxyXG5EQkcgXCJnZXRTeW1ib2xzRnJvbVR5cGUodHlwZVN0cilcIlxyXG5cclxuZXF1YWwgZ2V0U3ltYm9sc0Zyb21UeXBlKCdpbnRlZ2VyJyksIFsnaW50ZWdlciddXHJcbmVxdWFsIGdldFN5bWJvbHNGcm9tVHlwZSgnaGFzaG9mPGludGVnZXI+JyksIFsnaGFzaG9mJywnaW50ZWdlciddXHJcblxyXG5EQkcgXCJnZXRJbXBvcnRDb2RlKHR5cGVTdHIpXCJcclxuXHJcbmVxdWFsIGdldEltcG9ydENvZGUoJ2ludGVnZXInKSwgXCJcIlwiXHJcblx0aW1wb3J0IHtpbnRlZ2VyfSBmcm9tICdkYXRhdHlwZXMnO1xyXG5cdFwiXCJcIlxyXG5lcXVhbCBnZXRJbXBvcnRDb2RlKCdoYXNob2Y8aW50ZWdlcj4nKSwgXCJcIlwiXHJcblx0aW1wb3J0IHtoYXNob2YsIGludGVnZXJ9IGZyb20gJ2RhdGF0eXBlcyc7XHJcblx0XCJcIlwiXHJcblxyXG5EQkcgXCJzcGxpdEZ1bmNTdHIodmFsdWVTdHIpXCJcclxuXHJcbmVxdWFsIHNwbGl0RnVuY1N0cihcImFiY1wiKSwgdW5kZWZcclxuZXF1YWwgc3BsaXRGdW5jU3RyKFwiKCkgPT4gdHJ1ZVwiKSwgW1tdLCAndHJ1ZSddXHJcbmVxdWFsIHNwbGl0RnVuY1N0cihcIiggICkgPT4gdHJ1ZVwiKSwgW1tdLCAndHJ1ZSddXHJcbmVxdWFsIHNwbGl0RnVuY1N0cihcIihhLGIsYykgPT4gZmFsc2VcIiksIFtcclxuXHRbJ2EnLCdiJywnYyddXHJcblx0J2ZhbHNlJ1xyXG5cdF1cclxuZXF1YWwgc3BsaXRGdW5jU3RyKFwiKCBhICwgYixjICkgPT4gZmFsc2VcIiksIFtcclxuXHRbJ2EnLCdiJywnYyddXHJcblx0J2ZhbHNlJ1xyXG5cdF1cclxuZXF1YWwgc3BsaXRGdW5jU3RyKFwiKGE6IHN0cmluZywgYik9PnRydWVcIiksIFtcclxuXHRbJ2E6IHN0cmluZycsICdiJ11cclxuXHQndHJ1ZSdcclxuXHRdXHJcblxyXG5EQkcgXCJnZXRUc0NvZGUodHlwZVN0ciwgdmFsdWVTdHIpXCJcclxuXHJcbmVxdWFsIGdldFRzQ29kZSgnaW50ZWdlcicsICc0MicpLCAnY29uc3QgeDogaW50ZWdlciA9IDQyJ1xyXG5lcXVhbCBnZXRUc0NvZGUoJ1RGaWx0ZXJGdW5jJywgJyh4KSA9PiB0cnVlJyksXHJcblx0J2NvbnN0IHg6IFRGaWx0ZXJGdW5jID0gKHg6IHVua25vd24pID0+IHRydWUnXHJcblxyXG5EQkcgXCJjaGVja1R5cGUoeCwgdHlwZVN0cilcIlxyXG5cclxuZXF1YWwgY2hlY2tUeXBlKDQyLCAnbnVtYmVyJyksIFtdXHJcblxyXG5EQkcgXCJhbmFseXplKHRzQ29kZSwgaE9wdGlvbnMpXCJcclxuXHJcbmVxdWFsIGFcIlwiXCJcclxuXHR4IDo9IHkgKyB6ICsgZnVuYyhtaW4pXHJcblx0XCJcIlwiLCBzXCJcIlwiXHJcblx0TUlTU0lORzogeSB6IGZ1bmMgbWluXHJcblx0RVhUUkE6IHhcclxuXHRcIlwiXCJcclxuXHJcbmVxdWFsIGFcIlwiXCJcclxuXHRpbXBvcnQge2RlZmluZWQsIG5vdGRlZmluZWR9IGZyb20gJ2RhdGF0eXBlcydcclxuXHRcIlwiXCIsIHNcIlwiXCJcclxuXHRJTVBPUlRTOiBkYXRhdHlwZXM6IGRlZmluZWQgbm90ZGVmaW5lZFxyXG5cdEVYVFJBOiBkZWZpbmVkIG5vdGRlZmluZWRcclxuICAgXCJcIlwiXHJcblxyXG5lcXVhbCBhXCJcIlwiXHJcblx0eCA6PSB5ICsgeiArIGZ1bmMobWluKVxyXG5cdFwiXCJcIiwgc1wiXCJcIlxyXG5cdE1JU1NJTkc6IHkgeiBmdW5jIG1pblxyXG5cdEVYVFJBOiB4XHJcblx0XCJcIlwiXHJcblxyXG5lcXVhbCBhXCJcIlwiXHJcblx0aW1wb3J0IHtkZWZpbmVkLCBub3RkZWZpbmVkfSBmcm9tICdkYXRhdHlwZXMnXHJcblx0XCJcIlwiLCBzXCJcIlwiXHJcblx0SU1QT1JUUzogZGF0YXR5cGVzOiBkZWZpbmVkIG5vdGRlZmluZWRcclxuXHRFWFRSQTogZGVmaW5lZCBub3RkZWZpbmVkXHJcbiAgIFwiXCJcIlxyXG5cclxuZXF1YWwgYVwiXCJcIlxyXG5cdGV4cG9ydCBtZWFuaW5nIDo9IDQyXHJcblx0XCJcIlwiLCBzXCJcIlwiXHJcblx0RVhQT1JUUzogbWVhbmluZ1xyXG5cdFwiXCJcIlxyXG5cclxuZXF1YWwgYVwiXCJcIlxyXG5cdGZ1bmMgXCJIZWxsb1wiXHJcblx0XCJcIlwiLCBzXCJcIlwiXHJcblx0TUlTU0lORzogZnVuY1xyXG5cdFwiXCJcIlxyXG5cclxuZXF1YWwgYVwiXCJcIlxyXG5cdGZ1bmMgeCwgeSt6XHJcblx0XCJcIlwiLCBzXCJcIlwiXHJcblx0TUlTU0lORzogZnVuYyB4IHkgelxyXG5cdFwiXCJcIlxyXG5cclxuIyAtLS0gaW1wb3J0cyBhcmUgbm90IG5lZWRlZFxyXG5cclxuZXF1YWwgYVwiXCJcIlxyXG5cdGltcG9ydCB7ZnVuY30gZnJvbSAnd2lsbHknXHJcblxyXG5cdGZ1bmMgeCwgeSt6XHJcblx0XCJcIlwiLCBzXCJcIlwiXHJcblx0SU1QT1JUUzogd2lsbHk6IGZ1bmNcclxuXHRNSVNTSU5HOiB4IHkgelxyXG5cdFwiXCJcIlxyXG5cclxuIyAtLS0gT25seSB0IGlzIG5lZWRlZCwgcyBpcyBhIHBhcmFtZXRlclxyXG5cclxuZXF1YWwgYVwiXCJcIlxyXG5cdGZ1bmMgOj0gKHM6IHN0cmluZyk6IHN0cmluZyA9PlxyXG5cdFx0cmV0dXJuIHMgKyB0ICsgJy50eHQnXHJcblx0ZnVuYygnYWJjJylcclxuXHRcIlwiXCIsIHNcIlwiXCJcclxuXHRNSVNTSU5HOiB0XHJcblx0XCJcIlwiXHJcblxyXG4jIC0tLSBTYW1lLCBvbmx5IHVzaW5nICdmdW5jdGlvbicga2V5d29yZFxyXG5cclxuZXF1YWwgYVwiXCJcIlxyXG5cdGZ1bmN0aW9uIGZ1bmMoczogc3RyaW5nKTogc3RyaW5nXHJcblx0XHRyZXR1cm4gcyArIHQgKyAnLnR4dCdcclxuXHRmdW5jKCdhYmMnKVxyXG5cdFwiXCJcIiwgc1wiXCJcIlxyXG5cdE1JU1NJTkc6IHRcclxuXHRcIlwiXCJcclxuIl19