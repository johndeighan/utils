# fsys.lib.test.civet

import {
	undef, defined, hash, voidFunc, isString, deepEqual,
	} from 'datatypes'
import {
	o, spaces, sinceLoad, sinceLoadStr, sleep, pass,
	} from 'llutils'
import {LOG, DBG} from 'logger'
import {getCmdArgs} from 'cmd-args'
import {TPLLToken} from 'pll'
import {
	isFile, isDir, getPathType, fileExt, withExt,
	lStatFields, getStats, isStub, parsePath,
	allFilesMatching, allLinesIn,
	normalizePath, pathToURL, mkpath, relpath, pathSubDirs, myself,
	rmFile, rmDir, isExt, newerDestFileExists,
	clearDir, mkDir, mkDirsForFile, slurp, barf,
	removeFilesMatching, removeFilesExcept,
	watchFile, FileEventHandler,
	TFsEventHandler,
	TPathType, TPathInfo,
	patchFirstLine, FsEvent,
	} from 'fsys'
import {setDirTree} from 'pllfile'
import {
	equal, truthy, falsy, like, objListLike, matches,
	succeeds, fails, includesAll, isType, notType,
	} from 'unit-test'

getCmdArgs()

# ---------------------------------------------------------------------------

setup := (): void =>

	DBG "setDirTree()"

	setDirTree('src/test/fsys', """
			tokens.txt
				if x==1
					print "OK"
				exit
			dummy.txt
				dummy
			file1.txt
				line1
				line2
				line3
			file2.txt
				# test1.cielo

				LOG := (str) => console.log str
				LOG "Hello, World!"
			file3.flags.txt
				# test1.cielo

				LOG := (str) => console.log str
				LOG "Hello, World!"
			file4.cielo
				# file.cielo

				abc
			file5.cielo
				this is the REAL first line
				# file.cielo

				abc
			file.config.ts
				export default new Object({
					a: 1,
					b: 'abc',
					f: () => 'hello'
					})
			/aaa
				/bbb
					newfile.txt
						abc
					oldfile.txt
						abc
					temp.txt
						abc
			/subdir
				new.txt
					abc
					def
		""", o'clear')
	return

setup()

# ---------------------------------------------------------------------------

DBG "isFile()"

truthy isFile('./deno.jsonc')
truthy isFile('deno.jsonc')
falsy isFile('./src/lib/notafile.txt')
truthy isFile("./src/test/fsys/dummy.txt")
falsy  isFile("./src/test/fsys")

DBG "isDir()"

truthy isDir('test')
falsy isDir('nosuchdir')
truthy isDir("./src/test/fsys")
falsy  isDir("./src/test/fsys/dummy.txt")

DBG "type TPathType"

isType  'TPathType', 'missing'
isType  'TPathType', 'file'
notType 'TPathType', 'xxx'

DBG "getPathType()"

equal getPathType('./deno.jsonc'), 'file'
equal getPathType("./src/test/fsys"), 'dir'
equal getPathType('./src/lib/notafile.txt'), 'missing'
equal getPathType("./test"), 'dir'
equal getPathType("./src/test/fsys.lib.test.civet"), 'file'
equal getPathType("C:/temp/file.txt"), 'missing'

DBG "fileExt()"

equal fileExt('C:/Users/johnd/utils/deno.jsonc'), '.jsonc'
equal fileExt("C:/temp/file.txt"), ".txt"
equal fileExt("c:\\temp/to/file.txt"), ".txt"
equal fileExt("c:\\temp/to/file.flag.txt"), ".txt"

DBG "withExt()"

equal withExt('deno.jsonc', '.txt'), 'deno.txt'
equal withExt("C:/temp/file.txt", ".js"), "C:/temp/file.js"
equal withExt("c:\\temp/to/file.txt", ".js"), "c:\\temp/to/file.js"
equal withExt("c:\\temp/to/file.flag.txt", ".js"), "c:\\temp/to/file.flag.js"

DBG "const lStatFields"

includesAll lStatFields, ['size', 'mtime']

DBG "getStats(path)"

truthy ('mtime' in getStats('deno.jsonc'))
equal getStats('src/test/fsys/file1.txt').size, 17

DBG "isStub()"

truthy isStub('abc')
falsy  isStub('.js')
falsy  isStub('abc/deno')
falsy  isStub('abc\\deno')

DBG "type TPathInfo", "parsePath()"

like  parsePath("C:/temp/file.txt"), {
	type: 'missing'
	path: "C:/temp/file.txt"
	root: 'C:/'
	dir: 'C:/temp'
	fileName: 'file.txt'
	stub: 'file'
	purpose: undefined
	ext: '.txt'
	relPath: "../../../temp/file.txt"
	relDir: "../../../temp"
	}

like parsePath(import.meta.url), {
	type: 'file'
	fileName: 'fsys.lib.test.ts'
	stub: 'fsys.lib'
	purpose: 'test'
	ext: '.ts'
	relPath: 'src/test/fsys.lib.test.ts'
	relDir: 'src/test'
	}

DBG "allFilesMatching()"

objListLike Array.from(allFilesMatching('**/src/test/fsys/file*.txt')), [
	{
		type: 'file'
		root: 'C:/'
		fileName: 'file1.txt',
		stub: 'file1'
		ext: '.txt'
		relPath: 'src/test/fsys/file1.txt'
		}
	{
		type: 'file'
		root: 'C:/'
		fileName: 'file2.txt',
		stub: 'file2'
		ext: '.txt'
		relPath: 'src/test/fsys/file2.txt'
		}
	{
		type: 'file'
		root: 'C:/'
		fileName: 'file3.flags.txt',
		stub: 'file3'
		purpose: 'flags'
		ext: '.txt'
		relPath: 'src/test/fsys/file3.flags.txt'
		}
	]

(() =>
	lFiles :=  Array.from(allFilesMatching('src/test/fsys/**', o'includeDirs'))
	objListLike lFiles, [
		{
			type: 'dir'
			fileName: 'fsys',
			}
		{
			type: 'dir'
			fileName: 'aaa',
			}
		{
			type: 'dir'
			fileName: 'bbb',
			}
		{
			type: 'file'
			fileName: 'newfile.txt',
			}
		{
			type: 'file'
			fileName: 'oldfile.txt',
			}
		{
			type: 'file'
			fileName: 'temp.txt',
			}
		{
			type: 'file'
			fileName: 'dummy.txt',
			}
		{
			type: 'file'
			fileName: 'file.config.ts'
			}
		{
			type: 'file'
			fileName: 'file1.txt',
			}
		{
			type: 'file'
			fileName: 'file2.txt',
			}
		{
			type: 'file'
			fileName: 'file3.flags.txt',
			}
		{
			type: 'file'
			fileName: 'file4.cielo',
			}
		{
			type: 'file'
			fileName: 'file5.cielo',
			}
		{
			type: 'dir'
			fileName: 'subdir',
			}
		{
			type: 'file'
			fileName: 'new.txt',
			}
		{
			type: 'file'
			fileName: 'tokens.txt',
			}
		], (h) =>
			x := h['fileName']
			return isString(x) ? x : ''
	)()

(() =>
	hOptions := {
		includeDirs: true
		filter: (hFile: TPathInfo) =>
			flag := switch hFile.type
				when 'dir'
					(hFile.fileName != 'fsys')
				when 'file'
					defined(hFile.fileName.match(/^[a-z0-9]+\.txt$/))
				else
					false
			return flag
		}

	objListLike Array.from(allFilesMatching('src/test/fsys/**', hOptions)), [
		{
			type: 'dir'
			fileName: 'aaa',
			}
		{
			type: 'dir'
			fileName: 'bbb',
			}
		{
			type: 'file'
			fileName: 'newfile.txt',
			}
		{
			type: 'file'
			fileName: 'oldfile.txt',
			}
		{
			type: 'file'
			fileName: 'temp.txt',
			}
		{
			type: 'file'
			fileName: 'dummy.txt',
			}
		{
			type: 'file'
			fileName: 'file1.txt',
			}
		{
			type: 'file'
			fileName: 'file2.txt',
			}
		{
			type: 'dir'
			fileName: 'subdir',
			}
		{
			type: 'file'
			fileName: 'new.txt',
			}
		{
			type: 'file'
			fileName: 'tokens.txt',
			}
		]
	)()

(() =>
	hOptions := {
		includeDirs: false
		filter: (hFile: TPathInfo) =>
			{fileName} := hFile
			return fileName.match(/^[a-z0-9]+\.txt$/)
		}

	lFiles := Array.from(allFilesMatching('src/test/fsys/**', hOptions))
	equal lFiles.map((h) => h.fileName), [
		'newfile.txt',
		'oldfile.txt',
		'temp.txt',
		'dummy.txt',
		'file1.txt',
		'file2.txt',
		'new.txt',
		'tokens.txt',
		]
	)()

DBG "allLinesIn()"

lLines: string[] := []
for await line of allLinesIn('./src/test/fsys/file1.txt')
	lLines.push line

equal lLines, [
	'line1'
	'line2'
	'line3'
	]

DBG "normalizePath()"

equal normalizePath("C:/temp/file.txt"), "C:/temp/file.txt"
equal normalizePath("C:\\temp/to/file.txt"), "C:/temp/to/file.txt"
equal normalizePath("C:\\temp/to/file.flag.txt"), "C:/temp/to/file.flag.txt"
equal normalizePath('C:\\Users\\johnd'), 'C:/Users/johnd'

DBG "pathToURL()"

equal pathToURL('c:/x/temp.txt'), "file:///c:/x/temp.txt"

DBG "mkpath()"

equal mkpath("C:/temp/file.txt"), "C:/temp/file.txt"
equal mkpath("C:/temp", "file.txt"), "C:/temp/file.txt"
equal mkpath("C:\\temp/to/file.txt"), "C:/temp/to/file.txt"
equal mkpath("C:\\temp/to/file.flag.txt"), "C:/temp/to/file.flag.txt"
equal mkpath("C:/temp", "file.txt"), "C:/temp/file.txt"
equal mkpath("C:\\temp/to", "file.txt"), "C:/temp/to/file.txt"
equal mkpath("C:\\temp", "to/file.flag.txt"), "C:/temp/to/file.flag.txt"
equal mkpath('c:\\', 'Users', 'johnd'), 'C:/Users/johnd'

DBG "relpath()"

equal relpath('C:/Users/johnd/utils/deno.jsonc'), 'deno.jsonc'

DBG "type TPathDesc", "pathSubDirs()"

(() =>
	fullPath := "C:/Users/johnd/utils/src/test/fsys/deno.jsonc"
	relPath  := "src/test/fsys/deno.jsonc"

	# --- non-relative, try both full and relative paths
	equal pathSubDirs(fullPath, o'!relative'), {
		dir: 'C:/Users/johnd/utils/src/test/fsys'
		root: "C:/"
		lParts: ['Users', 'johnd', 'utils', 'src', 'test', 'fsys']
		}
	equal pathSubDirs(relPath, o'!relative'), {
		dir: 'C:/Users/johnd/utils/src/test/fsys'
		root: "C:/"
		lParts: ['Users', 'johnd', 'utils', 'src', 'test', 'fsys']
		}

	# --- relative, try both full and relative paths
	equal pathSubDirs(fullPath, o'relative'), {
		dir: "src/test/fsys"
		root: ""
		lParts: ['src', 'test', 'fsys']
		}
	equal pathSubDirs(relPath, o'relative'), {
		dir: "src/test/fsys"
		root: ""
		lParts: ['src', 'test', 'fsys']
		}

	# --- Default is not relative
	equal pathSubDirs(fullPath), {
		dir: 'C:/Users/johnd/utils/src/test/fsys'
		root: "C:/"
		lParts: ['Users', 'johnd', 'utils', 'src', 'test', 'fsys']
		}
	equal pathSubDirs(relPath), {
		dir: 'C:/Users/johnd/utils/src/test/fsys'
		root: "C:/"
		lParts: ['Users', 'johnd', 'utils', 'src', 'test', 'fsys']
		}
	)()

DBG "myself()"

equal myself(import.meta.url), 'src/test/fsys.lib.test.ts'

# ---------------------------------------------------------------------------
# ---------------------------------------------------------------------------

DBG "slurp(path)"

equal slurp('./src/test/fsys/file1.txt'), """
	line1
	line2
	line3
	"""

barfPath := 'src/test/fsys/barfed.txt'

DBG "barf(path, contents)"

(() =>
	contents := """
		abc

		xyz
		"""

	barf barfPath, contents
	equal slurp(barfPath), """
		abc

		xyz
		"""
	)()

DBG "isExt(str)"

truthy isExt('.something')
falsy  isExt('./windows/temp.txt')

DBG "newerDestFileExists(srcPath, destPath)"

truthy newerDestFileExists('src/test/fsys/file1.txt', barfPath)
falsy  newerDestFileExists(barfPath, 'src/test/fsys/file1.txt')

DBG "mkDir()"

falsy  isDir('src/test/fsys/tempdir')
falsy  isFile('src/test/fsys/tempdir/file42.txt')
mkDir 'src/test/fsys/tempdir'
barf 'src/test/fsys/tempdir/file42.txt', 'abc'
truthy isDir('src/test/fsys/tempdir')
truthy isFile('src/test/fsys/tempdir/file42.txt')

DBG "rmFile()"

truthy isFile(barfPath)
rmFile barfPath
falsy  isFile(barfPath)

DBG "rmDir()"

truthy isDir('src/test/fsys/tempdir')
rmDir 'src/test/fsys/tempdir', o'clear'
falsy  isDir('src/test/fsys/tempdir')

path := 'src/test/fsys/aaa/bbb/newfile.txt'

DBG "mkDirsForFile(path)"

(() =>
	mkDirsForFile path
	truthy isDir('src/test/fsys')
	truthy isDir('src/test/fsys/aaa')
	truthy isDir('src/test/fsys/aaa/bbb')
	falsy  isDir('src/test/fsys/aaa/bbb/ccc')
	truthy isFile(path)
	barf path, 'abc'
	truthy isFile(path)
	)()

DBG "clearDir(dir)"

(() =>
	setup()
	clearDir 'src/test/fsys/aaa'

	truthy isDir('src/test/fsys/aaa')
	falsy  isDir('src/test/fsys/aaa/bbb')
	falsy  isFile(path)
	)()

DBG "removeFilesMatching()"

(() =>
	setup()
	removeFilesMatching '**/*file.txt'

	falsy  isFile('src/test/fsys/aaa/newfile.txt')
	falsy  isFile('src/test/fsys/aaa/bbb/newfile.txt')
	falsy  isFile('src/test/fsys/aaa/bbb/oldfile.txt')
	truthy isFile('src/test/fsys/aaa/bbb/temp.txt')
	)()

DBG "removeFilesExcept()"

(() =>
	setup()
	lKeep := [
		'src/test/fsys/aaa/bbb/newfile.txt'
		'src/test/fsys/aaa/bbb/oldfile.txt'
		]
	removeFilesExcept '**/*file.txt', lKeep

	falsy  isFile('src/test/fsys/aaa/newfile.txt')
	truthy isFile('src/test/fsys/aaa/bbb/newfile.txt')
	truthy isFile('src/test/fsys/aaa/bbb/oldfile.txt')
	truthy isFile('src/test/fsys/aaa/bbb/temp.txt')
	)()

DBG "type TFsEventHandler", "class FileEventHandler"

(() =>
	lChanges: string[] := []
	fileChangeFunc: TFsEventHandler := (kind, path) =>
		lChanges.push kind
		return

	handler := new FileEventHandler(fileChangeFunc)
	handler.handle {
		kind: 'modify',
		paths: ['/usr/lib/temp.txt']
		}
	handler.handle {
		kind: 'modify',
		paths: ['/usr/lib/temp.txt']
		}
	handler.handle {
		kind: 'modify',
		paths: ['/usr/lib/temp2.txt']
		}
	handler.handle {
		kind: 'modify',
		paths: ['/usr/lib/temp.txt']
		}

	await sleep 2

	handler.handle {
		kind: 'modify',
		paths: ['/usr/lib/temp.txt']
		}
	handler.handle {
		kind: 'modify',
		paths: ['/usr/lib/temp.txt']
		}

	await sleep 2

	expected := [
		{kind: 'modify', paths: ['/usr/lib/temp2.txt']}
		{kind: 'modify', paths: ['/usr/lib/temp.txt']}
		{kind: 'modify', paths: ['/usr/lib/temp.txt']}
		]

	equal lChanges, expected
	)()

(() =>
	setup()

	lChanges: hash[] := []
	handler := new FileEventHandler((kind, path) =>
		lChanges.push {kind, path}
		return
		)
	handler.handle {
		kind: 'modify',
		paths: ['/usr/lib/temp.txt']
		}
	handler.handle {
		kind: 'modify',
		paths: ['/usr/lib/temp.txt']
		}
	handler.handle {
		kind: 'modify',
		paths: ['/usr/lib/temp2.txt']
		}
	handler.handle {
		kind: 'modify',
		paths: ['/usr/lib/temp.txt']
		}

	await sleep 2

	handler.handle {
		kind: 'modify',
		paths: ['/usr/lib/temp.txt']
		}
	handler.handle {
		kind: 'modify',
		paths: ['/usr/lib/temp.txt']
		}

	await sleep 2

	expected := [
		{kind: 'modify', path: '/usr/lib/temp2.txt'}
		{kind: 'modify', path: '/usr/lib/temp.txt'}
		{kind: 'modify', path: '/usr/lib/temp.txt'}
		]

	equal lChanges, expected
	)()

DBG "type TFsEventHandler", "watchFile()", "watchFiles()"

await (() =>
	# --- Set contents of dummy.txt to standard contents
	path := mkpath('src/test/fsys/dummy.txt')
	barf path, 'dummy\n'

	let doStop: boolean = false
	lChanges: hash[] := []
	add := (str: string, stop: boolean=false): void =>
		if stop
			doStop = true
		barf path, str, o'append'
		return

	callback: TFsEventHandler := (kind, path) =>
		lChanges.push {
			kind
			path
			ms: sinceLoad()
			}
		return doStop

	promise := watchFile path, callback

	add 'A'
	add 'B'
	add 'C'
	await sleep 0.3
	add 'D'
	add 'E', true

	await Promise.allSettled([promise])

	equal slurp(path), 'dummy\nABCDE'

	objListLike lChanges, [
		{kind: 'modify', path}
		{kind: 'modify', path}
		]
	)()

DBG "patchFirstLine(path, str, newstr)"

(() =>
	path1 := 'src/test/fsys/file4.cielo'
	path2 :='src/test/fsys/file5.cielo'
	patchFirstLine path1, '.cielo', '.civet'
	patchFirstLine path2, '.cielo', '.civet'
	truthy slurp(path1).includes 'file.civet'
	falsy  slurp(path2).includes 'file.civet'
	)()
