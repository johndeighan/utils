# compile.cmd.civet

import {assert, croak, isArray} from 'datatypes'
import {pass} from 'llutils'
import {OL} from 'to-nice'
import {getCmdArgs} from 'cmd-args'
import {watchFiles, allFilesMatching} from 'fsys'
import {DBG, LOG, WARN, ERR} from 'logger'
import {compileFile, TCompileResult} from 'automate'

[hArgs, lNonOptions] := getCmdArgs {
	_: """
		files to compile, as one of the following:
			'<stub>.lib'  - file <stub>.lib.<ext>
			'<stub>.cmd'  - file <stub>.cmd.<ext>
			'<stub>.lib.test'  - file <stub>.lib.test.<ext>
			'<stub>.cmd.test'  - file <stub>.cmd.test.<ext>
			- a full or relative file path
		where <ext> is a valid extension to compile
		"""
	w:    "watch for and recompile files if they change"
	}

{watch} := hArgs
let numCompiled = 0

# ---------------------------------------------------------------------------

logResult := (hResult: TCompileResult): void =>

	{path, status} := hResult
	switch status
		when 'compiled'
			LOG "COMPILED: #{OL(path)}"
			numCompiled += 1
		when 'exists'
			pass()
		else
			ERR "NOT COMPILED: #{OL(path)}"
	return

# ---------------------------------------------------------------------------

if (lNonOptions.length == 0)
	DBG "=====  Compiling all files  ====="
	for {path} of allFilesMatching('**/*.{lib,cmd}.civet')
		hResult := compileFile path
		logResult hResult
else
	# --- Files can be specified as:
	#        - <stub>.(lib|cmd)
	#        - <stub>.(lib|cmd).test
	#        - a full or relative path
	#     Multiple files can be comma-separated

	for str of lNonOptions
		DBG "non-option: #{OL(str)}"
		for str: string of str.split(',')
			if lMatches := str.match(///^
					([A-Za-z0-9_-]+)
					\.
					(lib|cmd)
					$///)
				[_, stub, purpose] := lMatches
				pat := "**/#{stub}.#{purpose}.*"
				for {path} of allFilesMatching(pat)
					DBG "compile file #{OL(path)}"
					logResult compileFile(path)
			else if lMatches := str.match(///^
					([A-Za-z0-9_-]+)
					\.
					(lib|cmd)
					\.
					test
					$///)
				[_, stub, purpose] := lMatches
				pat := "**/#{stub}.#{purpose}.test.*"
				for {path} of allFilesMatching(pat)
					DBG "compile file #{OL(path)}"
					logResult compileFile(path)
			else
				DBG "compile file #{OL(str)}"
				logResult compileFile(str)

LOG "(#{numCompiled} files compiled)"

if watch
	watchFiles Deno.cwd(), (kind, path) =>
		console.log "EVENT: #{kind} #{OL(path)}"
		return false
