# cmd-args.lib.civet

import {
	undef, defined, notdefined, assert, croak,
	hash, hashof,
	isEmpty, isArray, isBoolean, isInteger, isHash, isString,
	} from 'datatypes'
import {
	keys, getOptions, o, spaces,
	} from 'llutils'
import {OL} from 'to-nice'
import {
	TLogLevel, setLogLevel,
	} from 'log-levels'
import {LOG, DBG} from 'logger'

# ---------------------------------------------------------------------------

hKeyToLogLevel: hashof<TLogLevel> := {
	P: 'profile'
	D: 'debug'
	I: 'info'
	W: 'warn'
	E: 'error'
	S: 'silent'
	N: 'none'
	}

export logLevelFromArgs := (lArgs: string[]): TLogLevel? =>

	for str of lArgs
		lMatches := str.match(///^
			-
			([A-Za-z0-9_-]*)
			(=)?
			///)
		if defined(lMatches)
			keyStr := lMatches[1]
			hasEq := lMatches[2]
			if isEmpty(hasEq)
				for key of keys(hKeyToLogLevel)
					if keyStr.includes(key)
						return hKeyToLogLevel[key]
	return undef

# ---------------------------------------------------------------------------

/**
 * Parse command line arguments, optionally specifying which
 * options to expect and/or the expected number of non-options
 *
 * There are 3 kinds of items allowed on the command line:
 *
 * 1. flags, e.g.
 * 	`-fnx` - sets flags `f`, 'n' and `x` to true
 *    flags must be upper or lower case letters
 *
 * 2. an option with a value, e.g.
 * 	`-label=mylabel` - sets option `label` to `'mylabel'`
 * 	if the value contains a space char, it must be quoted
 * 	if the value looks like a number, it's set to a number
 *
 * 3. anything else is a non-option, e.g.
 * 	c:/temp/temp.txt
 * 	if it includes a space char or starts with `-`,
 * 		it must be quoted
 *
 * the 1st argument to getCmdArgs() is optional, and is a hash
 * of information about the expected arguments.
 *
 * If key '_' is present, it must be a hash possibly including keys:
 *    'range' - either an integer specifying the exact number of
 *              non-options expected, or an array of 2 integers
 *              specifying the minimum and maximum number of
 *              non-options expected.
 *    'desc' - a text description of what non-options are
 *
 * All other keys are names of options allowed
 *    the associated value
 * must be a hash with possibly these keys:
 *    type - the type of value expected (defaults to 'boolean')
 *    desc - a text description of the option (used on help screens)
 *
 * the 2nd argument to getCmdArgs() is an array of string arguments
 * from the command line (defaults to Deno.args)
 *
 * the 3rd argument to getCmdArgs() is a hash of possible options:
 *    doSetLogger - defaults to true - if false, then options
 *                  -P, -D, -Q, -I and -S no longer set logging options
 *                  and may therefore be used for other purposes
 *
 * By default, the following flags are recognized, and therefore
 * cannot be included in hDesc (this behavior can be
 * disabled by setting hOptions.doSetLogger to false):
 *
 * `-P` - set the current log level to 'profile'
 * `-D` - set the current log level to 'debug'
 * `-Q` - set the current log level to 'warn'
 * `-I` - set the current log level to 'info'
 * `-S` - set the current log level to 'silent'
 *
 * (see library @jdeighan/logger)
 */

type TCmdArgs = {
	[key: string]: unknown
	}

# --- Return a hash of args and an array of non-options

export getCmdArgs := (
	hDesc: hash? = undef,
	lArgs: string[] = Deno.args,
	hOptions: hash = {}
	): [TCmdArgs, string[]] =>

	type opt = {
		doSetLogger: boolean
		}
	{doSetLogger} := getOptions<opt> hOptions, {
		doSetLogger: true
		}

	if doSetLogger && defined(hDesc)
		# --- Make sure hDesc does NOT include any of:
		#        P, D, Q, I, S
		for key of keys(hKeyToLogLevel)
			assert notdefined(hDesc[key]),
					"invalid key #{OL(key)} set in hDesc"
		logLevel := logLevelFromArgs(lArgs)
		if defined(logLevel)
			setLogLevel logLevel

	if defined(hDesc)
		DBG "hDesc is: #{OL(hDesc)}"
	DBG "lArgs is: #{OL(lArgs)}"

	if ((lArgs.length == 1)
			&& ['-h','--h','-help','--help'].includes(lArgs[0])
			)
		if defined(hDesc)
			LOG helpStr(hDesc)
		else
			LOG "No help available"
		Deno.exit(0)

	hResult: TCmdArgs := {}
	lNonOptions: string[] := []

	# --- Utility functions

	# --- Even gets called for -D, -Q, -P, -S
	addOption := (name: string, value: string | boolean) =>
		DBG "addOption(#{OL(name)}, #{OL(value)})"
		assert (name not in hResult),
				"dup key #{name}, hResult = #{OL(hResult)}"

		if doSetLogger
			logger := hKeyToLogLevel[name]
			if defined(logger)
				hResult[name] = true
				setLogLevel logger
				return

		if notdefined(hDesc)
			hResult[name] = value
			return
		{type} := getOptionInfo(hDesc, name)

		# --- type checking
		if isArray(type)
			assert type.includes(value), "type not an array"
			hResult[name] = value
		else if isBoolean(value)
			hResult[name] = value
		else
			# --- it's a string
			float := parseFloat(value)
			if (Number.isNaN(float))
				hResult[name] = value
			else
				hResult[name] = float
		return

	addNonOption := (str: string) =>
		DBG "addNonOption(#{OL(str)})"
		lNonOptions.push str

	for str of lArgs
		# --- ignore '--'
		if (str == '--')
			DBG "skipping --"
			continue

		# --- check if it's an option
		lMatches := str.match(///^
			-
			([A-Za-z0-9_-]*)
			(?:
				(=)
				(.*)
				)?
			$///)
		if (lMatches == null)
			# --- it's a non-option
			addNonOption str
		else
			# --- it's an option
			[_, optStr, eqStr, valueStr] := lMatches
			if eqStr
				addOption optStr, valueStr
			else
				for ch of optStr.split('')
					addOption ch, true

	# --- if hDesc is set, then
	#     Fill in default values if available

	if defined(hDesc)
		# --- Fill in missing keys with default values
		DBG "Filling in missing keys with default values"
		for name of keys(hDesc, o'except=_')
			if notdefined(hResult[name])
				{defaultVal} := getOptionInfo(hDesc, name)
				if defined(defaultVal)
					hResult[name] = defaultVal

		# --- Check of there's a restriction on the number of non-options
		if ('_' in hDesc) && isArray(hResult._)
			len := hResult._.length
			DBG "Check number of non-options (#{len})"
			hInfo := getNonOptionInfo(hDesc)
			DBG "Non-option info: #{OL(hInfo)}"
			if defined(hInfo)
				{min, max} := hInfo
				if defined(hInfo.min)
					assert (len >= hInfo.min), "#{len} non-options < min (#{hInfo.min})"
				if defined(hInfo.max)
					assert (len <= hInfo.max), "#{len} non-options > max (#{hInfo.max})"

	DBG "hResult = #{OL(hResult)}"
	DBG "lNonOptions = #{OL(lNonOptions)}"
	return [hResult, lNonOptions]

# ---------------------------------------------------------------------------

export getOptionInfo := (hDesc: hash, name: string): hash =>

	# --- Return value is a hash with keys: type, desc

	assert (name != '_'), "getOptionInfo(hDesc, '_') called"
	assert (name in hDesc), "No such option: -#{name}"
	h := isHash(hDesc[name]) ? hDesc[name] : {desc: hDesc[name]}
	if notdefined(h.type)
		h.type = (name.length == 1) ? 'boolean' : 'string'
	if notdefined(h.desc)
		h.desc = '<no description available>'
	if ('defaultVal' not in h) && (h.type == 'boolean')
		h.defaultVal = false
	return h

# ---------------------------------------------------------------------------
# --- returns undef if no '_' key in hDesc

type TNonOptionInfo = {
	desc: string
	min: number
	max: number
	}

export getNonOptionInfo := (hDesc: hash): TNonOptionInfo? =>

	DBG "hDesc = #{OL(hDesc)}"
	if ('_' not in hDesc)
		DBG "No '_' key in hDesc"
		return undef
	h := hDesc._
	if not isHash(h)
		DBG "hDesc._ not a hash"
		return undef
	let {desc, range} = h
	realDesc := (
		  isEmpty(desc)  ? '<no description available>'
		: isString(desc) ? desc
		: "<bad _ description>"
		)
	DBG "desc = #{desc}"
	if notdefined(range)
		DBG "No range key"
		return {
			desc: realDesc
			min: 0
			max: Number.MAX_SAFE_INTEGER
			}

	DBG "range = #{OL(range)}"
	if isInteger(range)
		DBG "Integer range: #{range}"
		return {
			desc: realDesc
			min: range
			max: range
			}
	else if isArray(range)
		assert (range.length == 2), "Bad '_' key: #{OL(range)}"
		[min, max] := range
		DBG "Array range: #{min}..#{max}"
		if isInteger(min) && isInteger(max)
			return {
				desc: realDesc
				min
				max
				}
		else
			croak "range min or max not an integer: #{OL(min)}..#{OL(max)}"
	else
		croak "Invalid range: #{OL(range)}"

# ---------------------------------------------------------------------------

cntStr := (n: number, str: string): string =>
	return (n==1) ? "1 #{str}" : "#{n} #{str}s"

export helpStr := (hDesc: hash): string =>

	lLines := ["Available options:"]
	push := (str: string, level: number=0): void =>
		lLines.push spaces(3*level) + str

	for name of keys(hDesc, {lExcept: '_'})
		{type, desc} := getOptionInfo(hDesc, name)
		push "-#{name}: #{type} - #{desc}", 1
	if defined(hDesc._)
		push "Non-options:"
		hInfo := getNonOptionInfo(hDesc)
		if defined(hInfo)
			{desc, min, max} := hInfo
			push desc, 1
			if (min == max)
				push "There must be exactly #{min} non-options", 1
			else
				if (min > 0)
					push "There must be at least #{cntStr(min, 'non-option')}", 1
				if (max < Number.MAX_SAFE_INTEGER)
					push "There must be at most #{cntStr(max, 'non-option')}", 1
		else
			croak "Bad descriptor for '_'"
	return lLines.join('\n')
