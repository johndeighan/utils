# indent.lib.civet

import {
	undef, defined, notdefined, assert, croak, array,
	isString, isArray, isArrayOfStrings, hash, hashof, isHash,
	integer, isInteger,
	} from 'datatypes'
import {
	rtrim, countChars, escapeStr, getOptions,
	blockToArray, arrayToBlock, toArray, toBlock,
	widthOf, heightOf, blockify, keys,
	} from 'llutils'

export let oneIndent: string? = undef

# ---------------------------------------------------------------------------

export resetOneIndent := (str: string?=undef): void =>

	oneIndent = str
	return

# ---------------------------------------------------------------------------

export indentLevel := (line: string): number =>

	# --- This will always match, and it's greedy
	#     (but TypeScript doesn't know that)
	[prefix] := line.match(/^\s*/) || ['']

	if (prefix.length == 0)
		return 0

	# --- Check if we're using TABs or spaces
	numTABs := countChars(prefix, "\t")
	numSpaces := countChars(prefix, " ")
	assert (numTABs==0) || (numSpaces==0),
		"Invalid mix of TABs and spaces in #{escapeStr(line)}"

	# --- oneIndent must be one of:
	#        undef
	#        a single TAB character
	#        some number of space characters

	# --- Set variables oneIndent & level
	switch oneIndent
		when undef
			if (numTABs > 0)
				oneIndent = "\t"
				return numTABs
			else
				oneIndent = ' '.repeat(numSpaces)
				return 1
		when "\t"
			assert (numSpaces==0), "Expecting TABs, found spaces"
			return numTABs
		else
			# --- using some number of spaces
			assert (numTABs == 0), "Expecting spaces, found TABs"
			assert (numSpaces % oneIndent.length == 0), """
					Invalid num spaces: #{numSpaces},
					oneIndent = #{escapeStr(oneIndent)}
					"""
			return numSpaces / oneIndent.length

# ---------------------------------------------------------------------------

export type lineDesc = [
	level: number
	text: string
	]

export splitLine := (line: string): lineDesc =>

	[_, prefix, str] := line.match(/^(\s*)(.*)$/) || ['', '', '']
	return [indentLevel(prefix), str.trim()]

# ---------------------------------------------------------------------------

export function indented(
		input: string,
		hOptions?: hash
		): string
export function indented(
		input: string[],
		hOptions?: hash
		): string[]
export function indented(
		input: string | string[],
		hOptions: hash = {}
		): string | string[] {

	# --- Because there's a global named oneIndent,
	#     we have to put the option in a new variable, i.e. 'ind'
	type opt = {
		oneIndent: string?
		level: integer
		}
	{oneIndent: ind, level} := getOptions<opt> hOptions, {
		oneIndent: undef
		level: 1
		}

	useIndent: string := (
		  defined(ind) ? ind
		: defined(oneIndent) ? oneIndent
		: '\t'
		)

	lLines: string[] := isArray(input) ? input : input.split('\n')
	lNewLines: string[] := for line of lLines
		useIndent.repeat(level) + line
	return isArray(input) ? lNewLines : lNewLines.join('\n')
	}

# ---------------------------------------------------------------------------

export undented := (input: string | string[]): string | string[] =>

	# --- input must be either a string or array of strings
	lLines := toArray(input)

	# --- NOTE: leave empty lines empty

	let toRemove: string?  = undef
	let nToRemove: number = 0
	lNewLines: string[] := []
	for line of lLines
		trimmed := rtrim(line)
		if (trimmed == '')
			lNewLines.push ''
		else if notdefined(toRemove)
			[_, prefix, rest] := trimmed.match(/^(\s*)(.*)$/) || ['','','']
			if (prefix.length == 0)
				lNewLines.push trimmed
			else
				toRemove = prefix
				nToRemove = prefix.length
				lNewLines.push rest
		else
			assert (line.indexOf(toRemove) == 0),
				"can't remove #{escapeStr(toRemove)} from #{escapeStr(line)}"
			lNewLines.push trimmed.substr(nToRemove)

	return isString(input) ? arrayToBlock(lNewLines) : lNewLines

# ---------------------------------------------------------------------------

export type TBlockDesc = string[] | {[key: string]: TBlockDesc}

export Blockify := (
		desc: TBlockDesc
		hOptions: hash = {}
		): string =>

	type opt = {
		sep: string
		endsep: string
		oneIndent: string
		width: number
		}
	{sep, endsep, width, oneIndent,
		} := getOptions<opt> hOptions, {
		sep: ' '
		endsep: ''
		oneIndent: '   '
		width: 64
		}

	if isArray(desc)
		if (desc.length == 0)
			return ''    # --- has 0 height
		else
			return blockify desc, hOptions
	else
		# --- width must be reduced since block will be indented
		hOpts := {sep, endsep, oneIndent, width: width-3}

		lParts := for label of keys(desc)
			block := Blockify desc[label], hOpts
			if (heightOf(block) == 0)
				"#{label}: (none)"
			else if (heightOf(block) == 1) && (label.length + widthOf(block) < width)
				"#{label}: #{block}"
			else
				"#{label}:\n#{indented(block, {oneIndent})}"
		return lParts.join('\n')
