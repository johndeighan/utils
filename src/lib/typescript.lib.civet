# typescript.lib.civet

import {existsSync} from '@std/fs'
import {statSync} from 'node:fs'
import {
	SourceFile, Node, ScriptTarget, SyntaxKind, ModuleKind,
	NewLineKind, EmitHint, CompilerOptions, ModuleResolutionKind,
	createSourceFile, createPrinter, createProgram, transpileModule,
	getPreEmitDiagnostics, flattenDiagnosticMessageText,
	getLineAndCharacterOfPosition, forEachChild,
	} from "npm:typescript"
import {blue} from "@std/fmt/colors"

import {
	undef, defined, notdefined, integer, TStringGenerator,
	hash, hashof, isHash, TFilterFunc, isString,
	isEmpty, nonEmpty,
	} from 'datatypes'
import {
	truncStr, getOptions, spaces, o, OL, words,
	stringify,
	} from 'llutils'
import {indented} from 'indent'
import {
	LOG, DBG, LOGVALUE, INDENT, UNDENT, DBGVALUE,
	} from 'logger'
import {slurp, barf, barfTempFile} from 'fsys'
import {toNice, TMapFunc} from 'nice'
import {getCmdOutputSync} from 'exec'
import {stripSrcMap} from 'source-map'
import {getNeededImportStmts} from 'symbols'

decoder := new TextDecoder("utf-8")

# ---------------------------------------------------------------------------
# ---------------------------------------------------------------------------

type TExportDesc = {
	name: string
	kind?: string
	}

# ---------------------------------------------------------------------------

export allExportsIn := (
		tsCode: string
		): Generator<TExportDesc, void, void> ->

	yield {name: 'dummy'}
	return

# ---------------------------------------------------------------------------

export allExportsInFile := (
		path: string
		): Generator<TExportDesc, void, void> ->

	yield* allExportsIn(slurp(path))
	return

# ---------------------------------------------------------------------------
# ---------------------------------------------------------------------------

type TImportDesc = {
	name: string
	kind?: string
	}

# ---------------------------------------------------------------------------

export allImportsIn := (
		tsCode: string
		): Generator<TImportDesc, void, void> ->

	yield {name: 'dummy'}
	return

# ---------------------------------------------------------------------------

export allImportsInFile := (
		path: string
		): Generator<TImportDesc, void, void> ->

	yield* allImportsIn(slurp(path))
	return

# ---------------------------------------------------------------------------

export kindStr := (i: number): string =>

	return SyntaxKind[i]

# ---------------------------------------------------------------------------

export tsMapFunc: TMapFunc := (
		key: string
		val: unknown
		): unknown =>

	if (key == 'kind') && (typeof val == 'number')
		return kindStr(val)
	return val

# ---------------------------------------------------------------------------

export ts2ast := (
		tsCode: string,
		hOptions: hash = {}
		): SourceFile =>

	type opt = {
		fileName: string
		}
	{fileName} := getOptions<opt> hOptions, {
		fileName: 'temp.ts'
		}

	tsCode = stripSrcMap(tsCode)[0]
	hAst := createSourceFile(fileName, tsCode, ScriptTarget.Latest)
	filter: TFilterFunc := (x: unknown) =>
		return (
			   (typeof x == 'object')
			&& (x != null)
			&& ('kind' in x)
			&& (typeof x.kind == 'number')
			)
	return hAst

# ---------------------------------------------------------------------------

export ast2ts := (node: SourceFile): string =>

	printer := createPrinter {newLine: NewLineKind.LineFeed}
	return printer.printNode EmitHint.Unspecified, node, node

# ---------------------------------------------------------------------------

export typeCheckFiles := (
		lFileNames: string | string[],
		hOptions: CompilerOptions = hDefConfig
		): string[] =>

	if (typeof lFileNames == 'string')
		lFileNames = [lFileNames]
	program := createProgram(lFileNames, hOptions)
	emitResult := program.emit()

	lMsgs: string[] := []
	getPreEmitDiagnostics(program).forEach (diag) =>
		{file, start, messageText} := diag
		msg := flattenDiagnosticMessageText messageText, "\n"
		if (file)
			{fileName} := file
			{line, character} := getLineAndCharacterOfPosition file, start!
			lMsgs.push "#{fileName}:(#{line+1}:#{character+1}): #{msg}"
		else
			lMsgs.push msg
	return lMsgs

export typeCheckFile = typeCheckFiles   # --- synonym

# ---------------------------------------------------------------------------

export astAsString := (
		hAst: SourceFile
		hOptions: hash = {}
		): string =>

	return toNice hAst, {
		ignoreEmptyKeys: true
		mapFunc: tsMapFunc
		lExclude: words(
			'pos end id flags modifierFlagsCache'
			'transformFlags hasExtendedUnicodeEscape'
			'numericLiteralFlags setExternalModuleIndicator'
			'languageVersion languageVariant jsDocParsingMode'
			'hasNoDefaultLib'
			)
		}

# ---------------------------------------------------------------------------

export typeCheckCode := (
		tsCode: string
		): string[]? =>

	# --- We must place the TypeScript file at the project root
	#     so that paths gotten from .symbols resolve correctly

	path := "./_typecheck_.ts"
	barf path, tsCode
	hResult := getCmdOutputSync 'deno', [
			'check',
			'--import-map', 'import_map.jsonc',
			path
			]
	{success, code, stdout, stderr} := hResult
	if success && (code == 0)
		return []
	else if defined(stderr)
		return [stderr]
	else
		return ['Unknown error']

# ---------------------------------------------------------------------------

export checkType := (
		value: unknown
		typeStr: string
		expectSuccess: boolean = true
		): string[] =>

	DBG "CALL checkType():", INDENT

	tsCode := getTsCode typeStr, stringify(value)
	DBGVALUE 'tsCode', tsCode

	# --- check if we need to import the type
	importCode := getImportCode(typeStr)
	DBGVALUE 'importCode', importCode

	code := "#{importCode}\n#{tsCode}"
	lDiagnostics := typeCheckCode(code)
	if expectSuccess && nonEmpty(lDiagnostics)
		LOG "typeCheckCode FAILED:"
		LOG "CODE:"
		LOG code
		LOGVALUE 'lDiagnostics', lDiagnostics
	else if not expectSuccess && isEmpty(lDiagnostics)
		LOG "typeCheckCode SUCCEEDED:"
		LOG "CODE:"
		LOG code
	DBG UNDENT
	return lDiagnostics || []

# ---------------------------------------------------------------------------
# --- We need to add ':unknown' to any function parameters
#     that don't have an explicit type

export getTsCode := (
		typeStr: string
		valueStr: string
		): string =>

	DBGVALUE 'typeStr', typeStr
	DBGVALUE 'valueStr', valueStr
	result := splitFuncStr(valueStr)
	if defined(result)
		[lParms, body] := result
		addType := (parm: string) =>
			if (parm.indexOf(':') >= 0)
				return parm
			else
				return "#{parm}: unknown"
		parmStr := lParms.map(addType).join(', ')
		return "const x: #{typeStr} = (#{parmStr}) => #{body}"
	else
		return "const x: #{typeStr} = #{valueStr}"

# ---------------------------------------------------------------------------

type splitResult = [string[], string]

export splitFuncStr := (
		valueStr: string
		): splitResult? =>

	if lMatches := valueStr.match(///^
			\(
			([^\)]*)
			\) \s* [\=\-]\>
			\s*
			(.*)
			$///)
		[_, strParms, strBody] := lMatches
		if isEmpty(strParms)
			return [[], strBody]
		else
			return [
				strParms.split(',').map((x) => x.trim())
				strBody
				]
	else
		return undef

# ---------------------------------------------------------------------------

export getImportCode := (
		typeStr: string
		): string =>

	DBG "CALL getImportCode()"
	lSymbols := getSymbolsFromType(typeStr)
	DBGVALUE 'lSymbols', lSymbols
	if nonEmpty(lSymbols)
		lStmts := getNeededImportStmts(lSymbols)
		DBGVALUE 'lStmts', lStmts
		return lStmts.join('\n')
	else
		return ''

# ---------------------------------------------------------------------------

export getSymbolsFromType := (typeStr: string): string[] =>

	if lMatches := typeStr.match(///^
			([A-Za-z][A-Za-z0-9+]*)
			(?:
				\<
				([A-Za-z][A-Za-z0-9+]*)
				\>
				)?
			$///)
		[_, type, subtype] := lMatches
		return nonEmpty(subtype) ? [type, subtype] : [type]
	else if lMatches := typeStr.match(///^
			\( \)                         # ()
			\s*
			\= \>                         # =>
			\s*
			([A-Za-z][A-Za-z0-9+]*)       # an identifier
			$///)
		return [lMatches[1]]
	else
		return []

# ---------------------------------------------------------------------------

hDefConfig: CompilerOptions := {
	"allowJs": false,
	"allowUmdGlobalAccess": false,
	"allowUnreachableCode": false,
	"allowUnusedLabels": false,
	"alwaysStrict": true,
	"assumeChangesOnlyAffectDirectDependencies": false,
	"checkJs": false,
	"composite": false,
	"declaration": false,
	"declarationDir": undefined,
	"declarationMap": false,
	"emitBOM": false,
	"emitDeclarationOnly": false,
	"exactOptionalPropertyTypes": false,
	"experimentalDecorators": false,
	"forceConsistentCasingInFileNames": true,
	"generateCpuProfile": null,
	"generateTrace": null,
	"ignoreDeprecations": "5.0",
	"importHelpers": false,
	"inlineSourceMap": false,
	"inlineSources": false,
	"isolatedModules": false,
#	"jsx": "react-jsx",
#	"jsxFactory": "React.createElement",
#	"jsxFragmentFactory": "React.Fragment",
#	"jsxImportSource": "react",
	"lib": [
		"esnext",
		"dom",
		"dom.iterable"
	],
	"mapRoot": undefined,
	"maxNodeModuleJsDepth": 0,
	"module": ModuleKind.ESNext,
	"moduleDetection": undefined,
	"moduleResolution": ModuleResolutionKind.NodeNext,
	"newLine": NewLineKind.LineFeed,
	"noEmit": true,
	"noEmitHelpers": false,
	"noEmitOnError": false,
	"noErrorTruncation": false,
	"noFallthroughCasesInSwitch": true,
	"noImplicitAny": true,
	"noImplicitOverride": true,
	"noImplicitReturns": true,
	"noImplicitThis": true,
	"noPropertyAccessFromIndexSignature": true,
	"noUncheckedIndexedAccess": true,
	"noUnusedLocals": true,
	"noUnusedParameters": true,
	"outDir": undefined,
	"outFile": undefined,
	"paths": {},
	"preserveConstEnums": false,
	"preserveSymlinks": false,
	"preserveValueImports": false,
	"reactNamespace": "React",
	"removeComments": false,
	"resolveJsonModule": true,
	"rootDir": undefined,
	"rootDirs": [],
	"skipDefaultLibCheck": false,
	"skipLibCheck": false,
	"sourceMap": false,
	"sourceRoot": undefined,
	"strict": true,
	"strictBindCallApply": true,
	"strictFunctionTypes": true,
	"strictNullChecks": true,
	"strictPropertyInitialization": true,
	"stripInternal": false,
	"suppressExcessPropertyErrors": false,
	"suppressImplicitAnyIndexErrors": false,
	"target": ScriptTarget.ES2022,
	"traceResolution": false,
	"tsBuildInfoFile": undefined,
	"typeRoots": [],
	"useDefineForClassFields": true,
	"useUnknownInCatchVariables": true
	}
