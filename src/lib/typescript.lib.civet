# typescript.lib.civet

import {existsSync} from '@std/fs'
import {statSync} from 'node:fs'
import {
	SourceFile, Node, ScriptTarget, SyntaxKind, ModuleKind,
	NewLineKind, EmitHint, CompilerOptions, ModuleResolutionKind,
	createSourceFile, createPrinter, createProgram, transpileModule,
	getPreEmitDiagnostics, flattenDiagnosticMessageText,
	getLineAndCharacterOfPosition, forEachChild,
	} from "npm:typescript"

import {hash, isHash} from 'datatypes'
import {truncStr, hasKey, getOptions} from 'llutils'
import {DBG, LOGVALUE} from 'logger'
import {TNodeInfo, getAstWalker} from 'ast-walker'

decoder := new TextDecoder("utf-8")

# ---------------------------------------------------------------------------

/**
 * getCode(str) - return contents of file if str is a file path
 *    else return str
 */

export getCode := (str: string): string =>

	if ((str.indexOf('\n') == -1)
			&& str.match(/\.[A-Za-z0-9]+$/)
			&& existsSync(str)
			&& statSync(str).isFile()
			)
		data := Deno.readFileSync(str)
		return decoder.decode(data)
	else
		return str

# ---------------------------------------------------------------------------

/**
 * ts2ast() - convert TypeScript code to an AST
 */

export ts2ast := (
		str: string,
		hOptions: hash = {}
		): SourceFile =>

	type opt = {
		addNames: boolean
		}
	{addNames} := getOptions<opt> hOptions, {
		addNames: true
		}

	tsCode := getCode str
	hAst := createSourceFile("temp.ts", tsCode, ScriptTarget.Latest)
	filter := (x: any) =>
		return (
			   (typeof x == 'object')
			&& (x != null)
			&& hasKey(x, 'kind')
			&& (typeof x.kind == 'number')
			)
	if addNames
		walker := getAstWalker(hAst, filter)
		for item of walker()
			{node} := item
			if (typeof node == 'object') && (node != null) && ('kind' in node)
				{kind} := node
				if (typeof kind == 'number')
					item.kindStr = SyntaxKind[kind]
	return hAst

# ---------------------------------------------------------------------------

/**
 * ts2js() - convert TypeScript code to JavaScript code
 */

export ts2js := (str: string): string =>

	tsCode := getCode str
	hOptions := {
		compilerOptions: {
			module: ModuleKind.ES2022
			}
		}
	return transpileModule(tsCode, hOptions).outputText.trim()

# ---------------------------------------------------------------------------

export ast2ts := (node: SourceFile): string =>

	printer := createPrinter {newLine: NewLineKind.LineFeed}
	return printer.printNode EmitHint.Unspecified, node, node

# ---------------------------------------------------------------------------

export ast2js := (node: SourceFile): string =>

	return ts2js(ast2ts(node))

# ---------------------------------------------------------------------------

export typeCheckFiles := (
		lFileNames: string | string[],
		hOptions: CompilerOptions = hDefConfig
		): string[] =>

	if (typeof lFileNames == 'string')
		lFileNames = [lFileNames]
	program := createProgram(lFileNames, hOptions)
	emitResult := program.emit()

	lMsgs: string[] := []
	getPreEmitDiagnostics(program).forEach (diag) =>
		{file, start, messageText} := diag
		msg := flattenDiagnosticMessageText messageText, "\n"
		if (file)
			{fileName} := file
			{line, character} := getLineAndCharacterOfPosition file, start!
			lMsgs.push "#{fileName}:(#{line+1}:#{character+1}): #{msg}"
		else
			lMsgs.push msg
	return lMsgs

export typeCheckFile = typeCheckFiles   # --- synonym

# ---------------------------------------------------------------------------

type TNodePrinter = (src: SourceFile, n: Node, depth: number) => string

pprintNode := (
		source: SourceFile,
		node: Node,
		depth: number
		): string =>

	kind := SyntaxKind[node.kind]
	text := node.getText(source).replaceAll('\n', '\\n')
	pre := ' '.repeat(3 * depth)
	return "#{pre}#{kind} - '#{truncStr(text, 32)}'"

# ---------------------------------------------------------------------------

export pprintAST := (
		source: SourceFile,
		pprint: TNodePrinter = pprintNode
		): string =>

	lLines: string[] := []

	traverse := (node: Node, depth=0): void =>
		line := pprint(source, node, depth)
		lLines.push line
		forEachChild node, (childNode) => traverse(childNode, depth + 1)
		return

	traverse source
	return lLines.join('\n')

# ---------------------------------------------------------------------------

hDefConfig: CompilerOptions := {
	"allowJs": false,
	"allowUmdGlobalAccess": false,
	"allowUnreachableCode": false,
	"allowUnusedLabels": false,
	"alwaysStrict": true,
	"assumeChangesOnlyAffectDirectDependencies": false,
	"checkJs": false,
	"composite": false,
	"declaration": false,
	"declarationDir": undefined,
	"declarationMap": false,
	"emitBOM": false,
	"emitDeclarationOnly": false,
	"exactOptionalPropertyTypes": false,
	"experimentalDecorators": false,
	"forceConsistentCasingInFileNames": true,
	"generateCpuProfile": null,
	"generateTrace": null,
	"ignoreDeprecations": "5.0",
	"importHelpers": false,
	"inlineSourceMap": false,
	"inlineSources": false,
	"isolatedModules": false,
#	"jsx": "react-jsx",
#	"jsxFactory": "React.createElement",
#	"jsxFragmentFactory": "React.Fragment",
#	"jsxImportSource": "react",
	"lib": [
		"esnext",
		"dom",
		"dom.iterable"
	],
	"mapRoot": undefined,
	"maxNodeModuleJsDepth": 0,
	"module": ModuleKind.ESNext,
	"moduleDetection": undefined,
	"moduleResolution": ModuleResolutionKind.NodeNext,
	"newLine": NewLineKind.LineFeed,
	"noEmit": true,
	"noEmitHelpers": false,
	"noEmitOnError": false,
	"noErrorTruncation": false,
	"noFallthroughCasesInSwitch": true,
	"noImplicitAny": true,
	"noImplicitOverride": true,
	"noImplicitReturns": true,
	"noImplicitThis": true,
	"noPropertyAccessFromIndexSignature": true,
	"noUncheckedIndexedAccess": true,
	"noUnusedLocals": true,
	"noUnusedParameters": true,
	"outDir": undefined,
	"outFile": undefined,
	"paths": {},
	"preserveConstEnums": false,
	"preserveSymlinks": false,
	"preserveValueImports": false,
	"reactNamespace": "React",
	"removeComments": false,
	"resolveJsonModule": true,
	"rootDir": undefined,
	"rootDirs": [],
	"skipDefaultLibCheck": false,
	"skipLibCheck": false,
	"sourceMap": false,
	"sourceRoot": undefined,
	"strict": true,
	"strictBindCallApply": true,
	"strictFunctionTypes": true,
	"strictNullChecks": true,
	"strictPropertyInitialization": true,
	"stripInternal": false,
	"suppressExcessPropertyErrors": false,
	"suppressImplicitAnyIndexErrors": false,
	"target": ScriptTarget.ES2022,
	"traceResolution": false,
	"tsBuildInfoFile": undefined,
	"typeRoots": [],
	"useDefineForClassFields": true,
	"useUnknownInCatchVariables": true
	}
