# to-nice.lib.civet

import {cyan, blue} from "@std/fmt/colors"

import {sep} from 'base-utils'
import {
	assert, croak, undef, defined, notdefined, hash, hashof,
	isString, isArray, isClass, isRegExp, isPrimitive,
	isEmpty, nonEmpty, assertIsHash, integer,
	symbolName, className, functionName, regexpDef,
	} from 'datatypes'
import {
	getOptions, escapeStr, o, toBlock, spaces, mapEachLine,
	} from 'llutils'

export type TCompareFunc = (a: string, b: string) => number

# ---------------------------------------------------------------------------

export alphaCompare: TCompareFunc := (
		a: string,
		b: string
		): number =>

	return (a < b) ? -1 : (a > b) ? 1 : 0

# ---------------------------------------------------------------------------
# --- any leading digit must be preceded by a single '\'

export toNiceString := (str: string): string =>

	# --- escape spaces and \t, \n or \r with unicode chars

	str1 := escapeStr(str)

	# --- precede with '\' if starts with digit, '.' or '-'
	#                      or looks like a label

	str2 := str1.match(/^[\d.-]/) ? "\\#{str1}" : str1
	str3 := str2.match(/^[^˳\s]+:/) ? "\\#{str2}" : str2
	return str3

# ---------------------------------------------------------------------------

# --- Returns a function that:
#        compares 2 strings based on their position in lSortKeys
#        else compares alphabetically

getCompareFunc := (
		lSortKeys: string[]
		): TCompareFunc =>

	# --- Create map of key to number
	h: hashof<number> := {}
	for key,i of lSortKeys
		h[key] = i+1

	return (a: string, b: string): number ->
		aVal := h[a]
		bVal := h[b]

		if defined(aVal)
			if defined(bVal)
				# --- compare numerically
				return (aVal < bVal) ? -1 : (aVal > bVal) ? 1 : 0
			else
				return -1
		else
			if defined(bVal)
				return 1
			else
				return alphaCompare(a, b)

# ---------------------------------------------------------------------------

export rotpos := <T>(lArray: T[], i: integer): T =>

	return lArray[i % lArray.length]

# ---------------------------------------------------------------------------

indented := (block: string, oneIndent: string) =>

	return mapEachLine(block, (line) => oneIndent + line)

# ---------------------------------------------------------------------------

export type TPathIndex = string | number

export buildPath := (lPath: TPathIndex[]): string =>

	let str = 'root'
	for item of lPath
		if isString(item)
			str += ".#{item}"
		else
			str += "[#{item.toString()}]"
	return str

# ---------------------------------------------------------------------------

export type TMapFunc = (
	key: string
	value: unknown
	hParent: hash
	) => unknown

export emptyMapFunc := (
		key: string
		value: unknown
		hParent: hash
		): unknown =>
	return undef

export toNice := (
		x: unknown,
		hOptions: hash={}
		mapVisited: Map<object, string> = new Map<object, string>()
		lPath: TPathIndex[] = []
		): string =>

	# --- When recoverable, classes and functions
	#     include their definitions,
	#     with escaped chars

	type opt = {
		compact: boolean
		recoverable: boolean
		ignoreEmptyValues: boolean
		sortKeys: boolean
		sortFunc: TCompareFunc?
		mapFunc: TMapFunc
		lInclude: string[]?
		lExclude: string[]?
		lIndents: string[]
		}
	{		compact
			recoverable
			ignoreEmptyValues
			sortKeys
			sortFunc
			mapFunc
			lInclude
			lExclude
			lIndents
		} := getOptions<opt> hOptions, {
		compact: false
		recoverable: false
		ignoreEmptyValues: false
		sortKeys: false
		sortFunc: undef
		mapFunc: emptyMapFunc
		lInclude: undef
		lExclude: undef
		lIndents: ['   ', '❘  ']
		}

	# --- You can provide sortKeys or a sortFunc, but not both
	assert not (sortKeys && defined(sortFunc)), "Bad options"

	switch typeof x
		when 'undefined'
			return '.undef'

		when 'boolean'
			return x ? '.true' : '.false'

		when 'number'
			return (
				  Number.isNaN(x)    ? '.NaN'
				: Number.isFinite(x) ? x.toString()
				: ((x < 0) ? '.neginf' : '.inf')
				)

		when 'bigint'
			return x.toString() + 'n'

		when 'string'
			return toNiceString(x)

		when 'symbol'
			name := symbolName(x)
			return name ? ".symbol #{name}" : '.symbol'

		when 'function'
			if isClass(x)
				return ".class #{className(x)}"
			else
				return ".function #{functionName(x)}"

		when 'object'
			if (x == null)
				return '.null'

			if isRegExp(x)
				return ".regexp #{escapeStr(regexpDef(x))}"

			# --- Check if object was previously visited
			prevpath := mapVisited.get x
			if prevpath
				return ".ref #{prevpath}"

			if isArray(x)
				if (x.length == 0)
					return '[]'

				mapVisited.set x, buildPath(lPath)
				lLines := []
				for val,i of x
					block := toNice(
							val,
							hOptions,
							mapVisited,
							[lPath..., i]
							)
					if compact
						lLines.push block
					else if isPrimitive(val) || block.startsWith('.') || isEmpty(val)
						lLines.push "- #{block}"
					else
						lLines.push '-'
						oneIndent := rotpos<string>(lIndents, lPath.length)
						lLines.push indented(block, oneIndent)
				if compact
					return '[' + lLines.join(' ') + ']'
				else
					return toBlock(lLines)

			# --- It's an object
			if (x instanceof Set)
				lKeys := for key of x.keys()
					toNice key
				return (
					  (lKeys.length == 0)
					? ".emptySet"
					: ".set #{lKeys.join(' ')}"
					)

			if (x instanceof Map)
				lLines := for [key, val] of x.entries()
					"#{toNice(key)}:: #{toNice(val)}"
				return lLines.join('\n')

			lKeys := Object.keys(x)
			if (lKeys.length == 0)
				return '{}'

			func: TCompareFunc? := (
				  defined(sortFunc) ? sortFunc
				: defined(lInclude) ? getCompareFunc(lInclude)
				: sortKeys          ? alphaCompare
				:                     undef
				)

			useKey := (key: unknown): boolean =>
				if (typeof key != 'string')
					return false
				if defined(lExclude) && lExclude.includes(key)
					return false
				if defined(lInclude) && not lInclude.includes(key)
					return false
				return true

			mapVisited.set x, buildPath(lPath)

			assertIsHash x    # --- will allow us to index with any string

			lLines := []
			for key of (defined(func) ? lKeys.sort(func) : lKeys).filter(useKey)
				val := x[key]
				if not ignoreEmptyValues || nonEmpty(val)
					mapped := recoverable ? undef : mapFunc(key, val, x)
					newval := mapped || val
					block := isString(mapped) ? mapped : toNice(
							newval,
							hOptions,
							mapVisited,
							[lPath..., key]
							)
					if (
								compact
							|| (defined(newval) && isPrimitive(newval))
							|| block.startsWith('.')
							|| isEmpty(newval)
							)
						lLines.push "#{key}: #{block}"
					else
						lLines.push "#{key}:"
						oneIndent := rotpos<string>(lIndents, lPath.length)
						lLines.push indented(block, oneIndent)
			if compact
				return '{' + lLines.join(' ') + '}'
			else
				return toBlock(lLines)

	return "<Unknown object #{x}>"

# ---------------------------------------------------------------------------

export OL := (x: unknown): string =>

	return toNice x, {compact: true}

# ---------------------------------------------------------------------------

export ML := (x: unknown): string =>

	return toNice x, {compact: false}

# ---------------------------------------------------------------------------

export DUMP := (
		x: unknown
		label: string? = undef
		hOptions: hash = {}
		): void =>

	type opt = {
		width: number
		char: string
		}
	{width, char} := getOptions<opt> hOptions, {
		width: 64
		char: '-'
		}

	console.log sep(label, char, width)
	if isString x
		if nonEmpty x
			console.log x
	else
		console.log toNice(x, hOptions)
	console.log sep(undef, char, width)
	return
