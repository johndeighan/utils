# exec.lib.civet

import fs from 'node:fs'
import {stripAnsiCode} from "@std/fmt/colors"
import {
	CompilerOptions, ScriptTarget, ModuleKind, CompilerHost,
	createSourceFile, createProgram, getPreEmitDiagnostics,
	flattenDiagnosticMessageText, createCompilerHost,
	} from "npm:typescript"

import {
	undef, defined, notdefined, assert, croak, hash,
	isString, isArray, isArrayOfStrings,
	} from 'datatypes'
import {
	getOptions, OL, pass, blockToArray,
	} from 'llutils'
import {
	barf,
	} from 'fsys'
import {
	getLogLevel, pushLogLevel, popLogLevel,
	DBG, LOG, WARN, ERR, LOGVALUE,
	INDENT, UNDENT,
	} from 'logger'

/**
 * @module exec-utils - utilities for executing external code
 */

textDecoder := new TextDecoder()

# ---------------------------------------------------------------------------

/**
 * convert ArrayBuffer, Int8Array, etc. to a string
 */

export mkstr := (item: any): string =>

	if isString(item)
		return stripAnsiCode(item)
	else if isArray(item)
		return stripAnsiCode(item.join(''))
	else if (item instanceof ArrayBuffer)
		return stripAnsiCode(textDecoder.decode(item))
	else if (item instanceof Int8Array)
		return stripAnsiCode(textDecoder.decode(item))
	return ''

# ---------------------------------------------------------------------------

/**
 * build a command line from a command name and array of arguments
 */

export getCmdLine := (cmdName: string, lArgs: string[]): string =>

	assert isString(cmdName), "cmdName not a string: #{OL(cmdName)}"
	assert isArrayOfStrings(lArgs), "not an array of strings: #{OL(lArgs)}"
	cmdLine := "#{cmdName} #{lArgs.join(' ')}"
	DBG "cmdLine = #{OL(cmdLine)}"
	return cmdLine

# ---------------------------------------------------------------------------

/**
 * build result hash to be returned by execCmd() or execCmdSync()
 */

export type TExecResult = {
	success: boolean
	code: number
	signal: string?
	stdout: string?
	stderr: string?
	}

# ---------------------------------------------------------------------------

/**
 * get options to pass to Deno.Command constructor
 * 2nd argument determines whether stdout and stderr are
 * sent to parent process's stdout and stderr or are
 * collected to be returned to the caller
 */

export getProcOpt := (
	lArgs: string[],
	collect: boolean
	): Deno.CommandOptions =>

	hEnv: hash := {
		DEFAULT_LOGGER: getLogLevel()
		}

	return if collect
		{
			args: lArgs,
			env: {DEFAULT_LOGGER: getLogLevel()}
			stdout: 'piped'
			stderr: 'piped'
			}
	else
		{
			args: lArgs,
			env: {DEFAULT_LOGGER: getLogLevel()}
			stdout: 'inherit'
			stderr: 'inherit'
			}

# ---------------------------------------------------------------------------
# ASYNC

export execCmd := (
	cmdName: string,
	lArgs: string[] = [],
	hOptions: hash = {}
	): TExecResult =>

	type opt = {
		collect: boolean
		nolog: boolean
		}
	{collect, nolog} := getOptions<opt> hOptions, {
		collect: false
		nolog: false
		}
	if nolog
		pushLogLevel 'silent'

	DBG "EXEC: #{OL(getCmdLine(cmdName, lArgs))}"
	DBG INDENT
	hProcOpt := getProcOpt(lArgs, collect)
	child := new Deno.Command(cmdName, hProcOpt)
	DBG UNDENT
	{success, code, signal, stdout, stderr} := await child.output();
	if nolog
		popLogLevel()
	return {
		success
		code
		signal: signal || undef
		stdout: collect ? mkstr(stdout) : undef
		stderr: collect ? mkstr(stderr) : undef
		}

# ---------------------------------------------------------------------------

export execCmdSync := (
	cmdName: string,
	lArgs: string[] = [],
	hOptions: hash = {}
	): TExecResult =>

	type opt = {
		collect: boolean
		nolog: boolean
		}
	{collect, nolog} := getOptions<opt> hOptions, {
		collect: false
		nolog: false
		}
	if nolog
		pushLogLevel 'silent'
	DBG "EXEC SYNC: #{OL(getCmdLine(cmdName, lArgs))}"
	DBG INDENT
	hProcOpt := getProcOpt(lArgs, collect)
	child := new Deno.Command(cmdName, hProcOpt)
	DBG UNDENT
	{success, code, signal, stdout, stderr} := child.outputSync()
	if nolog
		popLogLevel()
	return {
		success
		code
		signal: signal || undef
		stdout: collect ? mkstr(stdout) : undef
		stderr: collect ? mkstr(stderr) : undef
		}

# ---------------------------------------------------------------------------

export cmdSucceeds := (
	cmdName: string,
	lArgs: string[] = [],
	hOptions: hash = {}
	): boolean =>

	type opt = {
		quiet: boolean
		}
	{quiet} := getOptions<opt> hOptions, {
		quiet: true
		}
	try
		h := quiet ? {collect: true, nolog: true} : {}
		execCmdSync cmdName, lArgs, h
		return true
	catch err
		return false

# ---------------------------------------------------------------------------

getErrorMsgs := (stderr: string?): string[] =>

	if notdefined(stderr)
		return ['Unknown error']
	else
		lMsgs := (
			for line of blockToArray(stderr)
				if lMatches := line.match(/// \[ ERROR \] : \s* (.*)$///)
					lMatches[1]
				else
					undef
			).filter((x) => defined(x))
		if (lMsgs.length == 0)
			return ['Unknown error']
		else
			return lMsgs

# ---------------------------------------------------------------------------

/**
 * type checks TypeScript code, and returns
 * an array of diagnostic messages if errors are found
 */

export typeCheck := (
		tsCode: string
		): string[]? =>

	# --- We must place the TypeScript file at the project root
	#     so that paths gotten from .symbols resolve correctly

	path := "./_typecheck_.ts"
	barf path, tsCode
	hResult := execCmdSync 'deno', ['check', path], {collect: true}
	{success, code, stdout, stderr} := hResult
	if success && (code == 0)
		return []
	else
		return getErrorMsgs(stderr)

# ---------------------------------------------------------------------------
