# exec.lib.civet

import fs from 'node:fs'
import {stripAnsiCode} from "@std/fmt/colors"
import {
	CompilerOptions, ScriptTarget, ModuleKind, CompilerHost,
	createSourceFile, createProgram, getPreEmitDiagnostics,
	flattenDiagnosticMessageText, createCompilerHost,
	} from "npm:typescript"

import {
	undef, defined, notdefined, assert, croak, hash,
	isString, isArray, isArrayOfStrings,
	} from 'datatypes'
import {
	getOptions, OL, pass, blockToArray,
	} from 'llutils'
import {
	getLogLevel, pushLogLevel, popLogLevel,
	DBG, LOG, WARN, ERR, LOGVALUE,
	INDENT, UNDENT, DBGVALUE, DBGLABELED,
	} from 'logger'
import {
	barf,
	} from 'fsys'

/**
 * @module exec - utilities for executing external code
 */

textDecoder := new TextDecoder()

# ---------------------------------------------------------------------------

/**
 * convert ArrayBuffer, Int8Array, etc. to a string
 */

export mkstr := (item: (string | BufferSource)?): string =>

	if isString(item)
		return stripAnsiCode(item)
	else if isArray(item)
		return stripAnsiCode(item.join(''))
	else
		return stripAnsiCode(textDecoder.decode(item))

# ---------------------------------------------------------------------------

/**
 * build a command line from a command name and array of arguments
 */

export getCmdLine := (cmdName: string, lArgs: string[]): string =>

	assert isString(cmdName), "cmdName not a string: #{OL(cmdName)}"
	assert isArrayOfStrings(lArgs), "not an array of strings: #{OL(lArgs)}"
	cmdLine := "#{cmdName} #{lArgs.join(' ')}"
	DBG "cmdLine = #{OL(cmdLine)}"
	return cmdLine

# ---------------------------------------------------------------------------

/**
 * build result hash to be returned by execCmd() or execCmdSync()
 */

export type TExecResult = {
	success: boolean
	code: number
	signal: string?
	stdout?: string
	stderr?: string
	}

# ---------------------------------------------------------------------------
# ASYNC

export execCmd := (
	cmdName: string,
	lArgs: string[] = [],
	): TExecResult =>

	DBGLABELED "EXEC", "#{OL(getCmdLine(cmdName, lArgs))}"
	DBG INDENT
	child := new Deno.Command(cmdName, {
		args: lArgs,
		env: {DEFAULT_LOGGER: getLogLevel()}
		stdout: 'inherit'
		stderr: 'inherit'
		})
	{success, code, signal} := await child.output()
	DBG UNDENT
	return {
		success
		code
		signal: signal || undef
		}

# ---------------------------------------------------------------------------

export type TCmdDesc = [string, string[]]

export execCmds := (
		lCmds: TCmdDesc[]
		): TExecResult[] =>

	lPromises := for [cmdName, lArgs] of lCmds
		execCmd cmdName, lArgs

	lResults := await Promise.all(lPromises)
	return lResults

# ---------------------------------------------------------------------------

export execCmdSync := (
	cmdName: string,
	lArgs: string[] = [],
	): TExecResult =>

	DBGLABELED "EXEC SYNC", "#{OL(getCmdLine(cmdName, lArgs))}"
	DBG INDENT
	child := new Deno.Command(cmdName, {
		args: lArgs,
		env: {DEFAULT_LOGGER: getLogLevel()}
		stdout: 'inherit'
		stderr: 'inherit'
		})
	{success, code, signal} := child.outputSync()
	DBG UNDENT
	return {
		success
		code
		signal: signal || undef
		}

# ---------------------------------------------------------------------------
# ASYNC

export getCmdOutput := (
	cmdName: string,
	lArgs: string[] = [],
	): TExecResult =>

	DBGLABELED "EXEC(collect)", "#{OL(getCmdLine(cmdName, lArgs))}"
	DBG INDENT
	child := new Deno.Command(cmdName, {
		args: lArgs,
		env: {DEFAULT_LOGGER: getLogLevel()}
		stdout: 'piped'
		stderr: 'piped'
		})
	{success, code, signal, stdout, stderr} := await child.output()
	DBG UNDENT
	return {
		success
		code
		signal: signal || undef
		stdout: mkstr(stdout)
		stderr: mkstr(stderr)
		}

# ---------------------------------------------------------------------------

export getCmdOutputSync := (
	cmdName: string,
	lArgs: string[] = [],
	): TExecResult =>

	DBGLABELED "EXEC SYNC(collect)", "#{OL(getCmdLine(cmdName, lArgs))}"
	DBG INDENT
	child := new Deno.Command(cmdName, {
		args: lArgs,
		env: {DEFAULT_LOGGER: getLogLevel()}
		stdout: 'piped'
		stderr: 'piped'
		})
	{success, code, signal, stdout, stderr} := child.outputSync()
	DBG UNDENT
	return {
		success
		code
		signal: signal || undef
		stdout: mkstr(stdout)
		stderr: mkstr(stderr)
		}

# ---------------------------------------------------------------------------

export cmdSucceeds := (
	cmdName: string,
	lArgs: string[] = [],
	hOptions: hash = {}
	): boolean =>

	type opt = {
		quiet: boolean
		}
	{quiet} := getOptions<opt> hOptions, {
		quiet: true
		}
	try
		if not quiet
			pushLogLevel 'silent'
		getCmdOutputSync cmdName, lArgs
		if not quiet
			popLogLevel()
		return true
	catch err
		return false

# ---------------------------------------------------------------------------
