# parser.lib.civet

import {sprintf} from "@std/fmt/printf"
import {
	undef, defined, notdefined, hash,
	} from './datatypes.lib.ts'
import {
	getOptions, escapeStr, spaces,
	} from './llutils.lib.ts'
import {logIndent} from './log-formatter.lib.ts'
import {
	getLogLevel, setLogLevel,
	pushLogLevel, popLogLevel, DBG, INDENT, UNDENT,
	} from './logger.lib.ts'

# ---------------------------------------------------------------------------

export type TState = {
	text: string
	ignore: any[]
	lMatches?: string[]
	stack: any[]
	sp: number
	lastPos: number
	pos: number
	}

export type TRule = ($: TState) => TState

# --- Anything that can be converted to a TRule
type TLaxRule = (string | RegExp | TRule | TLaxRule[])

type TReducer<T> = (lMatches: T[], $: TState, $next: TState) => T?
type TCallback = ($: TState, $next: TState) => void

# ---------------------------------------------------------------------------

export function getNewState(
		text: string
		pos: number = 0
		): TState

	return {
		text
		ignore: []
		stack: []
		sp: 0
		lastPos: 0
		pos
		}

# ---------------------------------------------------------------------------

nbuf := 24

DBGMATCH := (
		desc: string    # Describe what we're trying to match
		$: TState
		$next: TState
		): void =>

	str := escapeStr($.text.substring($.pos, $next.pos))
	buf := spaces(nbuf - str.length - 1 - 3*logIndent)
	DBG "[+#{sprintf('%3d', $.pos)}] #{str}#{buf}#{desc}"
	return

# ---------------------------------------------------------------------------

DBGNOMATCH := (
		desc: string    # Describe what we're trying to match
		$: TState
		): void =>

	buf := spaces(nbuf - 3*logIndent)
	DBG "[-#{sprintf('%3d', $.pos)}]#{buf}#{desc}"
	return

# ---------------------------------------------------------------------------

export RegexMatcher := (re: RegExp): TRule =>

	return ($: TState): TState =>

		$.lastPos = $.pos

		lMatches := re.exec($.text.substring($.pos))
		if (not lMatches)
			DBGNOMATCH re.toString(), $
			return $

		# --- Token is matched, add matches to state,
		#     return the next state
		numChars := lMatches[0].length
		$next := {
			...$,
			pos: $.pos + numChars,
			}
		$.lMatches = lMatches
		DBGMATCH re.toString(), $, $next
		return $next

# ---------------------------------------------------------------------------

export StringMatcher := (str: string): TRule =>

	return ($: TState): TState =>

		$.lastPos = $.pos
		if ($.text.startsWith(str, $.pos))
			$next := {
				...$,
				pos: $.pos + str.length
				}
			DBGMATCH "'#{escapeStr(str)}'", $, $next
			return $next
		else
			DBGNOMATCH "'#{escapeStr(str)}'", $
			return $

# ---------------------------------------------------------------------------

export function getRule(rule: TLaxRule): TRule

	if Array.isArray(rule)
		lRules := rule.map(getRule)
		return StrictAll(lRules)
	if (typeof(rule) == 'function')
		return rule
	if (rule instanceof RegExp)
		return RegexMatcher(rule)
	if (typeof(rule) == 'string')
		return StringMatcher(rule)
	throw new Error('Invalid rule')

# ---------------------------------------------------------------------------

skipIgnored := ($: TState): TState =>

	return ($.ignore.length == 0) ? $ : $.ignore.at(-1)($)

# ---------------------------------------------------------------------------
# --- Match a sequence of rules left to right

export function All(
		lLaxRules: TLaxRule[]
		hOptions: hash = {}
		): TRule

	lRules := lLaxRules.map getRule
	return StrictAll(lRules, hOptions)

# ---------------------------------------------------------------------------

export function StrictAll(
		lRules: TRule[]
		hOptions: hash = {}
		): TRule

	{name} := getOptions hOptions, {
		name: undef
		}
	return ($) =>
		DBG "Try: #{(name || 'All')}", INDENT
		let $cur = $
		for rule,i of lRules
			$before := (i > 0) ? skipIgnored($cur) : $cur
			$after := rule($before)
			if ($after == $before)
				# --- if one rule fails: fail all
				DBG 'FAIL', UNDENT
				return $

#			if ($after.pos > $before.pos)
#				# --- All() should fail if all rules match,
#				#     but no progress is made
			$cur = $after
			DBG ".....#{i}"
		DBG UNDENT
		return $cur

# ---------------------------------------------------------------------------
# --- Match any of the rules
#     with left-to-right preference

export function Any(
		lLaxRules: TLaxRule[]
		hOptions: hash = {}
		): TRule

	lRules := lLaxRules.map getRule
	{name} := getOptions hOptions, {
		name: undef
		}
	return ($) =>
		DBG "Try: #{(name || 'Any')}", INDENT
		for rule,i of lRules
			$next := rule($)
			if ($next != $)
				DBG UNDENT
				return $next
			DBG ".....#{i}"
		DBG UNDENT
		return $

# ---------------------------------------------------------------------------
# --- Match a rule 1 or more times

export function Plus(laxRule: TLaxRule): TRule

	rule := getRule laxRule
	return ($) =>
		while (true)
			$cur := skipIgnored($)
			$next := rule($cur)
			if ($next == $cur)
				return $
			$ = $next

# ---------------------------------------------------------------------------
# --- Match a rule optionally

export function Optional(laxRule: TLaxRule): TRule

	rule := getRule laxRule
	return ($) =>
		$next := rule($)
		if ($next != $)
			return $next

		# --- Otherwise return a shallow copy
		#     of the state to still indicate a match
		return {...$}

# ---------------------------------------------------------------------------

export function Star(laxRule: TLaxRule): TRule

	return Optional(Plus(laxRule))

# ---------------------------------------------------------------------------

export function Node<T>(
		laxRule: TLaxRule,
		reducer: TReducer<T>
		): TRule

	rule := getRule laxRule
	return ($) =>
		$next := rule($)
		if ($next == $)
			return $

		# --- We have a match
		node := reducer($.stack.slice($.sp, $next.sp), $, $next)
		$next.sp = $.sp
		if (node != null)
			$.stack[$next.sp++] = node
		return $next

# ---------------------------------------------------------------------------

export getLineAndColumn := (text: string, pos: number) =>

	countChars := (str: string, ch: string): number =>
		let count = 0
		let pos = -1
		while (pos = str.indexOf(ch, pos+1)) != -1
			count += 1
		return count


	# --- Get line number by counting number of \n chars
	#        before the current position
	#     Get column number by finding closest previous position
	#        of a \n and computing the difference

	shortStr := text.substring(0, pos)
	return [
		countChars(shortStr, "\n") + 1,
		pos - shortStr.lastIndexOf('\n')
		]

# ---------------------------------------------------------------------------

type TStringMapper<T> = (str: string) => T

# ---------------------------------------------------------------------------

export function Ignore(
		laxToIgnore: TLaxRule,
		laxRule: TLaxRule
		): TRule

	rule := getRule laxRule
	toIgnore := getRule laxToIgnore
	return ($: TState) =>
		$cur := toIgnore($)
		$.ignore.push(toIgnore)
		$next := rule($cur)
		$.ignore.pop()
		return ($next == $cur) ? $ : toIgnore($next)

# ---------------------------------------------------------------------------
# --- Returns a function that:
#        1. accepts a string
#        2. returns a T

export function getParser<T>(
		laxRule: TLaxRule
		hOptions: hash = {}
		): TStringMapper<T>

	{pos, partial, reSkip} := getOptions hOptions, {
		pos: 0
		partial: false
		reSkip: /^\s+/
		}
	rule := defined(reSkip) ? Ignore(reSkip, laxRule) : getRule laxRule

	return (text: string): T =>
		$ := getNewState(text, pos)
		$next := rule($)

		if ($ == $next)
			[line, column] := getLineAndColumn(text, $.pos)
			throw new SyntaxError("""
				No match at pos #{$.lastPos}
				Remainder: #{escapeStr(text.slice($.pos))}
				""")
		if not partial && ($next.pos < text.length)
			# --- Not all input consumed
			[line, column] := getLineAndColumn(text, $.pos)
			throw new SyntaxError("""
				Stopped at pos #{$.lastPos}
				Remainder: #{escapeStr(text.slice($.pos))}
				""")
		return $.stack[0]
