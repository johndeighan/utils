# parser.lib.civet

import {sprintf} from "@std/fmt/printf"

import {
	undef, defined, notdefined,
	char, array, hash, isEmpty, nonEmpty,
	} from './datatypes.lib.ts'
import {
	getOptions, escapeStr, spaces,
	} from './llutils.lib.ts'
import {logIndent} from './log-formatter.lib.ts'
import {
	getLogLevel, setLogLevel,
	DBG, INDENT, UNDENT,
	TFormatter, TreeLogger,
	} from './logger.lib.ts'

# ---------------------------------------------------------------------------
# --- generator

labelGen := (): Generator<string, void, void> ->

	for ch of ['A'..'Z']
		for ch2 of ['', 'A'..'Z']
			yield ch + ch2
	return

# --- Create an iterator from the generator
labels := labelGen()

export randomLabel := (): string =>
	label := labels.next()
	return label.done ? 'ERR!' : label.value

# ---------------------------------------------------------------------------

export class State
	text: string = ''
	pos: number = 0

	# --- optional fields
	skipRule?: Rule
	lMatches?: string[]
	stack?: any[]
	logr?: TreeLogger<[State, State]>

	constructor(
			src: string | State
			n: number = 0
			hProps: Object = {}
			)
		if (typeof src == 'string')
			@text = src
			@pos = n
			Object.assign(@, hProps)
		else
			Object.assign(@, src)
			@.pos += n

export isFinished := ($: State): boolean =>
	{text, pos, skipRule} := $
	if (pos == text.length)
		return true
	else if (skipRule)
		# --- try running skip rule
		delete $.skipRule     # prevent rule running the skip rule
		$next := skipRule.next($)
		if defined($next)
			return ($next.pos == $next.text.length)
		else
			return false
	else
		return false

export type TRuleFunc = ($: State) => State?
export type TCallback = () => void

class Rule
	type: string
	func: TRuleFunc
	label: string = randomLabel()
	lChildren: Rule[] = []
	lCallbacks: TCallback[] = []

	constructor(
			type: string,
			func: TRuleFunc,
			lChildren: Rule[] = []
			)
		@type = type
		@func = func
		@lChildren = []

	addCallback(cb: TCallback): Rule
		@lCallbacks.push cb
		return @

	next($: State): State?
		return @func($)

# --- Anything that can be converted to a Rule
type TLaxRule = (string | RegExp | Rule)

# ---------------------------------------------------------------------------

nbuf := 24
digs := 1

DBGMATCH := (
		desc: string    # Describe what we're trying to match
		$: State
		$next: State
		): void =>

	str := escapeStr($.text.substring($.pos, $next.pos))
	buf := spaces(nbuf - str.length - 1 - 3*logIndent)
	i := sprintf("%#{digs}d", $.pos)
	DBG "[#{i} +] #{str}#{buf}#{desc}"
	return

# ---------------------------------------------------------------------------

DBGNOMATCH := (
		desc: string    # Describe what we're trying to match
		$: State
		): void =>

	buf := spaces(nbuf - 3*logIndent)
	i := sprintf("%#{digs}d", $.pos)
	DBG "[#{i} -]#{buf}#{desc}"
	return

# ---------------------------------------------------------------------------
# --- returns $ if no skip rule OR rule doesn't match

skipIgnored := ($: State): State =>

	# --- Will always return a defined value
	{skipRule} := $
	if notdefined(skipRule)
		return $

	# --- make sure skip is only tried once
	delete($.skipRule)
	$next := skipRule.next($)
	if defined($next)
		$.skipRule = skipRule    # still need to restore
		return Object.assign $next, {skipRule}
	else
		return Object.assign $, {skipRule}

# ---------------------------------------------------------------------------

export RegexMatcher := (
		re: RegExp
		cb: TCallback? = undef
		): Rule =>

	func := ($: State): State? =>

		$cur := skipIgnored($)
		lMatches := re.exec($cur.text.substring($cur.pos))
		if defined(lMatches)

			# --- Token is matched, add matches to state,
			#     return the next state
			numChars := lMatches[0].length
			$next := new State($cur, numChars)
			$.lMatches = lMatches
			DBGMATCH re.toString(), $cur, $next
			return $next
		else
			DBGNOMATCH re.toString(), $cur
			return undef
	newRule := new Rule('r', func)
	return defined(cb) ? newRule.addCallback(cb) : newRule

# ---------------------------------------------------------------------------

export StringMatcher := (
		str: string
		cb: TCallback? = undef
		): Rule =>

	func := ($: State): State? =>

		$cur := skipIgnored($)
		if ($cur.text.startsWith(str, $cur.pos))
			$next := new State($cur, str.length)
			DBGMATCH "'#{escapeStr(str)}'", $cur, $next
			return $next
		else
			DBGNOMATCH "'#{escapeStr(str)}'", $cur
			return undef
	newRule := new Rule('s', func)
	return defined(cb) ? newRule.addCallback(cb) : newRule

# ---------------------------------------------------------------------------

export function getRule(
		laxRule: TLaxRule
		cb: TCallback? = undef
		): Rule

	if (laxRule instanceof Rule)
		return defined(cb) ? laxRule.addCallback(cb) : laxRule
	if (laxRule instanceof RegExp)
		return RegexMatcher(laxRule, cb)
	if (typeof laxRule == 'string')
		return StringMatcher(laxRule, cb)
	throw new Error("Invalid rule: #{laxRule}")

# ---------------------------------------------------------------------------
# --- Match a sequence of rules in order

export function All(
		lLaxRules: TLaxRule[]
		cb: TCallback? = undef
		): Rule

	lRules := for laxRule of lLaxRules
		getRule laxRule
	func := ($: State) =>
		DBG 'All', INDENT
		for rule,i of lRules
			DBG "-----"
			$next := rule.next($)
			if notdefined($next)
				DBG 'FAIL', UNDENT
				return undef
			$ = $next

		DBG 'OK', UNDENT
		return $
	newRule := new Rule('&', func, lRules)
	return defined(cb) ? newRule.addCallback(cb) : newRule

# ---------------------------------------------------------------------------
# --- Match any of the rules, check left to right

export function Any(
		lLaxRules: TLaxRule[]
		cb: TCallback? = undef
		): Rule

	lRules := for laxRule of lLaxRules
		getRule laxRule
	func := ($: State) =>
		DBG 'Any', INDENT
		for rule,i of lRules
			DBG "-----"
			$next := rule.next($)
			if defined($next)
				DBG 'OK', UNDENT
				return $next
		DBG 'FAIL', UNDENT
		return undef
	newRule := new Rule('|', func, lRules)
	return defined(cb) ? newRule.addCallback(cb) : newRule

# ---------------------------------------------------------------------------
# --- Match a rule 1 or more times

export function Plus(
		laxRule: TLaxRule
		cb: TCallback? = undef
		): Rule

	rule := getRule(laxRule)
	func := ($: State) =>
		DBG "+", INDENT
		$first := rule.next($)
		if notdefined($first)
			DBG "FAIL", UNDENT
			return undef
		$ = $first
		loop
			$next := rule.next($)
			if notdefined($next)
				DBG "OK", UNDENT
				return $next
			$ = $next
	newRule := new Rule('+', func, [rule])
	return defined(cb) ? newRule.addCallback(cb) : newRule

# ---------------------------------------------------------------------------
# --- Match a rule optionally

export function Optional(
		laxRule: TLaxRule
		cb: TCallback? = undef
		): Rule

	rule := getRule(laxRule)
	func := ($: State) =>
		DBG "?", INDENT
		$next := rule.next($)
		if defined($next)
			DBG "OK - matched", UNDENT
			return $next
		else
			# --- Still succeed since it was optional
			DBG "OK - not matched", UNDENT
			return $
	newRule := new Rule('?', func, [rule])
	return defined(cb) ? newRule.addCallback(cb) : newRule

# ---------------------------------------------------------------------------

export function Star(
		laxRule: TLaxRule
		cb: TCallback? = undef
		): Rule

	rule := getRule(laxRule)
	func := ($: State) =>
		DBG "*", INDENT
		loop
			$next := rule.next($)
			if notdefined($next)
				DBG "OK", UNDENT
				return $
			$ = $next
	newRule := new Rule('*', func, [rule])
	return defined(cb) ? newRule.addCallback(cb) : newRule

# ---------------------------------------------------------------------------

type TReducer<T> = (
	$: State
	$next: State
	) => T?

export function Node<T>(
		laxRule: TLaxRule,
		reducer: TReducer<T>
		): Rule

	rule := getRule laxRule
	func := ($: State) =>
		$next := rule.next($)
		if notdefined($next)
			return $

		# --- We have a match
		node := reducer($, $next)
		if defined(node)
			if $next.stack
				$next.stack.push node
			else
				$next.stack = [node]
		return $next
	return new Rule('N', func, [rule])

# ---------------------------------------------------------------------------

export getLineAndColumn := (text: string, pos: number) =>

	countChars := (str: string, ch: string): number =>
		let count = 0
		let pos = -1
		while (pos = str.indexOf(ch, pos+1)) != -1
			count += 1
		return count


	# --- Get line number by counting number of \n chars
	#        before the current position
	#     Get column number by finding closest previous position
	#        of a \n and computing the difference

	shortStr := text.substring(0, pos)
	return [
		countChars(shortStr, "\n") + 1,
		pos - shortStr.lastIndexOf('\n')
		]

# ---------------------------------------------------------------------------
# --- Returns a function that:
#        1. accepts a string
#        2. returns given type

type TParser<T> = (str: string) => T?

export function getParser<T>(
		laxRule: TLaxRule
		hOptions: hash = {}
		): TParser<T>

	{pos, partial, reSkip, callback} := getOptions hOptions, {
		pos: 0
		partial: false
		reSkip: /^\s+/
		callbacks: []
		}
	rule := getRule laxRule

	return (text: string): T? =>
		DBG "parse #{escapeStr(text)}"
		skipRule := defined(reSkip) ? RegexMatcher(reSkip) : undef

		$ := new State(text, 0, {skipRule})

		$next := rule.next($)
		for func of rule.lCallbacks
			func()

		if defined($next) && (isFinished($next) || partial)
			return $next.stack ? $next.stack[0] : undef
		else
			[line, column] := getLineAndColumn(text, $.pos)
			throw new SyntaxError("""
				No match at pos #{$.pos}
				Remainder: #{escapeStr(text.slice($.pos))}
				""")
