# parser.lib.civet

import {
	undef, defined, notdefined, assert, hash, hashof,
	isArray, isFunction, isString, isRegExp, isHash,
	} from 'datatypes'
import {
	getOptions, escapeStr, spaces, randomLabel, OL,
	getLineAndColumn,
	} from 'llutils'
import {
	DBG, INDENT, UNDENT,
	} from 'logger'

# ---------------------------------------------------------------------------

export type TRuleFunc = (str: string, pos: number) => number
export isRuleFunc := (x: any): x is TRuleFunc =>
	return (typeof x == 'function')

export class Rule
	type: string
	func: TRuleFunc
	label: string = randomLabel()
	lChildren: Rule[] = []

	constructor(
			type: string,
			func: TRuleFunc,
			lChildren: Rule[] = []
			)
		@type = type
		@func = func
		@lChildren = []

	next(str: string, pos: number): number
		return @func(str, pos)

# --- Anything that can be converted to a Rule
export type TLaxRule = RegExp | string | TRuleFunc | TLaxRule[] | hashof<TLaxRule>

export type TCallback = (rule: Rule, lMatches: string[]) => void

# ---------------------------------------------------------------------------
# --- Custom errors

export class ParseError extends Error

	constructor(msg: string)
		super msg
		this.name = 'ParseError'

# ---------------------------------------------------------------------------
# --- Returns a function that:
#        1. accepts a string
#        2. throws error on failure

export type TParser = (str: string) => void

export function getParser(
		laxRule: TLaxRule
		lCallbacks: TCallback[] = []
		hOptions: hash = {}
		): TParser

	type opt = {
		reSkip: RegExp
		partial: boolean
		}
	{reSkip, partial} := getOptions<opt> hOptions, {
		reSkip: /^\s+/
		partial: false
		}

	# ..........................................................
	# function that skips reSkip, if defined

	skipIgnored: TRuleFunc := (str, pos) =>

		lMatches := str.substring(pos).match reSkip
		if defined(lMatches)
			len := lMatches[0].length
			if (len > 0)
				DBG "#{len} chars skipped"
			return pos + len
		else
			return pos

	# ..........................................................
	# --- function that maps RegExp => Rule

	RegexMatcher := (re: RegExp): Rule =>

		return new Rule('r', (str, pos): number =>

			skipPos := skipIgnored(str, pos)

			lMatches := re.exec(str.substring(skipPos))
			if (lMatches == null)
				throw new ParseError "RegExp Rule not matched"

			len := lMatches[0].length
			assert (len > 0), "Zero length in regex match"
			newPos := skipPos + len
			for cb of lCallbacks
				cb(rule, lMatches)
			return newPos
			)

	# ..........................................................
	# --- function that maps string => Rule

	StringMatcher := (substr: string): Rule =>

		return new Rule('s', (str, pos): number =>

			skipPos := skipIgnored(str, pos)

			if not str.startsWith(substr, skipPos)
				throw new ParseError "String Rule not matched"

			len := substr.length
			assert (len > 0), "Zero length in regex match"
			newPos := skipPos + len
			for cb of lCallbacks
				cb(rule, [substr])
			return newPos
			)

	# ..........................................................
	# --- function that maps TRuleFunc => Rule

	FuncMatcher := (func: TRuleFunc): Rule =>

		return new Rule('f', (str, pos): number =>

			skipPos := skipIgnored(str, pos)
			newPos := func(str, skipPos)
			assert (newPos > pos), "Zero length in rule match"
			for cb of lCallbacks
				cb(rule, [str.substring(pos, newPos)])
			return newPos
			)

	# ..........................................................
	# --- function that maps TLaxRule => Rule

	getRule := (laxRule: TLaxRule): Rule =>

		if isRegExp(laxRule)
			return RegexMatcher(laxRule)

		else if isString(laxRule)
			return StringMatcher(laxRule)

		else if isRuleFunc(laxRule)
			return FuncMatcher(laxRule)

		else if isArray(laxRule)
			return All laxRule

		else
			return Any laxRule

	# ..........................................................
	# --- function that maps TLaxRule[] => Rule

	Any := (hItems: hashof<TLaxRule>): Rule =>

		lRules := for key,val in hItems
			rule := getRule(val as TLaxRule)
			rule.label = key
			rule

		return new Rule('|', (str, pos): number =>
			# --- Try each rule
			#     if any succeed, succeed & return new pos
			#     else throw error
			for rule of lRules
				try
					newPos := rule.next(str, pos)
					for cb of lCallbacks
						cb(rule, [str.substring(pos, newPos)])
					return newPos

			throw new ParseError "Any Rule not matched"
			)

	# ..........................................................
	# --- function that maps TLaxRule[] => Rule

	All := (lLaxRules: TLaxRule[]): Rule =>

		lRules := for laxRule of lLaxRules
			getRule laxRule

		return new Rule('&', (str, pos): number =>
			for rule of lRules
				try
					newPos := rule.next(str, pos)
					pos = newPos
				catch err
					throw new ParseError "All Rule not matched"

			for cb of lCallbacks
				cb(rule, [])
			return pos
			)

	# --- Return a function that throws an error
	#     if string doesn't parse

	rule := getRule laxRule
	return (str) =>
		DBG "Parse #{escapeStr(str)}", INDENT
		try
			endPos := rule.next(str, 0)
			DBG "endPos = #{endPos}"
			if (endPos == str.length) || partial
				DBG UNDENT
				return true
			finalPos := skipIgnored(str, endPos)
			DBG "finalPos = #{finalPos}", UNDENT
			if (finalPos != str.length)
				throw new ParseError("Not all input exhausted")
			return
		catch err
			DBG UNDENT
			throw err
