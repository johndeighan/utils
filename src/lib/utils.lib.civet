/**
 * utils - utility functions
 * @module
 */

# utils.lib.civet

import {
	ts2ast, ts2js, ast2ts, ast2js, typeCheckFiles, pprintAST
	getCode,
	} from 'typescript'
import {
	TStringifier, TStringParser, TAssertFunc,
	deepEqual, hashLike, undef, defined, notdefined,
	isString, char, integer, isChar, isNonEmptyString,
	isBoolean, isNumber, isInteger,
	isPrimitive, isNonPrimitive,
	isArray, isArrayOfIntegers, isArrayOfStrings,
	isHash, isFunction, isObject, isRegExp,
	isEmpty, nonEmpty, assert, croak,
	jsType, isSymbol, symbolName, functionName, functionDef,
	classDef, regexpDef,
	hash, hashof, array, arrayof,
	regexp, voidFunc, nonEmptyString,
	isClass, className, isPromise, isClassInstance, isIterable,
	TObjCompareFunc, TObjLikeFunc, TToStringFunc,
	normalizeCode, normalizeExpr,
	} from 'datatypes'
import {
	pass, stringify, OL, ML, truncStr,
	getOptions, throwsError,
	strToHash, o, s, t, removeEmptyKeys, keys,
	hasKey, hasKeys, missingKeys, merge, hit,
	spaces, tabs, rtrim, countChars,
	blockToArray, allLinesInBlock,
	TBlockSpec, isBlockSpec, toArray,
	arrayToBlock, toBlock,
	escapeStr, unescapeStr, escapeBlock,
	relpath, wsSplit, words,
	sinceLoad, sinceLoadStr, sleep, sleepSync,
	getNExtra, rpad, lpad, centered,
	TAlignment, isAlignment, alignString, zpad,
	allMatches, range,
	Fetcher, require, assertSameStr, interpolate,
	} from 'llutils'
import {
	TLogLevel, isLogLevel,
	setLogLevel, pushLogLevel, popLogLevel,
	getLogLevel, getLog,
	INDENT, UNDENT,
	DBG, LOG, WARN, ERR, LOGVALUE, DBGVALUE,
	} from 'logger'
import {TextTable} from 'text-table'
import {
	oneIndent, resetOneIndent, indentLevel, splitLine,
	indented, undented,
	} from 'indent'
import {
	TPLLToken, tkEOF, allTokensIn, allTokensInBlock, tokenTable, TTokenGenerator,
	} from 'pll'
import {
	toNice, fromNice, getPrimitive,
	} from 'nice'
import {
	isFile, isDir, fileExt, withExt,
	rmFile, rmDir, TPathType, getPathType, getStats,
	isStub, TPathInfo, parsePath, slurp, barf, barfTempFile,
	allFilesMatching, allLinesIn, watchFile, watchFiles, FileEventHandler,
	normalizePath, mkpath, pathToURL, newerDestFileExists,
	pathSubDirs, clearDir, mkDir, mkDirsForFile, lStatFields,
	myself, removeFilesMatching, removeFilesExcept,
	TWatcherCallbackFunc, TFsCallbackFunc, setDirTree,
	TFileOp, fileOpsTable, allTokensInFile,
	patchFirstLine,
	} from 'fsys'
import {
	loadSymbols, sourceLib, libsAndSymbols, getNeededImportStmts,
	} from 'symbols'
import {
	execCmd, execCmdSync, cmdSucceeds,
	mkstr, getCmdLine, getProcOpt,
	TExecResult, typeCheck,
	} from 'exec'
import {
	TTesterFunc, TCompilerFunc, TPostProcessor,
	TCompilerInfo,
	TCompilerConfig,
	userConfigPath, getCompilerConfig,
	installCmd, uninstallCmd, getCompilerInfo, getPostProcessor,
	TCompileStatus, TCompileResult, TUnitTestResult, compileFile,
	getCompilerGlobPattern, allCompilableFiles,
	runUnitTestsFor, runAllUnitTests,
	isCompilerInfo, isCompilerConfig,
	} from 'compile'
import {
	civet2ts, civet2tsFile, civet2jsFile, civet2ast,
	} from 'civet'

# ---------------------------------------------------------------------------

/**
 * converts x to a string, removing any carriage returns
 * and removing leading and trailing whitespace
 */

export normalizeStr := (x: any): string =>

	return x.toString().replaceAll('\r', '').trim()

# ---------------------------------------------------------------------------

/**
 * Remove lines from a string or array
 * pat can be a string or a regular expression
 */

export removeLines := (
	strOrArray: string | string[],
	pat: string | RegExp
	): string | string[] =>

	assert isString(pat) || isRegExp(pat),  "Bad arg 2: #{OL(pat)}"
	lLines := isString(strOrArray) ? blockToArray(strOrArray) : strOrArray
	lNewLines := (
		if (typeof pat == 'string')
			lLines.filter((line) => (line != pat))
		else
			lLines.filter((line) => (line.match(pat) == null))
		)
	if isString(strOrArray)
		return lNewLines.join('\n')
	else
		return lNewLines

# ---------------------------------------------------------------------------

hKeyToLogLevel: hashof<TLogLevel> := {
	P: 'profile'
	D: 'debug'
	I: 'info'
	W: 'warn'
	E: 'error'
	S: 'silent'
	N: 'none'
	}

export logLevelFromArgs := (lArgs: string[]): TLogLevel? =>

	for str of lArgs
		lMatches := str.match(///^
			-
			([A-Za-z0-9_-]*)
			(=)?
			///)
		if defined(lMatches)
			keyStr := lMatches[1]
			hasEq := lMatches[2]
			if isEmpty(hasEq)
				for key of keys(hKeyToLogLevel)
					if keyStr.includes(key)
						return hKeyToLogLevel[key]
	return undef

# ---------------------------------------------------------------------------

/**
 * Parse command line arguments, optionally specifying which
 * options to expect and/or the expected number of non-options
 *
 * There are 3 kinds of items allowed on the command line:
 *
 * 1. flags, e.g.
 * 	`-fnx` - sets flags `f`, 'n' and `x` to true
 *    flags must be upper or lower case letters
 *
 * 2. an option with a value, e.g.
 * 	`-label=mylabel` - sets option `label` to `'mylabel'`
 * 	if the value contains a space char, it must be quoted
 * 	if the value looks like a number, it's set to a number
 *
 * 3. anything else is a non-option, e.g.
 * 	c:/temp/temp.txt
 * 	if it includes a space char or starts with `-`,
 * 		it must be quoted
 *
 * the 1st argument to getCmdArgs() is optional, and is a hash
 * of information about the expected arguments.
 *
 * If key '_' is present, it must be a hash possibly including keys:
 *    'range' - either an integer specifying the exact number of
 *              non-options expected, or an array of 2 integers
 *              specifying the minimum and maximum number of
 *              non-options expected.
 *    'desc' - a text description of what non-options are
 *
 * All other keys are names of options allowed
 *    the associated value
 * must be a hash with possibly these keys:
 *    type - the type of value expected (defaults to 'boolean')
 *    desc - a text description of the option (used on help screens)
 *
 * the 2nd argument to getCmdArgs() is an array of string arguments
 * from the command line (defaults to Deno.args)
 *
 * the 3rd argument to getCmdArgs() is a hash of possible options:
 *    doSetLogger - defaults to true - if false, then options
 *                  -P, -D, -Q, -I and -S no longer set logging options
 *                  and may therefore be used for other purposes
 *
 * By default, the following flags are recognized, and therefore
 * cannot be included in hDesc (this behavior can be
 * disabled by setting hOptions.doSetLogger to false):
 *
 * `-P` - set the current log level to 'profile'
 * `-D` - set the current log level to 'debug'
 * `-Q` - set the current log level to 'warn'
 * `-I` - set the current log level to 'info'
 * `-S` - set the current log level to 'silent'
 *
 * (see library @jdeighan/logger)
 */

export type TCmdArgs = {
	[key: string]: unknown
	}

export getCmdArgs := (
	hDesc: hash? = undef,
	lArgs: string[] = Deno.args,
	hOptions: hash = {}
	): hash =>

	type opt = {
		doSetLogger: boolean
		}
	{doSetLogger} := getOptions<opt> hOptions, {
		doSetLogger: true
		}

	if doSetLogger && defined(hDesc)
		# --- Make sure hDesc does NOT include any of:
		#        P, D, Q, I, S
		for key of keys(hKeyToLogLevel)
			assert notdefined(hDesc[key]),
					"invalid key #{OL(key)} set in hDesc"
		logLevel := logLevelFromArgs(lArgs)
		if defined(logLevel)
			setLogLevel logLevel

	if defined(hDesc)
		DBG "hDesc is: #{OL(hDesc)}"
	DBG "lArgs is: #{OL(lArgs)}"

	if ((lArgs.length == 1)
			&& ['-h','--h','-help','--help'].includes(lArgs[0])
			)
		if defined(hDesc)
			LOG helpStr(hDesc)
		else
			LOG "No help available"
		Deno.exit()

	hResult: hash := { _: [] }

	# --- Utility functions

	# --- Even gets called for -D, -Q, -P, -S
	addOption := (name: string, value: any) =>
		DBG "addOption(#{OL(name)}, #{OL(value)})"
		assert isString(name), "Not a string: #{OL(name)}"
		assert not hasKey(hResult, name),
				"dup key #{name}, hResult = #{OL(hResult)}"

		if doSetLogger
			logger := hKeyToLogLevel[name]
			if defined(logger)
				hResult[name] = true
				setLogLevel logger
				return

		if notdefined(hDesc)
			hResult[name] = value
			return
		{type} := getOptionInfo(hDesc, name)

		# --- type checking
		if isArray(type)
			assert type.includes(value), "type not an array"
			hResult[name] = value
		else
			switch type
				when 'string'
					hResult[name] = value
				when 'boolean'
					hResult[name] = (
						  (value == 'true')  ? true
						: (value == 'false') ? false
						:                      value
						)
				when 'number','float'
					hResult[name] = parseFloat(value)
				when 'integer'
					hResult[name] = parseInt(value)
		return

	addNonOption := (str: string) =>
		DBG "addNonOption(#{OL(str)})"
		if isArray(hResult?._)
			hResult._.push str
		else
			croak "addNonOption(): '_' not an array"

	for str of lArgs
		# --- ignore '--'
		if (str == '--')
			DBG "skipping --"
			continue

		# --- check if it's an option
		lMatches := str.match(///^
			-
			([A-Za-z0-9_-]*)
			(?:
				(=)
				(.*)
				)?
			$///)
		if (lMatches == null)
			# --- it's a non-option
			addNonOption str
		else
			# --- it's an option
			[_, optStr, eqStr, value] := lMatches
			if eqStr
				addOption optStr, value
			else
				for ch of optStr.split('')
					addOption ch, true

	# --- if hDesc is set, then
	#     Fill in default values if available

	if defined(hDesc)
		# --- Fill in missing keys with default values
		DBG "Filling in missing keys with default values"
		for name of keys(hDesc, o'except=_')
			if notdefined(hResult[name])
				{defaultVal} := getOptionInfo(hDesc, name)
				if defined(defaultVal)
					hResult[name] = defaultVal

		# --- Check of there's a restriction on the number of non-options
		if hasKey(hDesc, '_') && isArray(hResult._)
			len := hResult._.length
			DBG "Check number of non-options (#{len})"
			hInfo := getNonOptionInfo(hDesc)
			DBG "Non-option info: #{OL(hInfo)}"
			if defined(hInfo)
				{min, max} := hInfo
				if defined(hInfo.min)
					assert (len >= hInfo.min), "#{len} non-options < min (#{hInfo.min})"
				if defined(hInfo.max)
					assert (len <= hInfo.max), "#{len} non-options > max (#{hInfo.max})"

	DBG "hResult = #{OL(hResult)}"
	return hResult

# ---------------------------------------------------------------------------

export getOptionInfo := (hDesc: hash, name: string): hash =>

	# --- Return value is a hash with keys: type, desc

	assert (name != '_'), "getOptionInfo(hDesc, '_') called"
	assert hasKey(hDesc, name), "No such option: -#{name}"
	h := isHash(hDesc[name]) ? hDesc[name] : {desc: hDesc[name]}
	if notdefined(h.type)
		h.type = (name.length == 1) ? 'boolean' : 'string'
	if notdefined(h.desc)
		h.desc = '<no description available>'
	if not hasKey(h, 'defaultVal') && (h.type == 'boolean')
		h.defaultVal = false
	return h

# ---------------------------------------------------------------------------
# --- returns undef if no '_' key in hDesc

type TNonOptionInfo = {
	desc: string
	min: number
	max: number
	}

export getNonOptionInfo := (hDesc: hash): TNonOptionInfo? =>

	DBG "hDesc = #{OL(hDesc)}"
	if not hasKey(hDesc, '_')
		DBG "No '_' key in hDesc"
		return undef
	h := hDesc._
	if not isHash(h)
		DBG "hDesc._ not a hash"
		return undef
	let {desc, range} = h
	realDesc := (
		  isEmpty(desc)  ? '<no description available>'
		: isString(desc) ? desc
		: "<bad _ description>"
		)
	DBG "desc = #{desc}"
	if notdefined(range)
		DBG "No range key"
		return {
			desc: realDesc
			min: 0
			max: Number.MAX_SAFE_INTEGER
			}

	DBG "range = #{OL(range)}"
	if isInteger(range)
		DBG "Integer range: #{range}"
		return {
			desc: realDesc
			min: range
			max: range
			}
	else if isArray(range)
		assert (range.length == 2), "Bad '_' key: #{OL(range)}"
		[min, max] := range
		DBG "Array range: #{min}..#{max}"
		if isInteger(min) && isInteger(max)
			return {
				desc: realDesc
				min
				max
				}
		else
			croak "range min or max not an integer: #{OL(min)}..#{OL(max)}"
	else
		croak "Invalid range: #{OL(range)}"

# ---------------------------------------------------------------------------

cntStr := (n: number, str: string): string =>
	return (n==1) ? "1 #{str}" : "#{n} #{str}s"

export helpStr := (hDesc: hash): string =>

	lLines := ["Available options:"]
	push := (str: string, level: number=0): void =>
		lLines.push spaces(3*level) + str

	for name of keys(hDesc, o'except=_')
		{type, desc} := getOptionInfo(hDesc, name)
		push "-#{name}: #{type} - #{desc}", 1
	if defined(hDesc._)
		push "Non-options:"
		hInfo := getNonOptionInfo(hDesc)
		if defined(hInfo)
			{desc, min, max} := hInfo
			push desc, 1
			if (min == max)
				push "There must be exactly #{min} non-options", 1
			else
				if (min > 0)
					push "There must be at least #{cntStr(min, 'non-option')}", 1
				if (max < Number.MAX_SAFE_INTEGER)
					push "There must be at most #{cntStr(max, 'non-option')}", 1
		else
			croak "Bad descriptor for '_'"
	return lLines.join('\n')
