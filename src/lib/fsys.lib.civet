# fsys.lib.civet

import {debounce} from '@std/async/debounce'
import {
	existsSync, emptyDirSync, ensureDirSync,
	} from '@std/fs'
import {
	appendFileSync,
	} from 'node:fs'
import {EventEmitter} from 'node:events'

# --- Deno's statSync and lstatSync are still unstable,
#     so use this
import {statSync} from 'node:fs'

import {expandGlobSync} from '@std/fs/expand-glob'
import {TextLineStream} from '@std/streams'

# --- Use Deno's path library
import {
	parse, resolve, relative, fromFileUrl,
	} from '@std/path'

import {
	slurp,
	} from 'base-utils'
import {
	undef, defined, notdefined, assert, croak, isEmpty, nonEmpty,
	isString, isNonEmptyString, isBoolean, isNumber, isInteger,
	isArray, isArrayOfStrings, isHash, isRegExp,
	integer, hash, voidFunc,
	} from 'datatypes'
import {
	getOptions, removeEmptyKeys, pass,
	spaces, sinceLoadStr, sleep, relpath,
	} from 'llutils'
import {OL, ML} from 'to-nice'
import {
	pushLogLevel, popLogLevel, LOG, DBG, ERR,
	INDENT, UNDENT, DBGVALUE, DBGLABELED,
	} from 'logger'

export {slurp, relpath}

# --- Create a function capable of synchronously
#     importing ESM modules

Deno := globalThis.Deno
export type FsEvent = Deno.FsEvent

# --- not exported
decoder := new TextDecoder('utf-8')
encoder := new TextEncoder()

# ---------------------------------------------------------------------------

export isFile := (path: string): boolean =>

	return existsSync(path) && statSync(path).isFile()

# ---------------------------------------------------------------------------

export isDir := (path: string): boolean =>

	return existsSync(path) && statSync(path).isDirectory()

# ---------------------------------------------------------------------------

/**
 * returns one of:
 *    'missing'  - does not exist
 *    'dir'      - is a directory
 *    'file'     - is a file
 *    'symlink'  - is a symlink
 *    'unknown'  - exists, but not a file, directory or symlink
 */

export type TPathType =
	'missing' | 'file' | 'dir' | 'symlink' | 'unknown'

export getPathType := (path: string): TPathType =>

	assert isString(path), "not a string: #{OL(path)}"
	if not existsSync path
		return 'missing'
	h := statSync(path)
	return (
		  h.isFile()         ? 'file'
		: h.isDirectory()    ? 'dir'
		: h.isSymbolicLink() ? 'symlink'
		:                      'unknown'
		)

# ---------------------------------------------------------------------------

/**
 * extract the file extension from a path, including
 * the leading period
 */

export fileExt := (path: string): string =>

	if lMatches := path.match(/\.[^\.]+$/)
		return lMatches[0]
	else
		return ''

# ---------------------------------------------------------------------------

/**
 * return the given path, but with the given file extension
 * replacing the existing file extension
 */

export withExt := (path: string, ext: string): string =>

	assert isNonEmptyString(path), "path = #{OL(path)}"
	assert ext.startsWith('.'), "Bad file extension: #{ext}"
	lMatches := path.match(/^(.*)(\.[^\.]+)$/)
	if (lMatches == null)
		throw new Error("Bad path: '#{path}'")
	[_, headStr, orgExt] := lMatches
	return "#{headStr}#{ext}"

# ---------------------------------------------------------------------------

export lStatFields: string[] := [
	'dev','ino','mode','nlink','uid','gid','rdev',
	'size','blksize','blocks',
	'atimeMs','mtimeMs','ctimeMs','birthtimeMs',
	'atime','mtime','ctime','birthtime',
	]

/**
 * return statistics for a file or directory
 */

export getStats := (path: string): Deno.FileInfo =>

	fileInfo := Deno.statSync(path)
	return fileInfo

# ---------------------------------------------------------------------------

export isStub := (str: string): boolean =>

	# --- a stub cannot contain any of '\\', '/'
	return notdefined(str.match(/[\\\/]/)) && (str[0] != '.')

# ---------------------------------------------------------------------------

/**
 * parses a path or file URL, and returns a hash with keys:
 * 	type: TPathType - 'file','dir','symlink','missing' or 'unknown'
 * 	path: string
 * 	root: string
 * 	dir: string
 * 	fileName: string
 * 	stub: string?
 * 	purpose: string?
 * 	ext: string?
 * 	relPath: string
 * 	relDir: string
 */

export type TPathInfo = {
	type: TPathType  # 'file','dir','symlink','missing' or 'unknown'
	path: string
	root: string
	dir: string
	fileName: string
	stub: string?
	purpose: string?
	ext: string?
	relPath: string
	relDir: string
	}

export parsePath := (path: string): TPathInfo =>

	# --- NOTE: path may be a file URL, e.g. import.meta.url
	#           path may be a relative path

	assert isNonEmptyString(path), "path not a string #{OL(path)}"
	if defined(path.match(/^file\:\/\//))
		path = fromFileUrl(path)
	path = mkpath path

	{root, dir, base: fileName} := parse(path)

	lParts := fileName.split('.')
	[stub, purpose, ext] := switch lParts.length
		when 0
			croak "Can't happen"
		when 1
			[fileName, undef, undef]
		when 2
			[lParts[0], undef, ".#{lParts[1]}"]
		else
			[
				lParts.slice(0, -2).join('.'),
				lParts.at(-2),
				".#{lParts.at(-1)}"
				]

	# --- Grab everything up until the last path separator, if any
	relPath := relpath path
	lPathMatches := relPath.match(/^(.*)[\\\/][^\\\/]*$/)
	relDir := (lPathMatches == null) ? '.' : lPathMatches[1]

	return {
		type: getPathType(path)
		path
		root
		dir
		fileName
		stub
		purpose
		ext
		relPath
		relDir
		}

# ---------------------------------------------------------------------------
# GENERATOR

/**
 * generate files that match a given glob pattern
 * yields a hash with keys:
 *    type     - 'file', 'dir', 'symlink', 'unknown'
 *    root     - e.g. 'C:/'
 *    fileName
 *    stub
 *    purpose
 *    ext
 *    relPath   - relative to working dir, no leading . or ..
 * These options may be specified in the 2nd parameter:
 *    root: string - root of search, (def: Deno.cwd())
 *    lExclude: [string] - patterns to exclude,
 *    	def: ['node_modules/**', '.git/**']
 *    includeDirs: boolean - should directories be included? (def: true)
 * 	followSymlinks - boolean - should sym links be followed? (def: false)
 * 	canonicalize: boolean - if followsymlinks is true, should
 * 		paths be canonicalized? (def: true)
 * 	filter: (string => any?) - ignore if undef returned,
 *       else yield the returned value
 *
 * Glob pattern:
 * 	*         match any number of chars, except path separator
 * 	**        match zero or more directories
 * 	?         match any single char, except path separator
 * 	/         path separator
 * 	[abc]     match one char in the brackets
 * 	[!abc]    match one char not in the brackets
 * 	{abc,123} comma-separated list of literals to match
 */

export type TFileFilterFunc = (hInfo: TPathInfo) => boolean

export allFilesMatching := (
		pattern: string='**',
		hOptions: hash={}
		): Generator<TPathInfo, void, void> ->

	type opt = {
		root: string?
		lExclude: string[]
		includeDirs: boolean
		followSymlinks: boolean
		canonicalize: boolean
		filter: TFileFilterFunc?
		}
	{
		root,
		lExclude,
		includeDirs,
		followSymlinks,
		canonicalize,
		filter,
		} := getOptions<opt> hOptions, {
			root: undef
			lExclude: [
				'node_modules/**'
				'.git/**'
				'**/*.temp.*'
				]
			includeDirs: false
			followSymlinks: false
			canonicalize: false
			filter: undef
			}

	hGlobOptions := {
		root
		exclude: lExclude
		includeDirs
		followSymlinks
		canonicalize
		}

	for h of expandGlobSync(pattern, hGlobOptions)
		# --- h has keys: path, name, isFile, isDirectory, isSymLink

		DBG "MATCH: #{h.path}"
		type := (
			  h.isFile      ? 'file'
			: h.isDirectory ? 'dir'
			: h.isSymlink   ? 'symlink'
			:                 'unknown'
			)
		hFile := parsePath(h.path)
		if notdefined(filter)
			DBG "   - no filter"
			yield hFile
		else
			if filter(hFile)
				DBG "   - allowed by filter"
				yield hFile
			else
				DBG "   - excluded by filter"
	return

# ---------------------------------------------------------------------------
# returns full path to file

export findSrcFile := (
		fileName: string
		hOptions: hash={}
		): string? =>

	type opt = {
		root: string?
		}
	{root} := getOptions<opt> hOptions, {
		root: './src'
		}

	lFiles := Array.from(allFilesMatching("**/#{fileName}", {root}))
	DBGVALUE 'lFiles', lFiles
	switch lFiles.length
		when 1
			{path} := lFiles[0]
			assert isFile(path), "Not a file: #{OL(path)}"
			return path
		when 0
			return undef
		else
			croak "Multiple files with name #{OL(fileName)}"
			return ''

# ---------------------------------------------------------------------------
# ASYNC GENERATOR

/**
 * An async iterable - yields every line in the given file
 *
 * Usage:
 *   for await line of allLinesIn('src/lib/temp.civet')
 * 	  console.log "LINE: #{line}"
 *   console.log "DONE"
 */

export allLinesIn := (
	path: string
	): AsyncGenerator<string, void, void> ->

	assert isFile(path), "No such file: #{OL(path)} (allLinesIn)"
	f := await Deno.open(path)
	readable := f.readable
		.pipeThrough(new TextDecoderStream())
		.pipeThrough(new TextLineStream())

	for await line of readable
		yield line
	return

# ---------------------------------------------------------------------------

/**
 * converts all backslash characters to forward slashes
 * upper-cases drive letters
 */

export normalizePath := (path: string): string =>

	npath := path.replaceAll('\\', '/')
	if (npath.charAt(1) == ':')
		return npath.charAt(0).toUpperCase() + npath.substring(1)
	else
		return npath

# ---------------------------------------------------------------------------

export pathToURL := (lParts...: string[]): string =>

	path := resolve(lParts...)
	return new URL('file://' + path).href

# ---------------------------------------------------------------------------

/**
 * resolves multiple path parts to a single path
 * returns normalized path
 */

export mkpath := (lParts...: string[]): string =>

	path := resolve(lParts...)
	return normalizePath(path)

# ---------------------------------------------------------------------------

export type TPathDesc = {
	dir: string
	root: string
	lParts: string[]
	}

/**
 * returns {dir, root, lParts} where lParts includes the names of
 * all directories between the root and the file name
 * relative to the current working directory
 */

export pathSubDirs := (path: string, hOptions: hash={}): TPathDesc =>

	type opt = {
		relative: boolean
		}
	{relative} := getOptions<opt> hOptions, {
		relative: false
		}
	path = relative ? relpath(path) : mkpath(path)
	{root, dir} := parse(path)
	return {
		dir
		root
		lParts: dir.slice(root.length).split(/[\\\/]/)
		}

# ---------------------------------------------------------------------------
# --- Should be called like: myself(import.meta.url)
#     returns full path of current file

export myself := (url: string): string =>

	return relpath fromFileUrl(url)

# ---------------------------------------------------------------------------
# ---------------------------------------------------------------------------

export barf := (
		path: string,
		contents: string,
		hOptions: hash = {}
		): void =>

	type opt = {
		append: boolean
		}
	{append} := getOptions<opt> hOptions, {
		append: false
		}
	mkDirsForFile(path)
	data := encoder.encode(contents)
	if append && isFile(path)
		appendFileSync path, data
	else
		Deno.writeFileSync path, data
	return

# ---------------------------------------------------------------------------

export barfTempFile := (
		contents: string
		hOptions: hash = {}
		): string =>

	type opt = {
		ext: string
		}
	{ext} := getOptions<opt> hOptions, {
		ext: '.civet'
		}
	tempFilePath := Deno.makeTempFileSync {suffix: ext}
	barf tempFilePath, contents
	return tempFilePath

# ---------------------------------------------------------------------------

export isExt := (str: string): boolean =>

	return /^\.[A-Za-z0-9_]+$/.test(str)

# ---------------------------------------------------------------------------

export newerDestFileExists := (
	srcPath: string,
	destPath: string
	): boolean =>

	if isExt(destPath)
		destPath = withExt(srcPath, destPath)
	assert isFile(srcPath), "No such file: #{OL(srcPath)}"
	if not existsSync(destPath)
		return false
	srcModTime := statSync(srcPath).mtimeMs
	destModTime := statSync(destPath).mtimeMs
	return (destModTime > srcModTime)

# ---------------------------------------------------------------------------

/**
 * create a new directory if it doesn't exist
 * if the option 'clear' is set to a true value in the 2nd parameter
 * and the directory already exists, it is cleared
 */

export mkDir := (
		dirPath: string,
		clear: boolean=false
		): void =>

	if clear
		emptyDirSync dirPath    # --- creates if it doesn't exist
	else
		ensureDirSync dirPath
	return

# ---------------------------------------------------------------------------

/**
 * remove a file from the file system, but do nothing
 * if the file does not exist
 */

export rmFile := (path: string): void =>

	if existsSync path
		Deno.removeSync path
	return

# ---------------------------------------------------------------------------

/**
 * remove a directory from the file system, but do nothing
 * if the directory does not exist
 * NOTE: You must pass the 'clear' option if the directory
 *       is not empty
 */

export rmDir := (path: string, hOptions: hash={}): void =>

	type opt = {
		clear: boolean
		}
	{clear} := getOptions<opt> hOptions, {
		clear: false
		}
	if existsSync path
		if clear
			Deno.removeSync path, {recursive: true}
		else
			Deno.removeSync path
	return

# ---------------------------------------------------------------------------

/**
 * create any missing directories in the given path
 */

export mkDirsForFile := (path: string): void =>

	{root, lParts} := pathSubDirs(path)
	let dir = root
	for part of lParts
		dir += "/#{part}"
		if not isDir(dir)
			mkDir dir
	return

# ---------------------------------------------------------------------------

/**
 * deletes all files and subdirectories in the given directory
 */

export clearDir := (dirPath: string): void =>

	emptyDirSync dirPath
	return

# ---------------------------------------------------------------------------
# --- hOptions gets passed to allFilesMatching()

export removeFilesMatching := (
	pattern: string,
	hOptions: hash={}
	): void =>

	assert (pattern != '*') && (pattern != '**'),
		"Can't delete files matching #{OL(pattern)}"
	for {relPath} of allFilesMatching(pattern, hOptions)
		Deno.removeSync relPath
	return

# ---------------------------------------------------------------------------

export removeFilesExcept := (
	pattern: string,
	lKeep: string[],
	hOptions: hash = {}
	): void =>

	type opt = {
		debug: boolean
		}
	{debug} := getOptions<opt> hOptions, {
		debug: false
		}
	DBG := (msg: string): void =>
		if debug
			console.log msg
		return

	# --- truthy return means remove it
	filter := (hFile: TPathInfo) =>
		{type, relPath} := hFile
		if (type != 'file')
			return undef
		removeFile := not lKeep.includes(relPath)
		DBG "filter(#{relPath}): removeFile = #{removeFile}"
		return removeFile

	h: hash := {filter, debug}
	for {relPath} of allFilesMatching(pattern, h)
		DBG "REMOVE FILE #{relPath}"
		Deno.removeSync relPath
	return

# ---------------------------------------------------------------------------

/**
 * type TFsEventHandler
 *    - a function taking (kind, path)
 *   - optionally returns boolean to indicate stop watching
 */

export type TFsEventHandler = (kind: string, path: string) => void | boolean

/**
 * class FileEventHandler
 *    handles file changed events when .handle(fsEvent) is called
 *    callback is a function, debounced by 200 ms
 *       that takes an FsEvent and returns a voidFunc
 *       which will be called if the callback returns a function reference
 * [unit tests](../test/fs.test.civet#:~:text=%23%20%2D%2D%2D%20class%20FileEventHandler)
 */

export class FileEventHandler

	handler: TFsEventHandler   # --- debounced handler
	onStop: () => void = pass

	# ..........................................................

	constructor(
			callback: TFsEventHandler
			hOptions: hash={}
			)

		type opt = {
			onStop: voidFunc
			debounceBy: number
			}
		{
			onStop: @onStop
			debounceBy
			} := getOptions<opt> hOptions, {
				onStop: pass
				debounceBy: 200
				}
		@handler := debounce(callback, debounceBy)
		DBG "FileEventHandler constructor() called"

	# ..........................................................
	# --- Calls a voidFunc, but is debounced by @ms ms

	handle(fsEvent: FsEvent): void
		{kind, paths} := fsEvent
		DBG "HANDLE: [#{sinceLoadStr()}] #{kind} #{OL(paths)}"

		for path of paths
			@handler(kind, path)
		return

# ---------------------------------------------------------------------------
# ASYNC

/**
 * a function that watches for changes one or more files or directories
 *    and calls a callback function for each change.
 * If the callback returns true, watching is halted
 *
 * Usage:
 *   handler := (kind, path) => console.log path
 *   await watchFile 'temp.txt', handler
 *   await watchFile 'src/lib',  handler
 *   await watchFile ['temp.txt', 'src/lib'], handler
 */

export watchFile := (
	path: string | string[],
	watcherCB: TFsEventHandler,
	hOptions: hash={}
	): void ->

	# --- debounceBy is milliseconds to debounce by, default is 200
	{debounceBy} := getOptions<{debounceBy: number}> hOptions, {
		debounceBy: 200
		}

	DBG "WATCH: #{OL(path)}"
	watcher := Deno.watchFs(path)

	let doStop: boolean = false

	fsCallback: TFsEventHandler := (kind, path) =>
		result := watcherCB(kind, path)
		DBG "FCB: result = #{result}"
		if result
			watcher.close()
		return

	handler := new FileEventHandler(fsCallback, {debounceBy})

	for await fsEvent: FsEvent of watcher
		DBG "watcher event fired"
		if doStop
			DBG "doStop = #{doStop}, Closing watcher"
			break
		for path of fsEvent.paths
			# --- fsCallback will be (eventually) called
			handler.handle(fsEvent)

export watchFiles := watchFile

# ---------------------------------------------------------------------------

export patchFirstLine := (
		path: string
		str: string
		newstr: string
		): void =>

	# --- Replace str with newstr, but only on first line
	contents := Deno.readTextFileSync path
	nlPos := contents.indexOf "\n"
	strPos := contents.indexOf str
	if (strPos != -1) && ((nlPos == -1) || (strPos < nlPos))
		Deno.writeTextFileSync path, contents.replace(str, newstr)
	return
