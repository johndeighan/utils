# nice.lib.civet

import {
	undef, defined, notdefined, assert, croak, hash, hashof,
	isArray, isFunction, isBoolean, isString, isNonPrimitive,
	isClass, isArrayOfStrings, isEmpty, nonEmpty,
	className, functionName, symbolName,
	classDef, functionDef, regexpDef,
	} from 'datatypes'
import {
	getOptions, escapeStr, unescapeStr,
	keys, toBlock, o, OL, rtrim, Fetcher,
	} from 'llutils'
import {
	indented,
	} from 'indent'
import {
	TPLLToken, tkEOF, tkIndent, tkUndent,
	TTokenGenerator, allTokensInBlock,
	} from 'pll'

# ---------------------------------------------------------------------------

export type TCompareFunc = (a: string, b: string) => number
export type TMapFunc = (key: string, x: unknown) => unknown

# ---------------------------------------------------------------------------

export alphaCompare: TCompareFunc := (
		a: string,
		b: string
		): number =>

	return (a < b) ? -1 : (a > b) ? 1 : 0

# ---------------------------------------------------------------------------

# --- Returns a function that:
#        compares 2 strings based on their position in lSortKeys
#        else compares alphabetically

getCompareFunc := (
		lSortKeys: string[]
		): TCompareFunc =>

	# --- Create map of key to number
	h: hashof<number> := {}
	for key,i of lSortKeys
		h[key] = i+1

	return (a: string, b: string): number ->
		aVal := h[a]
		bVal := h[b]

		if defined(aVal)
			if defined(bVal)
				# --- compare numerically
				return (aVal < bVal) ? -1 : (aVal > bVal) ? 1 : 0
			else
				return -1
		else
			if defined(bVal)
				return 1
			else
				return alphaCompare(a, b)

# ---------------------------------------------------------------------------
# --- leading digit must be preceded by a single '\'
#     leading and trailing whitespace must be replaced
#        with \t, \n or \x20

export toNiceString := (str: string): string =>

	# --- escape TABs and NEWLINEs

	str1 := escapeStr(str, o'style=C')

	# --- precede with '/' if starts with digit, '.' or '-'

	str2 := str1.match(/^[\d.-]/) ? "\\#{str1}" : str1
	str3 := str2.match(/^\S+:/) ? "\\#{str2}" : str2

	# --- check for leading or trailing spaces
	#     (TABs and NEWLINEs have already been escaped)
	#     (regex always matches)

	lMatches := str3.match ///^
			(\x20+)?
			(.*?)
			(\x20+)?
			$///
	if defined(lMatches)
		[_, pre, mid, post] := lMatches
		return (
			(defined(pre) ? '\\x20'.repeat(pre.length) : '')
			+ mid
			+ (defined(post) ? '\\x20'.repeat(post.length) : '')
			)
	return str2

# ---------------------------------------------------------------------------

pathadd := (
		path: string
		key: string | number
		): string =>

	newkey := (
		  (typeof key == 'number')
		? "[#{key.toString()}]"
		: "/#{key}"
		)
	return (path == '/') ? newkey : "#{path}#{newkey}"

# ---------------------------------------------------------------------------

export toNice := (
		x: unknown,
		hOptions: hash={}
		mapVisited: Map<object, string> = new Map<object, string>()
		path: string = '/'
		): string =>

	# --- When recoverable, classes and functions
	#     include their definitions,
	#     with escaped chars

	type opt = {
		recoverable: boolean
		ignoreEmptyKeys: boolean
		sortKeys: boolean
		sortFunc: TCompareFunc?
		mapFunc: TMapFunc
		lInclude: string[]?
		lExclude: string[]
		}
	{recoverable,
			ignoreEmptyKeys,
			sortKeys,
			sortFunc,
			mapFunc,
			lInclude,
			lExclude,
		} := getOptions<opt> hOptions, {
		recoverable: false
		ignoreEmptyKeys: false
		sortKeys: false
		sortFunc: undef
		mapFunc: (key: string, x: unknown) => return x
		lInclude: undef
		lExclude: []
		}

	assert not (sortKeys && defined(sortFunc)), "Bad options"
	switch typeof x
		when 'undefined'
			return '.undef.'

		when 'boolean'
			return x ? '.true.' : '.false.'

		when 'number'
			return (
				  Number.isNaN(x)    ? '.NaN.'
				: Number.isFinite(x) ? x.toString()
				: ((x < 0) ? '.neginfinity.' : '.infinity.')
				)

		when 'bigint'
			return x.toString() + 'n'

		when 'string'
			return toNiceString(x)

		when 'symbol'
			name := symbolName(x)
			return name ? ".symbol #{name}." : '.symbol.'

		when 'function'
			if isClass(x)
				return ".class #{className(x)}."
			else
				return ".function #{functionName(x)}."

		when 'object'
			if (x == null)
				return '.null.'

			if (x instanceof RegExp)
				def := regexpDef(x)
				return def ? ".regexp #{def}." : '.regexp.'

			if (x instanceof String)
				return toNiceString(x.toString())

			if (x instanceof Boolean)
				return x ? '.true.' : '.false.'

			if (x instanceof Number)
				return x.toString()

			# --- Check if object was previously visited
			prevpath := mapVisited.get x
			if prevpath
				return ".REF #{prevpath}."

			# --- a utility function ---

			shouldSplit := (v: unknown): boolean =>
				return (
						(typeof v == 'object')
					&& (v != null)
					&& not (v instanceof String)
					&& not (v instanceof Number)
					&& not (v instanceof Boolean)
					&& nonEmpty(v)
					&& not mapVisited.has(v)
					)

			if isArray(x)
				if (x.length == 0)
					return '.[].'
				lLines := []
				for val,i of x
					doSplit := shouldSplit(val)
					block := toNice(
							val,
							hOptions,
							mapVisited,
							pathadd(path, i)
							)
					if doSplit
						lLines.push '-'
						lLines.push indented(block, 1, {oneIndent: '   '})
					else
						lLines.push "- #{block}"
				return toBlock(lLines)

			# --- Add to visited map
			mapVisited.set x, path

			lKeys := Object.keys(x)
			if (lKeys.length == 0)
				return '.{}.'

			func: TCompareFunc? := (
				  defined(sortFunc) ? sortFunc
				: defined(lInclude) ? getCompareFunc(lInclude)
				: sortKeys          ? alphaCompare
				:                     undef
				)

			useKey := (key: unknown): boolean =>
				if (typeof key != 'string')
					return false
				if defined(lExclude) && lExclude.includes(key)
					return false
				if defined(lInclude) && not lInclude.includes(key)
					return false
				return true

			lLines := []
			for key of (defined(func) ? lKeys.sort(func) : lKeys)
				if useKey(key)
					val := mapFunc(key, (x as hashof<unknown>)[key])
					if not ignoreEmptyKeys || not isEmpty(val)
						doSplit := shouldSplit(val)
						block := toNice(
								val,
								hOptions,
								mapVisited,
								pathadd(path, key)
								)
						if doSplit
							lLines.push "#{key}:"
							lLines.push indented(block, 1, {oneIndent: '   '})
						else
							lLines.push "#{key}: #{block}"
			return toBlock(lLines)

	return "<Unknown object #{OL(x)}>"

# ---------------------------------------------------------------------------


# ---------------------------------------------------------------------------

export niceSplitter: TTokenGenerator := (
		str: string
		) ->
	if let lMatches = str.match(///^
			-
			(.*)
			$///)
		tail := lMatches[1].trim()
		if tail
			yield {
				kind: 'list-item'
				str
				value: getPrimitive(tail)
				}
		else
			yield {
				kind: 'list-head'
				name: str
				str: ''
				}
	else if let lMatches = str.match(///^
			([A-Za-z][A-Za-z0-9_]*)
			:
			(.*)
			$///)
		name := lMatches[1]
		tail := lMatches[2].trim()
		if tail
			yield {
				kind: 'hash-item'
				str
				name
				value: getPrimitive(tail)
				}
		else
			yield {
				kind: 'hash-head'
				name
				str
				}
	else
		yield {
			kind: 'primitive'
			str
			value: getPrimitive(str)
			}

# ---------------------------------------------------------------------------

export allNiceTokens := (
		block: string,
		): Generator<TPLLToken, void, void> ->

	for h of allTokensInBlock(block, niceSplitter)
		yield h
	return

# ---------------------------------------------------------------------------

export fromNice := (
		str: string,
		): unknown =>

	# --- Create a Fetcher, then use
	#     recursive descent parsing

	fetcher := new Fetcher<TPLLToken>(allNiceTokens(str), tkEOF)

	parseObj := (): unknown =>
		{kind, str} := fetcher.peek()
		switch kind
			'list-item', 'list-head'
				return parseList()
			'hash-item', 'hash-head'
				return parseHash()
			'eof'
				return undef
			else
				fetcher.skip()
				if defined(str)
					return getPrimitive(str)

	parseList := (): unknown[] =>
		lItems: unknown[] := []
		let {kind} = fetcher.peek()
		while ['list-item', 'list-head'].includes kind
			if (kind == 'list-head')
				lItems.push parseListNest()
			else
				lItems.push fetcher.get().value
			kind = fetcher.peek().kind
		return lItems

	parseListNest := (): unknown[] =>
		fetcher.get({kind: 'list-head', str: ''})
		fetcher.get({kind: 'indent', str: ''})
		value := parseObj()
		fetcher.get({kind: 'undent', str: ''})
		return [value]

	parseHash := (): hash =>
		hItems: hash := {}
		let {kind, name} = fetcher.peek()
		if (kind == 'hash-head')
			fetcher.skip()
			fetcher.get({kind: 'indent', str: ''})
			value := parseObj()
			if defined(name)
				hItems[name] = value
			fetcher.get({kind: 'undent', str: ''})
		else
			while (kind == 'hash-item')
				{name, value} := fetcher.get()
				if defined(name)
					hItems[name] = value
				{kind} = fetcher.peek()
		return hItems

	debugger
	return parseObj()

# ---------------------------------------------------------------------------

export getPrimitive := (
		str: string,
		): unknown =>

	str = str.trim()
	if lMatches := str.match(/^\.(.*)\.$/)
		s := lMatches[1].trim()
		switch s
			'undef'       then return undef
			'null'        then return null
			'true'        then return true
			'false'       then return false
			'NaN'         then return NaN
			'infinity'    then return Infinity
			'neginfinity' then return -Infinity
			'symbol'      then return Symbol()
			'[]'          then return []
			'{}'          then return {}
			/^symbol\s+(.+)$/
				lMatches := s.match(/^symbol\s+(.+)$/)
				if defined(lMatches)
					name := lMatches[1]
					return Symbol(name)
				else
					return Symbol()
			/^regexp\s+(.+)$/
				lMatches := s.match(/^regexp\s+(.+)$/)
				if defined(lMatches)
					name := lMatches[1]
					return new RegExp(name)
				else
					return new RegExp('^$')
			else
				croak "Not Implemented"
	else if str.match(/^\d+$/)
		return parseInt(str, 10)
	else if str.match(/^\d+\.\d*$/)
		return parseFloat(str)
	else
		return unescapeStr(str, o'purpose=C')
