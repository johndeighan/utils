# nice.lib.civet

import {
	undef, defined, notdefined, assert, croak, hash, hashof,
	isArray, isFunction, isBoolean, isString, isClass, isArrayOfStrings,
	jsType, className, functionName, symbolName,
	nonEmpty, classDef, functionDef, regexpDef,
	} from 'datatypes'
import {
	getOptions, escapeStr, unescapeStr,
	keys, toBlock, o, OL, rtrim, Fetcher,
	} from 'llutils'
import {
	indented,
	} from 'indent'
import {
	TPLLToken, tkEOF, tkIndent, tkUndent,
	TTokenGenerator, allTokensInBlock,
	} from 'pll'

# ---------------------------------------------------------------------------

type TCompareFunc = (a: string, b: string) => number

# ---------------------------------------------------------------------------

export alphaCompare: TCompareFunc := (
		a: string,
		b: string
		): number =>

	return (a < b) ? -1 : (a > b) ? 1 : 0

# ---------------------------------------------------------------------------

# --- Returns a function that:
#        compares 2 strings based on their position in lSortKeys
#        else compares alphabetically

getCompareFunc := (
		lSortKeys: string[]
		): TCompareFunc =>

	# --- Create map of key to number
	h: hashof<number> := {}
	for key,i of lSortKeys
		h[key] = i+1

	return (a: string, b: string): number ->
		aVal := h[a]
		bVal := h[b]

		if defined(aVal)
			if defined(bVal)
				# --- compare numerically
				return (aVal < bVal) ? -1 : (aVal > bVal) ? 1 : 0
			else
				return -1
		else
			if defined(bVal)
				return 1
			else
				return alphaCompare(a, b)

# ---------------------------------------------------------------------------

export toNice := (
		x: unknown,
		hOptions: hash={}
		): string =>

	# --- When strict, classes and function
	#     include their definitions, with escaped chars

	type opt = {
		strict: boolean
		sortFunc: TCompareFunc?
		sortKeys: string[]?
		}
	{strict, sortFunc, sortKeys
		} := getOptions<opt> hOptions, {
		strict: false
		sortFunc: undef
		sortKeys: undef
		}

	if (typeof x == 'undefined')
		return '.undef.'

	if (typeof x == 'bigint')
		return x.toString()

	if (typeof x == 'number')
		return (
			  Number.isNaN(x)    ? '.NaN.'
			: Number.isFinite(x) ? x.toString()
			: ((x < 0) ? '.neginfinity.' : '.infinity.')
			)

	if (typeof x == 'function')
		if isClass(x)
			return ".class #{classDef(x)}."
		else
			return ".function #{functionDef(x)}."

	if (typeof x == 'object')

		if (x == null)
			return '.null.'

		if isArray(x)
			if (x.length == 0)
				return '.[].'
			lLines := []
			for item of x
				block := toNice(item, hOptions)
				if shouldSplit(item)
					lLines.push '-'
					lLines.push indented(block)
				else
					lLines.push "- #{block}"
			return toBlock(lLines)

		if (x instanceof String)
			s := x.toString()
			if needsPreEsc(s)
				return '\\' + escapeStr(s, o'style=C')
			else
				return escapeStr(s, o'style=C')

		if (x instanceof Boolean)
			return x ? '.true.' : '.false.'

		if (x instanceof Number)
			return x.toString()

		if (x instanceof RegExp)
			def := regexpDef(x)
			return def ? ".regexp #{def}." : '.regexp.'

#		sortKeysFunc: TCompareFunc := (
#			  isArray(sortKeys)    ? getCompareFunc(sortKeys)
#			: isFunction(sortKeys) ? sortKeys
#			:                        alphaCompare
#			)

		let sortKeysFunc: TCompareFunc
		if defined(sortFunc)
			sortKeysFunc = sortFunc
		else if defined(sortKeys)
			sortKeysFunc = getCompareFunc(sortKeys)
		else
			sortKeysFunc = alphaCompare

		lKeys := Object.keys(x)
		if (lKeys.length == 0)
			return '.{}.'
		lLines := []
		for key of lKeys.sort(sortKeysFunc)
			if isString(key)
				val := (x as hashof<unknown>)[key]
				block := toNice(val, hOptions)
				if shouldSplit(val)
					lLines.push "#{key}:"
					lLines.push indented(block)
				else
					lLines.push "#{key}: #{block}"
		return toBlock(lLines)

	else
		return "<Unknown object #{x}>"

# ---------------------------------------------------------------------------

export needsPreEsc := (str: string) =>

	# --- if it looks like an array item, it needs leading \
	if str.match(/^-/)
		return true

	# --- if it looks like a hash key, it needs leading \
	if str.match(/^[A-Za-z][A-Za-z0-9_]*:/)
		return true

	# --- if it looks like a number, it needs leading \
	if str.match(/^\d+(?:\.\d*)?/)
		return true

	# --- if it starts with a '.', it needs leading \
	if (str.length > 0) && (str[0] == '.')
		return true

	return false

# ---------------------------------------------------------------------------

shouldSplit := (x: any): boolean =>

	return ['hash','array','class','instance'].includes(jsType(x))

# ---------------------------------------------------------------------------

export niceSplitter: TTokenGenerator := (
		str: string
		) ->
	if let lMatches = str.match(///^
			-
			(.*)
			$///)
		tail := lMatches[1].trim()
		if tail
			yield {
				kind: 'list-item'
				str
				value: getPrimitive(tail)
				}
		else
			yield {
				kind: 'list-head'
				name: str
				str: ''
				}
	else if let lMatches = str.match(///^
			([A-Za-z][A-Za-z0-9_]*)
			:
			(.*)
			$///)
		name := lMatches[1]
		tail := lMatches[2].trim()
		if tail
			yield {
				kind: 'hash-item'
				str
				name
				value: getPrimitive(tail)
				}
		else
			yield {
				kind: 'hash-head'
				name
				str
				}
	else
		yield {
			kind: 'primitive'
			str
			value: getPrimitive(str)
			}

# ---------------------------------------------------------------------------

export allNiceTokens := (
		block: string,
		): Generator<TPLLToken, void, void> ->

	for h of allTokensInBlock(block, niceSplitter)
		yield h
	return

# ---------------------------------------------------------------------------

export fromNice := (
		str: string,
		): any =>

	# --- Create a Fetcher, then use
	#     recursive descent parsing

	fetcher := new Fetcher<TPLLToken>(allNiceTokens(str), tkEOF)

	parseObj := (): any =>
		{kind, str} := fetcher.peek()
		switch kind
			'list-item', 'list-head'
				return parseList()
			'hash-item', 'hash-head'
				return parseHash()
			'eof'
				return undef
			else
				fetcher.skip()
				return getPrimitive(str)

	parseList := (): any[] =>
		lItems: any[] := []
		let {kind} = fetcher.peek()
		while ['list-item', 'list-head'].includes kind
			if (kind == 'list-head')
				lItems.push parseListNest()
			else
				lItems.push fetcher.get().value
			kind = fetcher.peek().kind
		return lItems

	parseListNest := (): any[] =>
		fetcher.get({kind: 'list-head', str: ''})
		fetcher.get({kind: 'indent', str: ''})
		value := parseObj()
		fetcher.get({kind: 'undent', str: ''})
		return value

	parseHash := (): hash =>
		hItems: hash := {}
		let {kind, name} = fetcher.peek()
		if (kind == 'hash-head')
			fetcher.skip()
			fetcher.get({kind: 'indent', str: ''})
			value := parseObj()
			if defined(name)
				hItems[name] = value
			fetcher.get({kind: 'undent', str: ''})
		else
			while (kind == 'hash-item')
				{name, value} := fetcher.get()
				if defined(name)
					hItems[name] = value
				{kind} = fetcher.peek()
		return hItems

	debugger
	return parseObj()

# ---------------------------------------------------------------------------

export getPrimitive := (
		str: string,
		): any =>

	str = str.trim()
	if lMatches := str.match(/^\.(.*)\.$/)
		s := lMatches[1].trim()
		switch s
			'undef'       then return undef
			'null'        then return null
			'true'        then return true
			'false'       then return false
			'NaN'         then return NaN
			'infinity'    then return Infinity
			'neginfinity' then return -Infinity
			'symbol'      then return Symbol()
			'[]'          then return []
			'{}'          then return {}
			/^symbol\s+(.+)$/
				lMatches := s.match(/^symbol\s+(.+)$/)
				if defined(lMatches)
					name := lMatches[1]
					return Symbol(name)
				else
					return Symbol()
			/^regexp\s+(.+)$/
				lMatches := s.match(/^regexp\s+(.+)$/)
				if defined(lMatches)
					name := lMatches[1]
					return new RegExp(name)
				else
					return new RegExp('^$')
			else
				croak "Not Implemented"
	else if str.match(/^\d+$/)
		return parseInt(str, 10)
	else if str.match(/^\d+\.\d*$/)
		return parseFloat(str)
	else
		return unescapeStr(str, o'purpose=C')
