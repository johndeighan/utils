# llutils.lib.civet

import {sprintf} from "@std/fmt/printf"
import {relative} from '@std/path'

import {
	undef, defined, notdefined, assert,
	isHash, isArray, isNonEmptyString, isArrayOfStrings,
	isEmpty, nonEmpty, isString, isObject,
	integer, hash, array, voidFunc, FilterFunc, stringify,
	isNonPrimitive,
	} from './datatypes.lib.ts'

/**
 * @module llutils - low level utilities
 */

llutilsLoadTime: integer := Date.now()

# ---------------------------------------------------------------------------

export sinceLoad := (datetime: integer=Date.now()) =>

	return (datetime - llutilsLoadTime)

# ---------------------------------------------------------------------------

export sinceLoadStr := (datetime: integer?=undef) =>

	return sprintf("%6d", sinceLoad(datetime))

# ---------------------------------------------------------------------------

/**
 * throws an exception with the provided message
 */

export croak := (msg: string): never =>

	throw new Error(msg)

# ---------------------------------------------------------------------------

/**
 * Asserts that `cond` is true. If it isn't, an exception is
 * thrown with the given `msg`
 */

export throwsError := (func: voidFunc, msg: string="Unexpected success"): void =>

	try
		func()
		throw new Error(msg)
	catch err
		return    # ignore error - it was expected

# ---------------------------------------------------------------------------

/**
 * Calling pass() does nothing
 */

export pass := (): void =>    # do nothing

# ---------------------------------------------------------------------------

export deeplyEquals := (a: any, b: any): boolean =>

	if (a == b)
		return true

	if (typeof a != 'object') || (a == null) || (typeof b != 'object') || (b == null)
		return false

	keysA := Object.keys(a)
	keysB := Object.keys(b)

	if (keysA.length != keysB.length)
		return false

	for (key of keysA)
		if not b.hasOwnProperty(key) || not deeplyEquals(a[key], b[key])
			return false
	return true

# ---------------------------------------------------------------------------

/**
 * JSON stringifies x on one line
 * but displays both undefined and null as 'undef'
 */

export OL := (x: any): string =>

	if (x == undef)
		return 'undef'
	else if (x == null)
		return 'null'
	else if (typeof x == 'function')
		return x.toString().replaceAll('\n', ' ')
	else
		str := JSON.stringify(x, (k,v) => defined(v) ? v : '__undef__')
		return str.replaceAll('"__undef__"', 'undef')

# ---------------------------------------------------------------------------

export ML := (x: any): string =>

	if (x == undef)
		return 'undef'
	else if (x == null)
		return 'null'
	else if (typeof x == 'function')
		return x.toString()
	else
		str := JSON.stringify(x, (k,v) => defined(v) ? v : '__undef__', 3)
		if defined(str)
			return str.replaceAll('"__undef__"', 'undef')
		else
			console.log x
			return "JSON.stringify returned undef!!!"

# ---------------------------------------------------------------------------

/**
 * Converts the given string to a hash
 * <word> becomes a key with a true value
 * !<word> becomes a keys with a false value
 * <word>=<string> becomes a key with value <string>
 *    - <string> must be quoted if it contains whitespace
 */

export strToHash := (str: string): hash =>

	if isEmpty(str)
		return {}
	h: hash := {}
	for word of str.trim().split(/\s+/)
		if lMatches: string[] | null := word.match(///^
				(\!)?                    # negate value
				([A-Za-z][A-Za-z_0-9]*)  # identifier
				(?:
					(=)
					(.*)
					)?
				$///)
			[_, neg, ident, eqSign, str] := lMatches
			if isNonEmptyString(eqSign)
				assert notdefined(neg) || (neg == ''),
						"negation with string value"

				# --- check if str is a valid number
				if str.match(/^-?\d+(\.\d+)?$/)
					num := parseFloat(str)
					if Number.isNaN(num)
						# --- TO DO: interpret backslash escapes
						h[ident] = str
					else
						h[ident] = num
				else
					h[ident] = str
			else if neg
				h[ident] = false
			else
				h[ident] = true
		else
			croak "Invalid word #{OL(word)}"
	return h

# ---------------------------------------------------------------------------

export o := (lStrings: TemplateStringsArray): hash =>

	return strToHash(lStrings[0])

# ---------------------------------------------------------------------------

/**
 * Adds any keys in hDefaults that are missing in hOptions
 * to hOptions with their given values
 */

export addDefaults := (hOptions: hash, hDefaults: hash): hash =>

	assert isObject(hOptions), "hOptions not an object: #{OL(hOptions)}"
	assert isObject(hDefaults), "hDefaults not an object: #{OL(hDefaults)}"

	# --- Fill in defaults for missing values
	for key of Object.keys(hDefaults)
		value := hDefaults[key]
		if not hOptions.hasOwnProperty(key) && defined(value)
			hOptions[key] = value
	return hOptions

# ---------------------------------------------------------------------------

/**
 * returns a hash of options with their values, using options
 * if it's a hash, or parsing options using strToHash() if
 * it's a string - adding any default values from hDefaults
 * if they're missing in the resulting hash
 */

export getOptions := (hOptions: hash={}, hDefaults: hash={}): hash =>

	return addDefaults hOptions, hDefaults

# ---------------------------------------------------------------------------

/**
 * remove all keys from a hash that have either an empty name
 * or an empty value
 */

export removeEmptyKeys := (h: hash): hash =>

	hResult: hash := {}
	for key of keys(h)
		if nonEmpty(key) && nonEmpty(h[key])
			hResult[key] = h[key]
	return hResult

# ---------------------------------------------------------------------------

/**
 * return an array of all own keys in a hash
 */

export keys := (obj: hash, hOptions: hash={}): string[] =>

	h := getOptions hOptions, {
		except: []
		}

	let except = h.except

	if isString(except)
		except = [except]
	lKeys: string[] := []
	for key of Object.keys(obj)
		if not except.includes(key)
			lKeys.push key
	return lKeys

# ---------------------------------------------------------------------------

/**
 * returns true if either `h` is not defined, or if `h` is
 * a hash that includes all the keys provided
 */

export hasKey := (h: hash, ...lKeys: string[]): boolean =>

	if notdefined(h)
		return false
	assert isHash(h), "h not a hash: #{OL(h)}"
	for key of lKeys
		assert isString(key), "key not a string: #{OL(key)}"
		if not h.hasOwnProperty(key)
			return false
	return true

export hasKeys := hasKey

# ---------------------------------------------------------------------------

export missingKeys := (h: hash, ...lKeys: string[]): string[] =>

	if notdefined(h)
		return lKeys
	assert isHash(h), "h not a hash: #{OL(h)}"
	lMissing: string[] := []
	for key of lKeys
		if not h.hasOwnProperty(key)
			lMissing.push key
	return lMissing

# ---------------------------------------------------------------------------

/**
 * merges the provided objects into a new object
 * NOTE: none of the provided arguments are modified
 */

export merge := (...lObjects: hash[]): hash =>

	return Object.assign({}, lObjects...)

# ---------------------------------------------------------------------------

export hit := (pct: number = 50): boolean =>

	return (100 * Math.random() < pct)

# ---------------------------------------------------------------------------
# --- ASYNC !

export sleep := (sec: number): void =>

	await new Promise((r) => setTimeout(r, 1000 * sec))
	return

# ---------------------------------------------------------------------------

/**
 * returns a string consisting of the given number
 * of space characters
 */

export spaces := (n: number): string =>

	return " ".repeat(n)

# ---------------------------------------------------------------------------

/**
 * returns a string consisting of the given number
 * of TAB characters
 */

export tabs := (n: number): string =>

	return "\t".repeat(n)

# ---------------------------------------------------------------------------

/**
 * rtrim - strip trailing whitespace
 */

export rtrim := (line: string): string =>

	assert isString(line), "not a string: #{typeof line}"
	lMatches := line.match(/^(.*?)\s+$/)
	return (lMatches == null) ? line : lMatches[1]

# ---------------------------------------------------------------------------

/**
 * Count the number of a specific character in a string
 */

export countChars := (str: string, ch: string): number =>

	let count = 0
	let pos = -1
	while (pos = str.indexOf(ch, pos+1)) != -1
		count += 1
	return count

# ---------------------------------------------------------------------------

/**
 * convert a multi-line string to an array
 * of single line strings
 */

export blockToArray := (block: string): string[] =>

	if isEmpty(block)
		return []
	else
		return block.split(/\r?\n/)

# ---------------------------------------------------------------------------

export allLinesInBlock := (
		block: string
		): Generator<string, void, void> ->

	let start = 0
	let end = block.indexOf('\n')
	while (end != -1)
		yield block.substring(start, end)
		start = end + 1
		end = block.indexOf('\n', start)
	if (start < block.length)
		yield block.substring(start)
	return

# ---------------------------------------------------------------------------

/**
 * A string or string array
 */

export type blockSpec = string | string[]

export isBlockSpec := (x: any): x is blockSpec =>

	return isString(x) || isArrayOfStrings(x)

# ---------------------------------------------------------------------------

/**
 * return an array as is, convert a multi-line string
 * to an array of single line strings
 */

export toArray := (strOrArray: blockSpec): string[] =>

	if Array.isArray(strOrArray)
		return strOrArray
	else
		return blockToArray(strOrArray)

# ---------------------------------------------------------------------------

/**
 * convert an array of strings to a single multi-line string
 */

export arrayToBlock := (lLines: string[]): string =>

	assert isArray(lLines), "lLines is not an array: #{OL(lLines)}"
	return lLines.filter((line) => defined(line)).join("\n")

# ---------------------------------------------------------------------------

/**
 * return a string as is, convert an array of strings
 * to a single multi-line string
 */

export toBlock := (strOrArray: blockSpec): string =>

	if isString(strOrArray)
		return strOrArray
	else
		return arrayToBlock(strOrArray)

# ---------------------------------------------------------------------------

/**
 * replace these characters with single unicode chars:
 *    carriage return
 *    newline
 *    TAB
 *    space
 * Optionally, add a character to indicate a particular
 * position in the string
 * Valid options:
 *    offset - indicate position of offset
 *    poschar - char to use to indicate position
 */

export escapeStr := (
	str: string?,
	hReplace: hash = {
		"\r": '←'
		"\n": '↓'
		"\t": '→'
		" ": '˳'
		},
	hOptions: hash = {}
	): string =>

	if notdefined(str)
		return '<undefined>'
	{offset, poschar} := getOptions hOptions, {
		offset: undef
		poschar: '┊'
		}

	lParts := []
	for ch,i of str.split('')
		if defined(offset) && (i == offset)
			lParts.push poschar
		newch := hReplace[ch]
		if defined(newch)
			lParts.push newch
		else
			lParts.push ch
	if (offset == str.length)
		lParts.push poschar
	return lParts.join('')

# ---------------------------------------------------------------------------

/**
 * replace these characters with single unicode chars:
 *    carriage return
 *    TAB
 *    space
 * Optionally, add a character to indicate a particular
 * position in the string
 */

export escapeBlock := (
	block: string,
	hReplace: hash = {
		"\r": '←'
		"\t": '→'
		" ": '˳'
		},
	hOptions: hash = {}
	): string =>

	return escapeStr(block, hReplace, hOptions)

# ---------------------------------------------------------------------------

export relpath := (path: string): string =>

	return relative(Deno.cwd(), path).replaceAll('\\', '/')

# ---------------------------------------------------------------------------

/**
 * Splits a string on whitespace into an array,
 * ignoring any leading or trailing whitespace
 */

export wsSplit := (str: string): string[] =>

	newstr := str.trim()
	if (newstr == '')
		return []
	else
		return newstr.split(/\s+/)

# ---------------------------------------------------------------------------

/**
 * splits each string on whitespace ignoring any leading
 * or trailing whitespace, and returns an array of
 * all substrings obtained
 */

export words := (...lStrings: string[]): string[] =>

	let lWords = []
	for str of lStrings
		for word of wsSplit(str)
			lWords.push word
	return lWords

# ---------------------------------------------------------------------------

/**
 * calculates the number of extra characters needed to
 * make the given string have the given length.
 * If not possible, returns 0
 */

export getNExtra := (str: string, len: number): number =>

	extra := len - str.length
	return (extra > 0) ? extra : 0

# ---------------------------------------------------------------------------

/**
 * pads the given string on the right with
 * the given character, to the given length
 */

export rpad := (str: string, len: number, ch: string=' '): string =>

	assert (ch.length == 1), "Not a char"
	extra := getNExtra(str, len)
	return str + ch.repeat(extra)

# ---------------------------------------------------------------------------

/**
 * pads the given string on the left with
 * the given character, to the given length
 */

export lpad := (str: string, len: number, ch: string=' '): string =>

	assert (ch.length == 1), "Not a char"
	extra := getNExtra(str, len)
	return ch.repeat(extra) + str

# ---------------------------------------------------------------------------
# --- valid options:
#        char - char to use on left and right
#        buffer - num spaces around text when char <> ' '

/**
 * pads the given string on both the left and right
 * with the given character, to the given length
 * but with the given number of buffer chars surrounding
 * the text
 */

export centered := (
	text: string,
	width: number,
	char: string = ' ',
	numBuffer: number = 2
	): string =>

	totSpaces := width - text.length
	if (totSpaces <= 0)
		return text
	numLeft := Math.floor(totSpaces / 2)
	numRight := totSpaces - numLeft
	if (char == ' ')
		return spaces(numLeft) + text + spaces(numRight)
	else
		buf := ' '.repeat(numBuffer)
		left := char.repeat(numLeft - numBuffer)
		right := char.repeat(numRight - numBuffer)
		return left + buf + text + buf + right

# ---------------------------------------------------------------------------

/**
 * pad a string on the left, right, or both
 * to the given width
 */

export type alignment = 'l'|'c'|'r'|'left'|'center'|'right'

export isAlignment := (x: any): x is alignment =>

	return ['l','c','r','left','center','right'].includes(x)

export alignString := (
	str: string,
	width: number,
	align: alignment
	): string ->

	switch align
		when 'left', 'l'
			return rpad(str, width)
		when 'center', 'c'
			return centered(str, width)
		when 'right', 'r'
			return lpad(str, width)

# ---------------------------------------------------------------------------

/**
 * converts the given number to a string, then pads on the left
 * with zeros to achieve the given length
 */

export zpad := (n: number, len: number): string =>

	return lpad(n.toString(), len, '0')

# ---------------------------------------------------------------------------
# GENERATOR

export allMatches := (str: string, re: RegExp): Generator<string[], void, void> ->

	# --- Ensure the regex has the global flag (g) set
	newre := new RegExp(re, re.flags + (re.flags.includes('g') ? '' : 'g'))
	let lMatches: string[] | null = null
	while defined(lMatches = newre.exec(str))
  		yield lMatches
	return

# ---------------------------------------------------------------------------
# GENERATOR

export type TNodeInfo = {
	node: any
	level: integer
	}

export class NodeGenerator

	filter
	setYielded = new WeakSet<any>()

	constructor(@filter: FilterFunc = isNonPrimitive)

	allNodes(
			obj: any
			objLevel: integer = 0
			): Generator<TNodeInfo, void, void>

		if @setYielded.has(obj)
			return
		if @filter(obj)
			yield {
				node: obj,
				level: objLevel
				}
			@setYielded.add obj
		if isArray(obj)
			for item of obj
				for {node, level} of @allNodes(item, objLevel+1)
					yield {node, level}
					@setYielded.add node
		else if isHash(obj)
			for key of Object.keys(obj)
				value := obj[key]
				for {node, level} of @allNodes(value, objLevel+1)
					yield {node, level}
					@setYielded.add node
		return
