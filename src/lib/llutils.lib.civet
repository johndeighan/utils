# llutils.lib.civet

import {stripAnsiCode} from "@std/fmt/colors"
import {createRequire} from "node:module"
import {sprintf} from "@std/fmt/printf"
import {relative} from '@std/path'

import {
	undef, defined, notdefined, assert, char, deepEqual,
	isHash, isArray, isNonEmptyString, isArrayOfStrings,
	isEmpty, nonEmpty, isString, isInteger,
	integer, hash, hashof, array, arrayof, voidFunc,
	isNonPrimitive, functionDef, croak,
	assertIsString, assertIsNumber,
	} from 'datatypes'

/**
 * @module llutils - low level utilities
 */

llutilsLoadTime: integer := Date.now()

# ---------------------------------------------------------------------------

export sinceLoad := (datetime: Date | integer = Date.now()) =>

	if (datetime instanceof Date)
		return datetime.valueOf() - llutilsLoadTime
	else
		return datetime - llutilsLoadTime

# ---------------------------------------------------------------------------

export sinceLoadStr := (datetime: (Date | integer)? = undef) =>

	return sprintf("%6d", sinceLoad(datetime))

# ---------------------------------------------------------------------------

/**
 * Asserts that `cond` is true. If it isn't, an exception is
 * thrown with the given `msg`
 */

export throwsError := (func: voidFunc, msg: string="Unexpected success"): void =>

	try
		func()
		throw new Error(msg)
	catch err
		return    # ignore error - it was expected

# ---------------------------------------------------------------------------

/**
 * Calling pass() does nothing
 */

export pass := (): void =>    # do nothing

# ---------------------------------------------------------------------------

export truncStr := (str: string, len: number) =>

	if (str.length <= len)
		return str
	return str.substring(0, len-3) + '...'

# ---------------------------------------------------------------------------

export stringify := (
	x: unknown,
	hOptions: hash={}
	level: number=0
	): string =>

	type opt = {
		oneLine: boolean
		compress: boolean
		trunc: number
		}
	{oneLine, compress, trunc
		} := getOptions<opt> hOptions, {
		oneLine: false
		compress: true
		trunc: 0
		}

	result: string := switch typeof x
		when 'undefined'
			'undefined'
		when 'boolean'
			x ? 'true' : 'false'
		when 'number'
			x.toString()
		when 'bigint'
			x.toString() + 'n'
		when 'string'
			"\"#{escapeStr(x, o'style=C')}\""
		when 'symbol'
			if defined(x.description)
				"Symbol(\"#{x.description}\")"
			else
				"Symbol()"
		when 'object'
			if (x == null)
				'null'
			else if isArray(x)
				lParts := stringify(item, hOptions, level+1) for item of x
				if oneLine
					'[' + lParts.join(', ') + ']'
				else
					'[\n' + lParts.join(',\n') + '\n]'
			else if isHash(x)
				lParts := for key,val in x
					"#{key}: #{stringify(val, hOptions, level+1)}"
				if oneLine
					'{' + lParts.join(', ') + '}'
				else
					'{\n' + lParts.join(',\n') + '\n}'
			else
				"<unknown>"
		when 'function'
			functionDef(x)
		else
			croak "Can't stringify #{x}"

	if isInteger(trunc) && (trunc > 0)
		return truncStr(result, trunc)
	else
		return result

# ---------------------------------------------------------------------------

export strToHash := (str: string): hash =>

	if isEmpty(str)
		return {}
	h: hash := {}
	for word of str.trim().split(/\s+/)
		if lMatches: string[] | null := word.match(///^
				(\!)?                    # negate value
				([A-Za-z][A-Za-z_0-9]*)  # identifier
				(?:
					(=)
					(.*)
					)?
				$///)
			[_, neg, ident, eqSign, str] := lMatches
			if isNonEmptyString(eqSign)
				assert notdefined(neg) || (neg == ''),
						"negation with string value"

				# --- check if str is a valid number
				if str.match(/^-?\d+(\.\d+)?$/)
					num := parseFloat(str)
					if Number.isNaN(num)
						# --- TO DO: interpret backslash escapes
						h[ident] = str
					else
						h[ident] = num
				else
					h[ident] = str
			else if neg
				h[ident] = false
			else
				h[ident] = true
		else
			croak "Invalid word #{word}"
	return h

# ---------------------------------------------------------------------------

export o := (lStrings: TemplateStringsArray): hash =>

	return strToHash(lStrings[0])

# ---------------------------------------------------------------------------

/**
 * s - convert leading tabs to spaces
 */

export s := (lStrings: TemplateStringsArray): string =>

	console.log "calling function s"
	replacer := (match: string): string =>
		console.log "match = <#{escapeStr(match)}>"
		result := '   '.repeat(match.length)
		console.log "result = <#{escapeStr(result)}>"
		return result
	return lStrings[0].replaceAll(/^\t+/mg, replacer)

# ---------------------------------------------------------------------------

/**
 * t - convert leading spaces to tabs
 */

export t := (lStrings: TemplateStringsArray): string =>

	replacer := (match: string): string =>
		level := Math.floor(match.length / 3)
		return '\t'.repeat(level)
	return lStrings[0].replaceAll(/^\x20+/mg, replacer)

# ---------------------------------------------------------------------------

/**
 * returns a hash of options with their values,
 * - adding any default values from hDefaults
 *   if they're missing
 */

export getOptions := <T extends hash>(
		hOptions: hash={},
		hDefaults: T
		): T =>

	return {...hDefaults, ...hOptions}

# ---------------------------------------------------------------------------

/**
 * remove all keys from a hash that have either an empty name
 * or an empty value
 */

export removeEmptyKeys := (h: hash): hash =>

	hResult: hash := {}
	for key of keys(h)
		if nonEmpty(key) && nonEmpty(h[key])
			hResult[key] = h[key]
	return hResult

# ---------------------------------------------------------------------------

/**
 * return an array of all own keys in a hash
 * with possible exceptions
 */

export keys := (obj: hash, hOptions: hash={}): string[] =>

	type opt = {
		lExcept: string | string[]
		}
	{lExcept} := getOptions<opt> hOptions, {
		lExcept: []
		}

	lRealExcept := isString(lExcept) ? [lExcept] : lExcept
	lKeys: string[] := []
	for key of Object.keys(obj)
		if not lRealExcept.includes(key)
			lKeys.push key
	return lKeys

# ---------------------------------------------------------------------------

export hasOwn := Object.hasOwn

# ---------------------------------------------------------------------------

export hasKey := (obj: unknown, ...lKeys: string[]) =>

	if (typeof obj != 'object') || (obj == null)
		return false
	for key of lKeys
		if not obj.hasOwnProperty(key)
			return false
	return true

export hasKeys := hasKey

# ---------------------------------------------------------------------------

export missingKeys := (h: hash, ...lKeys: string[]): string[] =>

	if notdefined(h)
		return lKeys
	assert isHash(h), "h not a hash: #{h}"
	lMissing: string[] := []
	for key of lKeys
		if not h.hasOwnProperty(key)
			lMissing.push key
	return lMissing

# ---------------------------------------------------------------------------

/**
 * merges the provided objects into a new object
 * NOTE: none of the provided arguments are modified
 */

export merge := (...lObjects: hash[]): hash =>

	return Object.assign({}, lObjects...)

# ---------------------------------------------------------------------------

export hit := (pct: number = 50): boolean =>

	return (100 * Math.random() < pct)

# ---------------------------------------------------------------------------
# --- ASYNC !

export sleep := (sec: number): void =>

	await new Promise((r) => setTimeout(r, 1000 * sec))
	return

# ---------------------------------------------------------------------------

export sleepSync := (sec: number): void =>

	start := Date.now()
	end := Date.now() + 1000*sec
	while (Date.now() < end)
	return

# ---------------------------------------------------------------------------

/**
 * returns a string consisting of the given number
 * of space characters
 */

export spaces := (n: number): string =>


	return (n <= 0) ? '' : ' '.repeat(n)

# ---------------------------------------------------------------------------

/**
 * returns a string consisting of the given number
 * of TAB characters
 */

export tabs := (n: number): string =>

	return (n <= 0) ? '' : '\t'.repeat(n)

# ---------------------------------------------------------------------------

/**
 * rtrim - strip trailing whitespace
 */

export rtrim := (line: string): string =>

	assert isString(line), "not a string: #{typeof line}"
	lMatches := line.match(/^(.*?)\s+$/)
	return (lMatches == null) ? line : lMatches[1]

# ---------------------------------------------------------------------------

/**
 * Count the number of a specific character in a string
 */

export countChars := (str: string, ch: string): number =>

	let count = 0
	let pos = -1
	while (pos = str.indexOf(ch, pos+1)) != -1
		count += 1
	return count

# ---------------------------------------------------------------------------

/**
 * convert a multi-line string to an array
 * of single line strings
 */

export blockToArray := (block: string): string[] =>

	if isEmpty(block)
		return []
	else
		return block.split(/\r?\n/)

# ---------------------------------------------------------------------------

export allLinesInBlock := (
		block: string
		): Generator<string, void, void> ->

	let start = 0
	let end = block.indexOf('\n')
	while (end != -1)
		yield block.substring(start, end)
		start = end + 1
		end = block.indexOf('\n', start)
	if (start < block.length)
		yield block.substring(start)
	return

# ---------------------------------------------------------------------------

type TLineMapper = (line: string) => string

export mapEachLine := (
		block: string
		mapper: TLineMapper
		) =>

	lLines := for line of allLinesInBlock(block)
		mapper line
	return lLines.join('\n')

# ---------------------------------------------------------------------------

/**
 * A string or string array
 */

export type TBlockSpec = string | string[]

export isBlockSpec := (x: unknown): x is TBlockSpec =>

	return isString(x) || isArrayOfStrings(x)

# ---------------------------------------------------------------------------

/**
 * return an array as is, convert a multi-line string
 * to an array of single line strings
 */

export toArray := (strOrArray: TBlockSpec): string[] =>

	if Array.isArray(strOrArray)
		return strOrArray
	else
		return blockToArray(strOrArray)

# ---------------------------------------------------------------------------

/**
 * convert an array of strings to a single multi-line string
 */

export arrayToBlock := (lLines: string[]): string =>

	assert isArray(lLines), "lLines is not an array: #{lLines}"
	return lLines.filter((line) => defined(line)).join("\n")

# ---------------------------------------------------------------------------

/**
 * return a string as is, convert an array of strings
 * to a single multi-line string
 */

export toBlock := (strOrArray: TBlockSpec): string =>

	if isString(strOrArray)
		return strOrArray
	else
		return arrayToBlock(strOrArray)

# ---------------------------------------------------------------------------

export invertHash := (h: hash): hash =>

	assert isHash(h), "Not a hash: #{h}"
	hResult: hash := {}
	for key of keys(h)
		value := h[key]
		if isString(value)
			hResult[value] = key
	return hResult

# ---------------------------------------------------------------------------

/**
 * by default, replace these characters:
 *    carriage return
 *    newline
 *    TAB
 *    space
 * Optionally, add a character to indicate a particular
 * position in the string
 * Valid options:
 *    offset - indicate position of offset
 *    poschar - char to use to indicate position
 */

hDebugReplace: hashof<string> := {
	"\r": '←'
	"\n": '↓'
	"\t": '→'
	" ":  '˳'
	"←":  '\\←'
	"↓":  '\\↓'
	"→":  '\\→'
	"˳":  '\\˳'
	"\\": '\\\\'
	}

hDebugNoNewlineReplace: hashof<string> := {
	"\t": '→'
	" ":  '˳'
	"→":  '\\→'
	"˳":  '\\˳'
	}

hCReplace: hashof<string> := {
	"\r": '\\r'
	"\n": '\\n'
	"\t": '\\t'
	}

hCNoNewlineReplace: hashof<string> := {
	"\t": '\\t'
	}

export escapeStr := (
		str: string
		hOptions: hash = {}
		): string =>

	type opt = {
		style: string
		hReplace: hashof<string>
		block: boolean
		offset: number?
		range: number[]?      # --- can be [int, int]
		poschar: char
		beginchar: char
		endchar: char
		}
	{
		style,
		hReplace,
		block,
		offset,
		poschar,
		beginchar,
		endchar
		} := getOptions<opt> hOptions, {
			style: 'debug'
			hReplace: {}
			block: false
			offset: undef
			range: undef      # --- can be [int, int]
			poschar: '┊'
			beginchar: '⟨'
			endchar: '⟩'
			}

	let hRealReplace: hashof<string> = {}
	if nonEmpty(hReplace)
		hRealReplace = hReplace
	else if (style == 'C')
		if block
			hRealReplace = hCNoNewlineReplace
		else
			hRealReplace = hCReplace
	else
		if block
			hRealReplace = hDebugNoNewlineReplace
		else
			hRealReplace = hDebugReplace

	[beginPos, endPos] := (
		if defined(range) && isArray(range)
			range
		else
			[undef, undef]
		)

	lParts: string[] := []
	for ch,i of str
		if (i == offset)
			lParts.push poschar
		else if (i == beginPos)
			lParts.push beginchar
		else if (i == endPos)
			lParts.push endchar
		lParts.push (hRealReplace[ch] || ch)
	if (offset == str.length)
		lParts.push poschar
	return lParts.join('')

# ---------------------------------------------------------------------------

export unescapeStr := (
		str: string
		hOptions: hash = {}
		): string =>

	type opt = {
		style: string
		hReplace: hashof<string>
		}
	{style, hReplace} := getOptions<opt> hOptions, {
		style: 'C'
		hReplace: {}
		}

	let hRealReplace: hashof<string> = {}
	if nonEmpty(hReplace)
		hRealReplace = hReplace
	else
		if (style == 'debug')
			hRealReplace = {
				'←': ''
				'↓': '\n'
				'→': '\t'
				'˳': ' '
				}
		else
			hRealReplace = {
				'n': '\n'
				'r': ''     # carriage return should just disappear
				't': '\t'
				}

	let esc = false
	lParts: string[] := []
	for ch,i of str
		if (ch == '\\')
			if esc
				lParts.push '\\'
				esc = false
			else
				esc = true
		else
			if esc
				if defined(hRealReplace[ch])
					lParts.push hRealReplace[ch]
				else
					lParts.push ch
				esc = false
			else
				lParts.push ch
	return lParts.join('')

# ---------------------------------------------------------------------------

/**
 * don't escape newline or carriage return
 * Optionally, add a character to indicate a particular
 * position in the string
 */

export escapeBlock := (
	block: string,
	hOptions: hash = {}
	): string =>

	hOptions.block = true
	return escapeStr(block, hOptions)

# ---------------------------------------------------------------------------

export relpath := (path: string): string =>

	return relative(Deno.cwd(), path).replaceAll('\\', '/')

# ---------------------------------------------------------------------------

/**
 * Splits a string on whitespace into an array,
 * ignoring any leading or trailing whitespace
 */

export wsSplit := (str: string): string[] =>

	newstr := str.trim()
	if (newstr == '')
		return []
	else
		return newstr.split(/\s+/)

# ---------------------------------------------------------------------------

/**
 * splits each string on whitespace ignoring any leading
 * or trailing whitespace, and returns an array of
 * all substrings obtained
 */

export words := (...lStrings: string[]): string[] =>

	let lWords = []
	for str of lStrings
		for word of wsSplit(str)
			lWords.push word
	return lWords

# ---------------------------------------------------------------------------

/**
 * calculates the number of extra characters needed to
 * make the given string have the given length.
 * If not possible, returns 0
 */

export getNExtra := (str: string, len: number): number =>

	extra := len - str.length
	return (extra > 0) ? extra : 0

# ---------------------------------------------------------------------------

/**
 * pads the given string on the right with
 * the given character, to the given length
 */

export rpad := (str: string, len: number, ch: string=' '): string =>

	assert (ch.length == 1), "Not a char"
	extra := getNExtra(str, len)
	return str + ch.repeat(extra)

# ---------------------------------------------------------------------------

/**
 * pads the given string on the left with
 * the given character, to the given length
 */

export lpad := (str: string, len: number, ch: string=' '): string =>

	assert (ch.length == 1), "Not a char"
	extra := getNExtra(str, len)
	return ch.repeat(extra) + str

# ---------------------------------------------------------------------------
# --- valid options:
#        char - char to use on left and right
#        buffer - num spaces around text when char <> ' '

export centered := (
	text: string,
	width: number,
	char: string = ' ',
	numBuffer: number = 2
	): string =>

	totSpaces := width - text.length
	if (totSpaces <= 0)
		return text
	numLeft := Math.floor(totSpaces / 2)
	numRight := totSpaces - numLeft
	if (char == ' ')
		return spaces(numLeft) + text + spaces(numRight)
	else
		buf := ' '.repeat(numBuffer)
		left := char.repeat(numLeft - numBuffer)
		right := char.repeat(numRight - numBuffer)
		return left + buf + text + buf + right

# ---------------------------------------------------------------------------

/**
 * pad a string on the left, right, or both
 * to the given width
 */

export type TAlignment = 'l'|'c'|'r'|'left'|'center'|'right'

export isAlignment := (x: unknown): x is TAlignment =>

	return (
		   (typeof x == 'string')
		&& ['l','c','r','left','center','right'].includes(x)
		)

export alignString := (
	str: string,
	width: number,
	align: TAlignment
	): string ->

	switch align
		when 'left', 'l'
			return rpad(str, width)
		when 'center', 'c'
			return centered(str, width)
		when 'right', 'r'
			return lpad(str, width)

# ---------------------------------------------------------------------------

/**
 * converts the given number to a string, then pads on the left
 * with zeros to achieve the given length
 */

export zpad := (n: number, len: number): string =>

	return lpad(n.toString(), len, '0')

# ---------------------------------------------------------------------------
# GENERATOR

export allMatches := (str: string, re: RegExp): Generator<string[], void, void> ->

	# --- Ensure the regex has the global flag (g) set
	newre := new RegExp(re, re.flags + (re.flags.includes('g') ? '' : 'g'))
	let lMatches: string[] | null = null
	while defined(lMatches = newre.exec(str))
  		yield lMatches
	return

# ---------------------------------------------------------------------------

/**
 * A generator that yields integers starting with 0 and
 * continuing to n-1
 */

export range := (
	n: number
	): Generator<number, void, void> ->

	let i = 0
	while (i < n)
		yield i
		i = i + 1
	return

# ---------------------------------------------------------------------------

export class Fetcher<T>

	iter: Iterator<T>
	buffer: T? = undef

	constructor(@iter: Iterator<T>, @eofValue: T)

	peek(): T
		if defined(@buffer)
			return @buffer
		else
			{value, done} := @iter.next()
			if done
				return @eofValue
			else
				@buffer = value
				return value

	get(expected: T?=undef): T
		let result: T = @eofValue
		if defined(@buffer)
			result = @buffer
			@buffer = undef
		else
			{value, done} := @iter.next()
			result = done ? @eofValue : value
		if defined(expected)
			assert deepEqual(result, expected),
					"#{expected} expected"
		return result

	skip(expected: T?=undef): void
		@get(expected)
		return

	atEnd(): boolean
		if defined(@buffer)
			return false
		else
			{value, done} := @iter.next()
			if done || (value == @eofValue)
				return true
			else
				@buffer = value
				return false

# ---------------------------------------------------------------------------

export assertSameStr := (
		str1: string,
		str2: string
		): void =>

	if (str1 != str2)
		console.log centered("Strings Differ:", 64, '-')
		console.log centered("string 1", 64, '-')
		console.log str1
		console.log centered("string 2", 64, '-')
		console.log str2
		console.log '-'.repeat(64)

	assert (str1 == str2), "strings differ"
	return

# ---------------------------------------------------------------------------

export interpolate := (
		str: string
		hReplace: hashof<string>   # --- { <tag>: <replacement>, ... }
		): string =>

	for key of keys(hReplace)
		assert (key[0] == '$'), "all keys must start with '$'"
	re := ///
		\$
		(?:[A-Za-z][A-Za-z0-9]*)
		///g
	return str.replaceAll(re, (match: string) =>
		return hReplace[match] || match
		)

# ---------------------------------------------------------------------------
# --- generate random labels

labelGen := (): Generator<string, void, void> ->

	for ch of ['A'..'Z']
		yield ch
	for ch of ['A'..'Z']
		for ch2 of ['A'..'Z']
			yield ch + ch2
	for ch of ['A'..'Z']
		for ch2 of ['A'..'Z']
			for ch3 of ['A'..'Z']
				yield ch + ch2 + ch3
	return

# --- Create an iterator from the generator
labels := labelGen()

export randomLabel := (): string =>
	label := labels.next()
	return label.done ? 'ERR!' : label.value

# ---------------------------------------------------------------------------

export require := createRequire(import.meta.url)

# ---------------------------------------------------------------------------

export getLineAndColumn := (text: string, pos: number) =>

	# --- Get line number by counting number of \n chars
	#        before the current position
	#     Get column number by finding closest previous position
	#        of a \n and computing the difference

	shortStr := text.substring(0, pos)
	return [
		countChars(shortStr, "\n") + 1
		pos - shortStr.lastIndexOf('\n')
		]

# ---------------------------------------------------------------------------

export class KeyedStringSet

	hMap := new Map<string, Set<string>>

	# ..........................................................

	add(key: string, value: string): void

		aSet := @hMap.get key
		if defined(aSet)
			aSet.add value
		else
			newSet := new Set<string>()
			newSet.add value
			@hMap.set key, newSet
		return

	# ..........................................................

	allKeys(): Generator<string, void, void>

		yield* @hMap.keys()
		return

	# ..........................................................

	allValues(key: string): Generator<string, void, void>

		aSet := @hMap.get key
		if defined(aSet)
			yield* aSet.values()
		return
