# datatypes.lib.civet

import {minify} from 'npm:uglify-js'
import deepEqual from 'npm:fast-deep-equal'

export {deepEqual}

/**
 * @module datatypes - TypeScript datatype checking
 */

# ---------------------------------------------------------------------------

/**
 * a function that takes no arguments and returns nothing
 * [unit tests](../test/datatypes.test.civet#:~:text=DBG,voidFunc)
 */

export type voidFunc = () => void

export type TFilterFunc = (item: unknown) => boolean
export type TStringifier = (item: unknown) => string
export type TStringParser = (str: string) => unknown
export type TAssertFunc = (cond: boolean, msg?: string) => void

# ---------------------------------------------------------------------------

/**
 * An alias for JavaScript's `undefined`
 * [unit tests](../test/datatypes.test.civet#:~:text=DBG,undef)
 */

export undef := undefined

# ---------------------------------------------------------------------------

/**
 * returns true if the provided value is defined
 * (i.e. not null or undefined), else returns false
 * [unit tests](../test/datatypes.test.civet#:~:text=DBG,defined)
 */

export type TObject = {
	[key: string]: unknown
	[sym: symbol]: unknown
	}
export type TDefined = NonNullable<unknown>

export defined := (x: unknown): x is TDefined =>

	return (x != undef) && (x != null)

# ---------------------------------------------------------------------------

/**
 * Returns true if the value provided is not defined
 * (i.e. either null or undefined), else returns false
 * [unit tests](../test/datatypes.test.civet#:~:text=DBG,notdefined)
 */

export notdefined := (x: unknown): x is undefined =>

	return (x == undef) || (x == null)

# ---------------------------------------------------------------------------

/**
 * throws an exception with the provided message
 */

export croak := (msg: string): never =>

	throw new Error(msg)

# ---------------------------------------------------------------------------

/**
 * Asserts that `cond` is true. If it isn't, an exception is
 * thrown with the given `msg`
 */

export assert: TAssertFunc := (
		cond: boolean,
		msg: string="An error occurred"
		): asserts cond =>

	if !cond
		croak(msg)
	return

# ---------------------------------------------------------------------------
# --- general JavaScript function to get the type of a value

export jsType := (x: unknown): string =>

	if (typeof x == 'undefined')
		return 'undef'

	if (typeof x == 'bigint')
		return 'integer'

	if (typeof x == 'number')
		return (
			  Number.isNaN(x)    ? 'NaN'
			: Number.isFinite(x) ? (Number.isInteger(x) ? 'integer' : 'number')
			: ((x < 0) ? 'neginfinity' : 'infinity')
			)

	if (typeof x == 'function')
		# --- If it's a function whose source code starts with
		#     the "class" keyword, it's a class
		str := x.toString()
		if str.startsWith('class')
			# --- get name with className(x)
			#     get definition with classDef(x)
			return 'class'
		else
			return 'function' # get name with functionName(x)

	if (typeof x == 'object')
		if (x == null)
			return 'null'
		if Array.isArray(x)
			return 'array'
		if (x instanceof String)
			return 'string'
		if (x instanceof Boolean)
			return 'boolean'
		if (x instanceof Number)
			return Number.isInteger(x) ? 'integer' : 'number'
		if (x instanceof RegExp)
			# --- get definition with regexpDef(x)
			return 'regexp'
		className := x?.constructor?.name
		if (className == 'Object')
			return 'hash'
		else
			return 'instance'  # get class name with x.constructor.name
	else
		return (typeof x)

# ---------------------------------------------------------------------------

export isSymbol := (x: unknown): boolean =>

	return (typeof x == 'symbol')

# ---------------------------------------------------------------------------

export symbolName := (x: unknown): string =>

	if (typeof x == 'symbol')
		return x.description || ''
	throw new Error("Not a symbol")

# ---------------------------------------------------------------------------

export functionName := (x: Function): string =>

	return x.name || ''

# ---------------------------------------------------------------------------

export functionDef := (x: Function): string =>

	return normalizeExpr(x.toString())

# ---------------------------------------------------------------------------

export regexpDef := (x: unknown): string =>

	if (typeof x == 'object') && (x instanceof RegExp)
		return x.source
	croak "Not a RegExp"
	return ''      # --- TypeScript bug

# ---------------------------------------------------------------------------

export classDef := (x: unknown): string =>

	if (typeof x == 'function') && x.toString().startsWith('class')
		return normalizeCode(x.toString())
	croak "Not a class"
	return ''      # --- TypeScript bug

# ---------------------------------------------------------------------------

export className = (x: unknown): string? =>
	# --- item can be a class or an object

	if (typeof x == 'function') && x.toString().startsWith('class')
		return x.name || ''
	if (typeof x == 'object') && (x != null)
		return x.constructor.name || ''
	croak "Not a class"
	return ''      # --- TypeScript bug

# ---------------------------------------------------------------------------

/**
 * An array containing anything
 * [unit tests](../test/datatypes.test.civet#:~:text=DBG,array)
 */

export type array = unknown[]
export type arrayof<T> = T[]

/**
 * Test if something is an array
 * [unit tests](../test/datatypes.test.civet#:~:text=DBG,isArray)
 */

export isArray := (x: unknown): x is array =>

	return Array.isArray(x)

# ---------------------------------------------------------------------------

/**
 * An alias for TypeScript type 'object' with string keys
 * [unit tests](../test/datatypes.test.civet#:~:text=DBG,hash)
 */

export interface hash
	[key: string | symbol]: unknown

export interface hashof<T>
	[key: string | symbol]: T

# ---------------------------------------------------------------------------

/**
 * Test if something is a hash
 * [unit tests](../test/datatypes.test.civet#:~:text=DBG,isHash)
 */

export isHash := (x: unknown): x is hash =>

	return (jsType(x) == 'hash')

# ---------------------------------------------------------------------------

export type TObjCompareFunc = (h1: hash, h2: hash) => number
export type TObjLikeFunc = (h: hash, hPat: hash) => boolean
export type TToStringFunc = (h: hash) => string

export hashLike := (h: hash, hPat: hash): boolean =>

	lHashKeys := Object.keys(h)
	for key of Object.keys(hPat)
		if lHashKeys.includes(key)
			patVal := hPat[key]
			if defined(patVal) && not deepEqual(h[key], patVal)
				return false
		else
			return false
	return true

# ---------------------------------------------------------------------------

/**
 * returns true if (typeof item == 'string') or item instanceof String
 * [unit tests](../test/datatypes.test.civet#:~:text=DBG,isString)
 */

export isString := (x: unknown): x is string =>

	return (typeof x == 'string') || (x instanceof String)

# ---------------------------------------------------------------------------

export type char = string

export isChar := (x: unknown): x is char =>

	return isString(x) && (x.length == 1)

# ---------------------------------------------------------------------------

export type nonEmptyString = string

/**
 * Test if something is a non-empty string,
 * i.e. isn't all whitespace
 * [unit tests](../test/datatypes.test.civet#:~:text=DBG,isNonEmptyString)
 */

export isNonEmptyString := (x: unknown): x is nonEmptyString =>

	# --- must contain non-whitespace character
	return isString(x) && defined(x.match(/\S/))

# ---------------------------------------------------------------------------

/**
 * Test if something is a boolean
 * [unit tests](../test/datatypes.test.civet#:~:text=DBG,isBoolean)
 */

export isBoolean := (x: unknown): x is boolean =>

	return (typeof x == 'boolean') || (x instanceof Boolean)

# ---------------------------------------------------------------------------

/**
 * Test if something is a number
 * [unit tests](../test/datatypes.test.civet#:~:text=DBG,isNumber)
 */

export isNumber := (x: unknown): x is number =>

	return (
		   (typeof x == 'bigint')
		|| (typeof x == 'number')
		|| (x instanceof Number)
		)

# ---------------------------------------------------------------------------

export isPrimitive := (x: unknown): boolean =>

	return isString(x) || isNumber(x) || isBoolean(x)

# ---------------------------------------------------------------------------

export isNonPrimitive := (x: unknown): boolean =>

	return (x != null) && (typeof x == 'object')

# ---------------------------------------------------------------------------

/**
 * Type integer
 */

export type integer = number

/**
 * Test if something is an integer
 * [unit tests](../test/datatypes.test.civet#:~:text=DBG,isInteger)
 */

export isInteger := (x: unknown): x is integer =>

	return isNumber(x) && Number.isInteger(x.valueOf())

# ---------------------------------------------------------------------------

/**
 * Type intArray
 */

export type intArray = integer[]

export isArrayOfIntegers := (x: unknown): x is intArray =>

	if not Array.isArray(x)
		return false
	for item of x
		if not isInteger(item)
			return false
	return true

# ---------------------------------------------------------------------------

/**
 * Test if something is an array of strings
 * [unit tests](../test/datatypes.test.civet#:~:text=DBG,isArrayOfStrings)
 */

export isArrayOfStrings := (x: unknown): x is string[] =>

	if not Array.isArray(x)
		return false
	for item of x
		if not isString(item)
			return false
	return true

# ---------------------------------------------------------------------------

/**
 * Type regexp - a regular expression
 * [unit tests](../test/datatypes.test.civet#:~:text=DBG,regexp)
 */

export type regexp = RegExp

/**
 * Test if something is a regular expression
 * [unit tests](../test/datatypes.test.civet#:~:text=DBG,isRegExp)
 */

export isRegExp := (item: unknown): item is regexp =>

	return (item instanceof RegExp)

# ---------------------------------------------------------------------------

/**
 * Test if something is an object
 * [unit tests](../test/datatypes.test.civet#:~:text=DBG,isObject)
 */

export isObject := (x: unknown): x is object =>

	return (typeof x == 'object') && (x != null)

# ---------------------------------------------------------------------------

/**
 * Test if something is a function
 * [unit tests](../test/datatypes.test.civet#:~:text=DBG,isFunction)
 */

export isFunction := (item: unknown): boolean =>

	return (typeof item == 'function')

# ---------------------------------------------------------------------------

/**
 * returns true if any of these is true:
 * 	- x is null or undef
 * 	- x is a string consisting of only whitespace
 * 	- x is an array of length 0
 * 	- x is a hash that has no keys
 * else returns false
 * [unit tests](../test/datatypes.test.civet#:~:text=DBG,isEmpty)
 */

export isEmpty := (x: unknown): boolean =>

	if (x == undef) || (x == null)
		return true
	if isString(x)
		return (x.match(/^\s*$/) != null)
	if isArray(x)
		return (x.length == 0)
	if isHash(x)
		return (Object.keys(x).length == 0)
	else
		return false

# ---------------------------------------------------------------------------

/**
 * returns not isEmpty(x)
 * [unit tests](../test/datatypes.test.civet#:~:text=DBG,nonEmpty)
 */

export nonEmpty := (x: unknown): boolean =>

	return not isEmpty(x)

# ---------------------------------------------------------------------------

export lMark := '⸂'    # --- U+2E02
export rMark := '⸃'    # --- U+2E03

export hide := (str: string): string =>

	return lMark + str + rMark

# ---------------------------------------------------------------------------

export unhide := (str: string): string =>

	lParts: string[] := []
	let pos = 0
	let start = str.indexOf('"'+lMark, pos)
	while (start >= 0)
		end := str.indexOf(rMark+'"', start)
		if (end == -1)
			break
		else
			lParts.push str.substring(pos, start)
			lParts.push str.substring(start+2, end)
			pos = end+2
		start = str.indexOf('"'+lMark, pos)
	lParts.push str.substring(pos)
	return lParts.join('')

# ---------------------------------------------------------------------------

export isClass := (x: unknown): boolean =>

	if (typeof x != 'function')
		return false
	return x.toString().startsWith('class')

# ---------------------------------------------------------------------------

export isPromise := (x: unknown): boolean =>

	return (
		(typeof x == 'object')
		&& (x != null)
		&& ('then' in x)
		&& (typeof x.then == 'function')
		)

# ---------------------------------------------------------------------------
# --- NOTE: An '&' preceding a key name indicates
#           that it should be a function

export isClassInstance := (
		x: unknown,
		lReqKeys: string[]=[]
		): boolean =>

	if isHash(x)
		if isArray(x) || isPromise(x)
			return false
		if notdefined(x?.constructor?.name)
			return false
		for key of lReqKeys
			let type = undef
			if lMatches := key.match(///^ (\&) (.*) $///)
				[_, type, key] := lMatches
			if (key in x)
				item: any := x[key]
				if nonEmpty(item)
					if (type == '&') && (typeof item != 'function')
						return false
				else
					return false
			else
				return false
		return true
	else
		return false

# ---------------------------------------------------------------------------

export isIterable := (x: unknown): boolean =>

	if isHash(x)
		return (typeof x[Symbol.iterator] == 'function')
	return false

# ---------------------------------------------------------------------------
# --- Functions to normalize JavaScript code & expressions
# ---------------------------------------------------------------------------

export addFunctionNames := (code: string): string =>

	# --- The names we add will look like: '__dummy99' where
	#     '99' can be any sequence of digits
	#     to make it trivial to remove them later

	let id = 99
	re := ///
			function       # 'function' keyword
			\s*            # optional whitespace
			( \* ) ?       # optional '*'
			\s*            # optional whitespace
			\(
			///g
	replaceFunc := (match: string, ast: string?) =>
		n := id
		id += 1
		return (
			  (ast == undefined)
			? "function __dummy#{n.toString()}("
			: "function* __dummy#{n.toString()}("
			)
	return code.replaceAll(re, replaceFunc)

# ---------------------------------------------------------------------------

export removeFunctionNames := (code: string): string =>

	return code.replaceAll(/__dummy\d+/g, '')

# ---------------------------------------------------------------------------

export normalizeCode := (
		code: string,
		): string =>

	# --- Due to a bug in JavaScript, we have to make sure
	#     that all function names (even in generators)
	#     have a name, which we must remove after minimization

	newCode := addFunctionNames(code)

	# --- Remove extra whitespace
	#     Remove extra parens from '(str)=>return'
	#     Remove comments
	hOptions := {
		annotations: false
		mangle: false
		compress: undefined
		keep_fargs: true
		keep_fnames: true
		warnings: true
		}
	hResult := minify newCode, hOptions
	if hResult.error
		throw new Error(hResult.error.message)
	else if hResult.code
		return removeFunctionNames(hResult.code)
	else
		throw new Error("Unknown error in normalizeCode()")

# ---------------------------------------------------------------------------

export normalizeExpr := (
		code: string,
		): string =>

	str := normalizeCode(code)
	len := str.length
	if (str[len-1] == ';')
		return str.substring(0, len-1)
	else
		return str

# ---------------------------------------------------------------------------
