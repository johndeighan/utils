# unit-test.lib.civet

import {
	assert, assertEquals, assertStrictEquals, assertNotEquals,
	assertObjectMatch,
	assertStringIncludes, assertMatch, assertArrayIncludes,
	} from '@std/assert'

import {
	undef, defined, notdefined, isEmpty, nonEmpty,
	array, arrayof, isArray, isHash, isString, hash,
	hashof, isIterable, deepEqual, hashLike, integer,
	TObjCompareFunc, TObjLikeFunc, TToStringFunc,
	normalizeCode, voidFunc, croak,
	} from 'datatypes'
import {
	pass, stringify, o, keys, getOptions, spaces,
	} from 'llutils'
import {OL} from 'to-nice'
import {indented} from 'indent'
import {TextTable} from 'text-table'
import {
	pushLogLevel, popLogLevel,
	DBG, LOG, LOGVALUE, DBGVALUE, INDENT, UNDENT,
	} from 'logger'
import {relpath, mkDir, barf, getPathType, fileExt} from 'fsys'
import {TPLLToken, isKind, allTokensInBlock, tokenTable} from 'pll'
import {checkType} from 'typescript'
import {civet2tsFile} from 'civet'
import {getMyOutsideCaller} from 'v8-stack'
import {
	sourceLib, getNeededImportStmts,
	} from 'symbols'

# ---------------------------------------------------------------------------

/**
 * Generate a test name using the source line number
 */

getTestName := (): string =>

	pushLogLevel 'silent'
	frame := getMyOutsideCaller()
	line := (frame == undef) ? 0 : frame.line
	popLogLevel()
	DBG "TEST NAME: line #{line}"
	return "line #{line}"

# ---------------------------------------------------------------------------

/**
 * In a unit test, checks if  value is deeply equal to
 * the expected value. Reports line number of the test.
 *
 * @param {any} value - any JavaScript value
 * @param {any} expected - any JavaScript value
 * @returns {void} - nothing
 *
 * @example
 * ```js
 * equal 2+2, 4
 * ```
 * This test will pass.
 */

export equal := (value: unknown, expected: unknown) : void =>

	name := getTestName()
	DBG "equal ?, #{stringify(expected)} (#{name})"
	Deno.test name, () => assertEquals(value, expected)
	return

# ---------------------------------------------------------------------------

export same := (value: unknown, expected: unknown) : void =>

	name := getTestName()
	DBG "same ?, #{stringify(expected)} (#{name})"
	Deno.test name, () => assertStrictEquals(value, expected)
	return

# ---------------------------------------------------------------------------

/**
 * In a unit test, tests if value is truthy
 * Reports line number of the test.

 * @param {any} value - any JavaScript value
 * @returns {void} - nothing
 *
 * @example
 * ```js
 * truthy isString('abc')
 * ```
 * This test will pass.
 */

export truthy := (value: unknown): void =>

	name := getTestName()
	DBG "truthy #{stringify(value)} (#{name})"
	Deno.test name, () => assert value
	return

# ---------------------------------------------------------------------------

/**
 * In a unit test, tests if value is falsy
 * Reports line number of the test.
 *
 * @param {any} value - any JavaScript value
 * @returns {void} - nothing
 *
 * @example
 * ```js
 * falsy isString(42)
 * ```
 * This test will pass.
 */

export falsy := (value: unknown): void =>

	name := getTestName()
	DBG "falsy #{stringify(value)} (#{name})"
	Deno.test name, () => assert (not value)
	return

# ---------------------------------------------------------------------------

/**
 * In a unit test, tests if calling the provided function
 * throws an exception. Reports line number of the test.
 *
 * @param {any => any} func - any JavaScript function
 * @returns {void} - nothing
 *
 * @example
 * ```js
 * fails () => throw new Error('bad')
 * ```
 * This test will pass.
 */

export fails := (func: voidFunc): void =>

	pushLogLevel 'silent'    # --- silence any errors generated
	name := getTestName()
	DBG "fails <func> (#{name})"
	Deno.test name, () =>
		try
			func()
			popLogLevel()
			throw new Error("Test Failure - function succeeds!!!")
		catch err
			popLogLevel()

	return

# ---------------------------------------------------------------------------

/**
 * In a unit test, tests if calling the provided function
 * runs without throwing an exception.
 * Reports line number of the test.
 *
 * @param {any => any} func - any JavaScript function
 * @returns {void} - nothing
 *
 * @example
 * ```js
 * succeeds () => return 42
 * ```
 * This test will pass.
 */

export succeeds := (func: voidFunc): void =>

	assert (typeof func == 'function'), "test succeeds() passed non-function"
	name := getTestName()
	DBG "succeeds <func> (#{name})"
	Deno.test name, () =>
		try
			func()
		catch err
			# @ts-ignore
			msg := err.message
			throw new Error("FAIL - func throws (#{msg})")
	return

# ---------------------------------------------------------------------------

export iterEqual := (iter: Iterable<unknown>, expected: unknown[]) =>

	name := getTestName()
	DBG "iterEqual ?, #{stringify(expected)} (#{name})"
	Deno.test name, () => assertEquals Array.from(iter), expected
	return

# ---------------------------------------------------------------------------

export iterLike := (iter: Iterable<hash>, expected: hash[]) =>

	name := getTestName()
	DBG "iterEqual ?, #{stringify(expected)} (#{name})"

	lItems := Array.from(iter)
	len := lItems.length
	Deno.test "#{name}/len", () => assertEquals len, expected.length
	for i of [0..len-1]
		# @ts-ignore
		Deno.test "#{name}/#{i}", () => assertObjectMatch lItems[i], expected[i]
	return

# ---------------------------------------------------------------------------

/**
 * In a unit test, tests a value, which must be a string,
 * matches either a substring or a regular expression.
 * Reports line number of the test.
 *
 * @param {any} value - any JavaScript value
 * @param {any} expected - any JavaScript value
 * @returns {void} - nothing
 *
 * @example
 * ```js
 * matches 'abcde', 'bce'
 * ```
 * This test will pass.
 *
 * @example
 * ```js
 * matches 'aabbcc', /a+b+c+/
 * ```
 * This test will pass.
 */

export matches := (value: unknown, expected: unknown) =>

	assert isString(value), "Not a string: #{value}"
	name := getTestName()
	DBG "matches ?, #{stringify(expected)} (#{name})"
	if isString(expected)
		Deno.test name, () => assertStringIncludes value, expected
	else if (expected instanceof RegExp)
		Deno.test name, () => assertMatch value, expected
	else
		Deno.test name, () => assert false
	return

# ---------------------------------------------------------------------------

/**
 * In a unit test, tests if one hash matches another hash.
 * the first hash must have all the properties in the second hash,
 * but extra properties are allowed.
 * Reports line number of the test.
 *
 * @param {hash} value - any JavaScript object
 * @param {hash} expected - any JavaScript object
 * @returns {void} - nothing
 *
 * @example
 * ```js
 * like {a:1, b:2, c:3}, {a:1, c:3}
 * ```
 * This test will pass.
 */

export like := (value: object?, expected: hash): void =>

	name := getTestName()
	DBG "like ?, #{stringify(expected)} (#{name})"
	if notdefined(value)
		Deno.test name, () => assertEquals value, undef
	else
		Deno.test name, () => assertObjectMatch value, expected
	return

# ---------------------------------------------------------------------------

export codeLike := (value: string, expected: string): void =>

	name := getTestName()
	DBG "codeLike ?, #{stringify(expected)} (#{name})"
	Deno.test name, () =>
		assertEquals normalizeCode(value), normalizeCode(expected)
	return

# ---------------------------------------------------------------------------

export strListLike := (
		value: string[]
		expected: string[]
		): void =>

	name := getTestName()
	DBG "strListLike ?, #{stringify(expected, {trunc: 64})}"

	len := value.length
	Deno.test "#{name}/len", () => assertEquals len, expected.length

	if (len == 0)
		return

	lValues := value.toSorted()
	lExpected := expected.toSorted()
	for i of [0..len-1]
		val := lValues[i]
		exp := lExpected[i]
		# @ts-ignore
		Deno.test "#{name}/#{i}", () => assertEquals(val, exp)
	return

# ---------------------------------------------------------------------------

/**
 * In a unit test, tests if each Object in an array matches
 * each object in another array. The 2 arrays must be of the
 * same length. If a function is passed as the 3rd parameter,
 * then each array is first sorted by using the function to
 * convert each object to a string, then sorting the array
 * using those strings.
 * A matching function can also be provided as the 4th argument.
 * By default, the function hashLike (from llutils.lib) is used.
 * Reports line number of the test.
 *
 * @param {array | object} value - any JavaScript value
 * @param {array | object} expected - any JavaScript value
 * @returns {void} - nothing
 *
 * @example
 * ```js
 * like {a:1, b:2, c:3}, {a:1, c:3}
 * ```
 * This test will pass.
 *
 * @example
 * ```js
 * like [{a:1, b:2, c:3}, {a:3, b:5, c:23}], [{a:1, b:2}]
 * ```
 * This test will pass.
 */

export objListLike := (
		value: hash[]
		expected: hash[]
		strFunc: TToStringFunc? = undef     # used for sorting if defined
		likeFunc: TObjLikeFunc = hashLike   # used for comparison
		): void =>

	name := getTestName()
	DBG "objListLike ?, #{stringify(expected, {trunc: 64})}"
	DBG "strFunc is #{OL(strFunc)}"

	len := value.length
	Deno.test "#{name}/len", () => assertEquals len, expected.length

	if (len == 0)
		return

	# --- create the arrays to actually be compared
	let lVals: hash[] = value

	if defined(strFunc)
		compareFunc: TObjCompareFunc := (a: hash, b: hash) =>
			str1 := strFunc(a)
			str2 := strFunc(b)
			return (str1 < str2) ? -1 : (str1 > str2) ? 1 : 0
		lVals = value.toSorted(compareFunc)

	nVals := lVals.length
	DBG "lVals is array of length #{nVals}"

	let lExp: hash[] = value
	if defined(strFunc)
		DBG "strFunc defined"
		compareFunc: TObjCompareFunc := (a: hash, b: hash) =>
			str1 := strFunc(a)
			str2 := strFunc(b)
			return (str1 < str2) ? -1 : (str1 > str2) ? 1 : 0
		lExp = expected.toSorted(compareFunc)

	nExp := lExp.length
	DBG "lExp is array of length #{nExp}"

	for i of [0..len-1]
		# @ts-ignore
		Deno.test "#{name}/#{i}", () => assert likeFunc(lVals[i], lExp[i])
	return

# ---------------------------------------------------------------------------

/**
 * In a unit test, tests a value, which must be an array,
 * includes the expected value.
 * Reports line number of the test
 *
 * @param {Array<any>} value - an array
 * @param {any} expected - any JavaScript value
 * @returns {void} - nothing
 *
 * @example
 * ```js
 * includes ['a', 'b', 'c'], 'b'
 * ```
 * This test will pass.
 */

export includes := (
		value: unknown,
		expected: unknown
		): void =>

	assert Array.isArray(value), "not an array: #{value}"
	name := getTestName()
	DBG "includes ?, #{stringify(expected)} (#{name})"
	Deno.test name, () => assertArrayIncludes(value, [expected])
	return

# ---------------------------------------------------------------------------

/**
 * In a unit test, tests a value, which must be an array,
 * includes all of the items in the expected array.
 * Reports line number of the test
 *
 * @param {Array<any>} value - an array
 * @param {Array<any>} expected - an array
 * @returns {void} - nothing
 *
 * @example
 * ```js
 * includesAll ['a', 'b', 'c'], ['b', 'c']
 * ```
 * This test will pass.
 */

export includesAll := (
		value: unknown,
		expected: unknown
		): void =>

	assert Array.isArray(value), "not an array: #{value}"
	assert Array.isArray(expected), "not an array: #{expected}"
	name := getTestName()
	DBG "includesAll ?, #{stringify(expected)} (#{name})"
	Deno.test name, () => assertArrayIncludes(value, expected)
	return

# ---------------------------------------------------------------------------

/**
 * In a unit test, tests if a value is of a given type.
 * Relies on a .symbols file being correctly set up, and
 * it containing the type we're testing when testing
 * a non-buildin type
 *
 * @param {string} typeStr - a type as a string
 * @param {any} value - any JavaScript value
 * @returns {void} - nothing
 *
 * @example
 * ```js
 * isType 'string', 'abc'
 * ```
 * This test will pass.
 *
 * @example
 * ```js
 * isType 'number', 'abc'
 * ```
 * This test will fail.
 */

export isType := (
		typeStr: string
		value: unknown
		isOfType: Function?=undef
		): void =>

	name := getTestName()
	if defined(isOfType)
		DBG "Using type guard"
		Deno.test name, () => assert isOfType(value)
	else
		DBG INDENT
		lDiagnostics := checkType(value, typeStr, true)
		if defined(lDiagnostics)
			for msg of lDiagnostics
				console.log msg
		DBG UNDENT
		Deno.test name, () => assert isEmpty(lDiagnostics)
	return

# ---------------------------------------------------------------------------

/**
 * In a unit test, tests if a value is not of a given type.
 *
 * @param {string} typeStr - a type as a string
 * @param {any} value - any JavaScript value
 * @returns {void} - nothing
 *
 * @example
 * ```js
 * notType 'string', 'abc'
 * ```
 * This test will fail.
 *
 * @example
 * ```js
 * notType 'number', 'abc'
 * ```
 * This test will pass.
 */

export notType := (
		typeStr: string
		value: unknown
		isOfType: Function?=undef
		) =>

	name := getTestName()
	if defined(isOfType)
		DBG "Using type guard"
		Deno.test name, () => assert not isOfType(value)
	else
		DBG INDENT
		lDiagnostics := checkType(value, typeStr, false)
		DBG UNDENT
		Deno.test name, () => assert nonEmpty(lDiagnostics)
	return

# ---------------------------------------------------------------------------
# --- Uses a recursive descent parser

export type TFileOp = {
	funcName: 'mkDir' | 'barf'
	path: string
	contents?: string
	}

export setDirTree := (
		currentDir: string,
		contents: string,
		hOptions: hash = {}
		): TFileOp[] =>

	# --- Extract options
	type opt = {
		debug: boolean
		clear: boolean
		compile: boolean
		scaffold: boolean
		}
	{debug, clear, compile, scaffold} := getOptions<opt> hOptions, {
		debug: false
		clear: false
		compile: false
		scaffold: false
		}

	if not debug
		pushLogLevel 'info'
	let level: integer = 0

	# --- return calls made
	lFileOps: TFileOp[] := []

	# ..........................................................

	dbgEnter := (name: string, ...lArgs: unknown[]) =>
		strArgs := (
			for arg of lArgs
				OL(arg)
			).join(', ')
		DBG "#{'   '.repeat(level)}-> #{name}(#{strArgs})"
		level += 1
		return

	# ..........................................................

	dbgExit := (name: string, ...lArgs: unknown[]) =>
		strArgs := (
			for arg of lArgs
				OL(arg)
			).join(', ')
		level -= 1
		DBG "#{'   '.repeat(level)}<- #{name}(#{strArgs})"
		return

	# ..........................................................

	dbg := (line: string) =>
		DBG "#{'   '.repeat(level)}-- #{OL(line)}"
		return

	# ..........................................................

	doMakeDir := (
			dirPath: string
			): void =>

		path := relpath(dirPath)
		lFileOps.push {
			funcName: 'mkDir'
			path
			}
		if not scaffold
			mkDir path, clear
		return

	# ..........................................................

	doBarf := (
			path: string,
			contents: string
			): void =>

		lFileOps.push {
			funcName: "barf"
			path: relpath(path)
			contents
			}
		if not scaffold
			barf path, contents
			if (fileExt(path) == '.civet') && compile
				civet2tsFile path
		return

	# ..........................................................

	fileHandler := (
			path: string,
			lTokens: TPLLToken[]
			): void =>

		dbgEnter 'fileHandler', path
		contents := if isKind(lTokens[0], 'indent')
			lTokens.shift()
			lLines := []
			let level = 0
			# @ts-ignore
			while (level > 0) || not isKind(lTokens[0], 'undent')
				tok := lTokens.shift()
				if notdefined(tok)
					croak "No 'undent' in block"
				else
					switch tok.kind
						when 'indent'
							level += 1
						when 'undent'
							level -= 1
							assert (level >= 0), "Negative level in setDirTree()"
						when 'empty'
							lLines.push ''
						else
							if defined(tok.str)
								line := indented(tok.str, level)
								dbg line
								lLines.push line

			# --- HERE: (level == 0) AND (lTokens[0].kind == 'undent')
			assert (level == 0), "after file contents, level = #{OL(level)}"
			assert (lTokens[0].kind == 'undent'),
					"UNDENT expected after contents, got #{OL(lTokens[0])}"
			lTokens.shift()
			lLines.join('\n')
		else
			''
		doBarf path, contents
		dbgExit 'fileHandler', path
		return

	# ..........................................................

	dirHandler := (
			path: string,
			lTokens: TPLLToken[]
			): void =>

		dbgEnter 'dirHandler', path
		doMakeDir path
		if (lTokens.length > 0) && isKind(lTokens[0], 'indent')
			lTokens.shift()
			blockHandler(path, lTokens)
			# @ts-ignore
			assert isKind(lTokens[0], 'undent'), "Missing UNDENT in dirHandler"
			lTokens.shift()
		dbgExit 'dirHandler', path
		return

	# ..........................................................

	blockHandler := (dirPath: string, lTokens: TPLLToken[]) =>
		dbgEnter 'blockHandler', dirPath
		while (lTokens.length > 0) && (lTokens[0].kind != 'undent')
			tok: TPLLToken := lTokens[0]
			lTokens.shift()
			{kind, str} := tok
			switch kind
				when 'indent'
					croak "Unexpected INDENT"
				else
					if defined(str) && str.startsWith('/')
						dirHandler "#{dirPath}#{tok.str}", lTokens
					else
						fileHandler "#{dirPath}/#{tok.str}", lTokens
		dbgExit 'blockHandler'
		return

	# ..........................................................

	ptype := getPathType(currentDir)
	assert (ptype == 'dir') || (ptype == 'missing'),
			"currentDir is a #{ptype}"

	# --- Clear the directory if it exists
	doMakeDir currentDir

	lTokens := Array.from(allTokensInBlock(contents))
	DBG tokenTable(lTokens)

	blockHandler(currentDir, lTokens)
	assert (lTokens.length == 0),
			"Tokens remaining after parse: #{OL(lTokens)}"
	if not debug
		popLogLevel()
	return lFileOps

# ---------------------------------------------------------------------------

export fileOpsTable := (lFileOps: TFileOp[]): string =>

	tt := new TextTable("l l")
	tt.fullsep()
	tt.title 'FILE OPS'
	tt.fullsep()
	for {funcName, path, contents} of lFileOps
		switch funcName
			when 'mkDir'
				tt.data ['mkdir', path]
			when 'barf'
				tt.data ['barf', path]
				if contents
					for line of contents.split('\n')
						tt.data ['', line.replace('\t', spaces(3))]
	tt.fullsep()
	return tt.asString()

# ---------------------------------------------------------------------------
