# logger.civet

import {existsSync} from "https://deno.land/std/fs/mod.ts";
import {sprintf} from "https://deno.land/std/fmt/printf.ts";
import {
	ConsoleHandler, FileHandler, setup, getLogger,
	LogRecord,
	} from "https://deno.land/std/log/mod.ts";

import {
	assert, croak, pass,
	} from './llutils.ts'
import {
	undef, defined, hash, isString,
	} from './datatypes.ts'
import {
	mkpath, relpath, isDir, isFile, mkDir,
	} from './fs.ts'

Deno := globalThis.Deno
export logFileName : string := "./logs/logs.txt"
export sepdash : string := '-'.repeat(32)
export sepeq : string   := '='.repeat(32)

# --- These are not exported
isSep := (str : string): boolean =>
	return (str == sepdash) || (str == sepeq)

getMainModule := (): string =>
	path: string := new URL(Deno.mainModule).pathname
	return relpath(path.slice(1))

# --- There always needs to be a 'logs' folder in the current directory
mkDir './logs'

let indent : number = 0
prefix := () => '   '.repeat(indent)

# --- Used when current logger is 'profile'
let prevMS: number = 0
let prevFileMS: number = 0
let headerOutput: boolean = false
let fileHeaderOutput: boolean = false

hFileLabel: hash := {
	DEBUG: 'D '
	INFO:  'I '
	WARN:  'W '
	ERROR: 'ERROR: '
	}

hConsoleLabel: hash := {
	DEBUG: ''
	INFO:  ''
	WARN:  ''
	ERROR: ''
	}

# ---------------------------------------------------------------------------

export hLoggerConfig: hash := {
	handlers:

		profile: new ConsoleHandler('DEBUG', {
			formatter: ((rec: LogRecord) =>
				{datetime, msg, levelName} := rec
				ms := datetime.getMilliseconds()
				msStr := sprintf("%5d", ms - prevMS)
				prevMS = ms
				label := hConsoleLabel[levelName]
				if not headerOutput
					headerOutput = true
					return "ms\n-----\n#{msStr} #{label}#{prefix()}#{msg}"
				else
					return "#{msStr} #{label}#{prefix()}#{msg}"
				)
			})

		pfile: new FileHandler('DEBUG', {
			filename: mkpath(logFileName)
			mode: 'a'
			formatter: (rec) =>
				{datetime, msg, levelName} := rec
				ms := datetime.getMilliseconds()
				msStr := sprintf("%5d", ms - prevFileMS)
				prevFileMS = ms
				label := hFileLabel[levelName]
				if not fileHeaderOutput
					fileHeaderOutput = true
					return "ms\n-----\n#{msStr} #{label}#{prefix()}#{msg}"
				else
					return "#{msStr} #{label}#{prefix()}#{msg}"
			})

		console: new ConsoleHandler('DEBUG', {
			formatter: ((rec) =>
				{levelName, msg} := rec
				assert isString(msg), "Not a string: #{msg}"
				if msg.startsWith('=====  ')
					return ''
				label := hConsoleLabel[levelName]
				assert defined(label), "No label for #{levelName}"
				return "#{label}#{prefix()}#{msg}"
				)
			})

		file: new FileHandler('DEBUG', {
			filename: logFileName
			mode: 'a'
			formatter: (rec) =>
				{levelName, msg} := rec
				if isSep(msg)
					return msg
				else if msg.startsWith('=====  ')
					return msg
				else
					label := hFileLabel[levelName]
					assert defined(label), "No label for #{levelName}"
					return "#{label}#{prefix()}#{msg}"
				})

	# --- assign handlers to loggers
	#     must include:
	#        'profile', 'debug', 'info', 'warn', 'error', 'file' and 'silent'
	loggers: {
		profile: {
			level: "DEBUG"
			num: 1
			handlers: ["profile", "pfile"]
			}
		debug: {
			level: "DEBUG"
			num: 2
			handlers: ["console", "file"]
			}
		info: {
			level: "INFO"
			num: 3
			handlers: ["console", "file"]
			}
		warn: {
			level: "WARN",
			num: 4
			handlers: ["console", "file"]
			}
		error: {
			level: "ERROR"
			num: 5
			handlers: ["console", "file"]
			}
		file: {
			level: "DEBUG",
			num: 6
			handlers: ["file"]
			}
		silent: {
			level: "ERROR"
			num: 7
			handlers: []
			}
		}
	}

await setup(hLoggerConfig)

export INDENT : string := 'MOKaHenzkyZNbNWmUYijCNoqmIrIemFh'
export UNDENT : string := 'MXrveSEaCkCfQjEgPdMIaEDFMIWMtHqz'
export CLEAR  : string := '2EYCEu1v7xs0i4L3o5rAV1ZNLFkQYNHh'

# ---------------------------------------------------------------------------
# levels: profile, debug, info, warn, error, file, silent

class LoggerEx

	defLevel: string       = Deno.env.get('DEFAULT_LOGGER') || 'info'
	lLoggerStack: string[] = [@defLevel]
	hConfig: hash          = hLoggerConfig
	hLoggers: hash         = @hConfig.loggers
	silent: boolean        = false
	mainModule: string     = getMainModule()

	constructor()
		@check @defLevel

	curLevel(): string
		result := @lLoggerStack.at(-1)
		if (result == undef)
			throw new Error("empty stack")
		else
			return result

	levelChanged(): void
		switch @curLevel()
			when 'profile'
				# --- NOTE: These are package global variables
				prevMS = prevFileMS = Date.now()
				headerOutput = false
				fileHeaderOutput = false
		return

	setLevel(level: string): void
		@check level
		@lLoggerStack[@lLoggerStack.length-1] = level
		@levelChanged()
		return

	pushLevel(level: string): void
		@check level
		@lLoggerStack.push level
		@levelChanged()
		return

	popLevel(): string
		assert (@lLoggerStack.length > 0), "Empty logger stack"
		level := @lLoggerStack.pop()
		if (level == undef)
			throw new Error("empty stack")
		@levelChanged()
		return level

	isActive(level: string): boolean
		@check level
		curNum := @hLoggers[@curLevel()].num
		lvlNum := @hLoggers[level].num
		return (lvlNum >= curNum)

	output(level: string, lItems: any[]): void
		main := getMainModule()
		if (main != @mainModule)
			logger := getLogger('debug')
			logger.debug "=====  #{main}  ====="
			@mainModule = main
		if @isActive(level)
			for item of lItems
				switch item
					when INDENT
						indent += 1
					when UNDENT
						indent = (indent==0) ? 0 : indent-1
					when CLEAR
						@clearLog()
					else
						str := isString(item) ? item : JSON.stringify(item)
						logger := getLogger(@curLevel())
						switch level
#							when 'profile'
#								logger.profile str
							when 'debug'
								logger.debug str
							when 'info'
								logger.info str
							when 'warn'
								logger.warn str
							when 'error'
								logger.error str
#							when 'file'
#								logger.file str
							when 'silent'
								pass()
							else
								logger.debug str
		return

	flush(): void
		@hConfig.handlers.file.flush()
		@hConfig.handlers.pfile.flush()
		return

	clearLog(): void
		@flush()
		Deno.writeTextFileSync logFileName, ''
		prevMS = prevFileMS = Date.now()
		return

	getFullLog(): string
		@flush()
		text := Deno.readTextFileSync(logFileName)
		return text ? text.trim() : ''

	getLog(): string
		@flush()
		text := Deno.readTextFileSync(logFileName)
		lLines := text ? text.trim().split('\n') : []
		lNewLines := lLines.filter((x) => not x.match(/^=====\s\s/))
		resultStr := lNewLines.join('\n')
		return resultStr

	check(level: string): void
		assert @hLoggers[level], "Bad logger level: '#{level}'"
		return

export logger: LoggerEx := new LoggerEx()

# ---------------------------------------------------------------------------

export DBG  := (...lItems: any[]): void => logger.output 'debug', lItems
export LOG  := (...lItems: any[]): void => logger.output 'info', lItems
export WARN := (...lItems: any[]): void => logger.output 'warn', lItems
export ERR  := (...lItems: any[]): void => logger.output 'error', lItems

export curLogLevel  := (): string => return logger.curLevel()
export setLogLevel  := (level: string): void => logger.setLevel(level)
export pushLogLevel := (level: string): void => logger.pushLevel(level)
export popLogLevel  := (): string => return logger.popLevel()
export clearLog     := (): void => return logger.clearLog()
export getFullLog   := (): string => return logger.getFullLog()
export getLog       := (): string => return logger.getLog()
export flushLog     := (): void => logger.flush()
