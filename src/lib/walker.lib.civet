# walker.lib.civet

import {
	undef, defined, notdefined, integer, hash, array,
	isArray, isHash, isPrimitive, assert, croak, isEmpty,
	assertIsString, assertIsArray,
	} from 'datatypes'
import {extract} from 'extract'
import {OL} from 'to-nice'
import {DBG} from 'logger'

# ---------------------------------------------------------------------------

hasChildren := (x: unknown) =>
	return isHash(x) || isArray(x)

export class Walker<T extends object = hash>

	# --- Keep track of nodes visited to avoid infinite loops
	setVisited: WeakSet<hash | array> = new WeakSet<hash | array>()

	lNodeStack: T[] = []

	# ..........................................................

	get level(): integer

		return @lNodeStack.length

	# ..........................................................

	parent(n: integer = 1): T

		len := @lNodeStack.length
		assert (n >= 0) && (n < len), "Bad index: #{n} of #{len}"
		return @lNodeStack[len-n-1]

	# ..........................................................

	isNode(x: unknown): x is T

		return true

	# ..........................................................

	filter(node: T): boolean

		return true

	# ..........................................................

	extract(dspath: string): unknown?

		DBG "dspath = '#{dspath}'"
		lMatches := dspath.match ///^
				(\^*)
				(.*)
				$///
		if defined(lMatches)
			[_, goUpStr, mainStr] := lMatches
			return extract @parent(goUpStr.length), mainStr
		else
			croak "Bad dspath: #{dspath}"

	# ..........................................................

	getString(dspath: string): string

		str := @extract dspath
		assertIsString str
		return str

	# ..........................................................

	getArray(dspath: string): unknown[]

		lItems := @extract dspath
		assertIsArray lItems
		return lItems

	# ..........................................................
	# GENERATOR

	walk(x: unknown): Generator<T, void, void>

		if hasChildren(x)
			@setVisited = new WeakSet<hash | array>()
			yield* @walkItem x
		return

	# ..........................................................
	# GENERATOR

	walkItem(item: hash | array): Generator<T, void, void>

		if @setVisited.has item
			return

		if @isNode(item)
			# --- type narrowing ensures that item is a T
			if @filter(item)
				DBG "YIELD NODE: #{OL(item)}"
				yield item
				@setVisited.add item

			@lNodeStack.push item    # --- item is parent of yielded items

		if isArray item
			for x,i of item
				if isHash(x) || isArray(x)
					yield* @walkItem x
		else
			for [key,x] of Object.entries(item)
				if isHash(x) || isArray(x)
					yield* @walkItem x
		if @isNode(item)
			@lNodeStack.pop()
		return
