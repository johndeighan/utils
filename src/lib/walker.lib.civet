# walker.lib.civet

import {
	undef, defined, notdefined, integer,
	isArray, isObject, isPrimitive,
	} from 'datatypes'
import {OL} from 'llutils'
import {DBG} from 'logger'

# ---------------------------------------------------------------------------

type TIndex = string | number

export type TNodeInfo<T> = {
	node: T
	level: integer
	parent: T?
	index?: TIndex
	}

# ---------------------------------------------------------------------------

export class Walker<T extends object = object>

	# --- Keep track of nodes visited to avoid infinite loops
	setVisited: WeakSet<T> = new WeakSet<T>()

	# --- If className is provided, only objects with that
	#     constuctor name will be returned

	className: string?

	# ..........................................................

	constructor(@className: string? = undef)

	# ..........................................................

	isNode(x: object): x is T

		return (
			isObject(x)  # not undef, null, regex, array
				&& (
						not @className
					|| (x?.constructor?.name == @className)
					)
			)

	# ..........................................................

	useNode(x: object): boolean

		return @isNode(x)

	# ..........................................................

	filter(h: TNodeInfo<T>): boolean

		# --- filter() is only called if isNode(h.node) is true
		return true

	# ..........................................................

	walk(
			item: unknown
			parent: T? = undef
			level: number = 0
			index: (string | number)? = undef
			): Generator<TNodeInfo<T>, void, void>

		if isObject(item) && @useNode item
			DBG "NODE: #{OL(item)}"
			yield {
				node: item as T
				parent
				level
				index
				}

		if isArray item
			DBG "ARRAY"
			for x,i of item
				yield* @walk x, parent, level+1, i
		else if isObject item
			DBG "OBJECT"
			for [key, x] of Object.entries(item)
				yield* @walk x, (@isNode(item) ? item : parent), level+1, key
