# walker.lib.civet

import {
	undef, defined, notdefined, integer, TConstructor,
	isArray, isObject, isPrimitive, hash, croak, isEmpty,
	assertIsString, assertIsArray,
	} from 'datatypes'
import {extract} from 'llutils'
import {OL} from 'to-nice'
import {DBG} from 'logger'

# ---------------------------------------------------------------------------

export class Walker<T extends object = hash>

	# --- Keep track of nodes visited to avoid infinite loops
	setVisited: WeakSet<T> = new WeakSet<T>()

	lNodeStack: T[] = []

	# ..........................................................

	get level()

		return @lNodeStack.length - 1

	# ..........................................................

	parent(n: number = 1): T

		if (n < 0)
			croak "Bad index: #{n}"
		pos := @lNodeStack.length - n - 1
		if (pos < 0)
			croak "Bad index: #{n}, stack has #{@lNodeStack.length} items"
		return @lNodeStack[pos]

	# ..........................................................

	isNode(x: object): x is T

		return true

	# ..........................................................

	filter(node: T): boolean

		# --- filter() is only called if isNode(node) is true
		return true

	# ..........................................................

	extract(dspath: string): unknown?

		DBG "dspath = '#{dspath}'"
		lMatches := dspath.match ///^
				(\^*)
				(.*)
				$///
		if defined(lMatches)
			[_, goUpStr, mainStr] := lMatches
			return extract @parent(goUpStr.length), mainStr
		else
			croak "Bad dspath: #{dspath}"

	# ..........................................................

	getString(dspath: string): string

		str := @extract dspath
		assertIsString str
		return str

	# ..........................................................

	getArray(dspath: string): unknown[]

		lItems := @extract dspath
		assertIsArray lItems
		return lItems

	# ..........................................................
	# GENERATOR

	walk(item: unknown): Generator<T, void, void>

		if isObject(item) && @isNode(item)
			if @setVisited.has item
				return
			DBG "YIELD NODE: #{OL(item)}"
			@lNodeStack.push item
			yield item
			@setVisited.add item
			for x of Object.values(item)
				yield* @walk x
			@lNodeStack.pop()
		else if isArray item
			DBG "ARRAY"
			for x of item
				yield* @walk x
		else if isObject(item)
			DBG "OBJECT"
			for x of Object.values(item)
				yield* @walk x
		return