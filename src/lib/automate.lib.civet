# automate.lib.civet

import {
	compile as compileSvelte,
	} from 'npm:svelte/compiler'

import {
	undef, defined, notdefined, assert, croak, TAssertFunc,
	isEmpty, nonEmpty, isInteger,
	nonEmptyString, isNonEmptyString,
	hash, hashof, isHash, integer,
	} from 'datatypes'
import {
	words, allMatches, o, OL, keys, getOptions,
	} from 'llutils'
import {
	LOG, LOGVALUE, DBG, DBGVALUE, WARN, INDENT, UNDENT,
	pushLogLevel, popLogLevel,
	} from 'logger'
import {TextTable} from 'text-table'
import {
	TPathInfo, slurp, barf, patchFirstLine, parsePath,
	isFile, isDir, rmFile, findSrcFile,
	withExt, newerDestFileExists, allFilesMatching,
	} from 'fsys'
import {execCmd, execCmdSync, cmdSucceeds} from 'exec'
import {cielo2civetFile, configFromFile} from 'cielo'
import {civet2tsFile, compileCivetFiles} from 'civet'

# ---------------------------------------------------------------------------
# Please, no dependencies on the directory structure!
# ---------------------------------------------------------------------------

export type TTesterFunc = () => boolean

export type TCompileStatus =
	'temp'       |    # --- it's an intermediate file, not compiled
	'nocompiler' |    #     no compiler configured for this file
	'exists'     |    #     newer output files exist, not compiled
	'failed'     |    #     compiling failed
	'compiled'        #     compiling succeeded, output file exists

export type TCompilerFunc = (path: string) => TCompileStatus
export type TPostProcessor = (path: string) => void

export type TCompilerInfo = {
	tester: TTesterFunc
	compiler: TCompilerFunc
	getOutPaths: (path: string) => string[]
	}

export isCompilerInfo := (x: unknown): x is TCompilerInfo =>
	return isHash(x) && ('tester' in x) && ('compiler' in x) && ('getOutPaths' in x)

export type TCompilerConfig = {
	hCompilers: hashof<TCompilerInfo>         # <string>: <TCompilerInfo>
	hPostProcessors: hashof<TPostProcessor>   # <string>: <TPostProcessor>
	}

export isCompilerConfig := (x: unknown): x is TCompilerConfig =>
	return isHash(x) && ('hCompilers' in x) && ('hPostProcessors' in x)

export type TCompileResult = {
	status: TCompileStatus
	path: string
	lOutPaths?: string[]
	postProcStatus?: unknown
	}

export type TUnitTestResult = {
	stub: string
	success: boolean
	msg?: string
	code?: number
	signal?: string
	}

# ---------------------------------------------------------------------------

export build := (
		name: string = '*'
		purp: string = '{lib,cmd}'
		hOptions: hash={}
		): void =>

	type opt = {
		nopp: boolean
		}
	{nopp} := getOptions<opt> hOptions, {
		nopp: false
		}

	# --- Even though it's a constant, we can still
	#     append strings to it!
	lUnitTests: string[] := []

	pat := "**/#{name}.#{purp}.civet"
	for hInfo of allFilesMatching(pat)
		{type, path, fileName, purpose, stub, relPath} := hInfo
		assert (type == 'file'), "Not a file: #{path}"
		assert isNonEmptyString(stub), "Empty stub"
		LOG "#{relPath} (#{purpose})"
		if newerDestFileExists(relPath, '.ts')
			LOG "   EXISTS";
		else
			# --- Compile civet file to TypeScript

			{success} := execCmdSync 'civet', [
				'--inline-map'
				'-o', '.ts'
				'-c', relPath
				]
			if success
				LOG "   BUILD OK"

				# --- type check the TypeScript file

				hResult := execCmdSync 'deno', [
					'check',
					'-q', withExt(relPath, '.ts')
					]
				if hResult.success
					LOG "   CHECK OK"
				else
					LOG "   CHECK FAILED"
					continue   # don't install if a command
			else
				LOG "   BUILD FAILED"
				continue   # don't install if a command

		switch purpose
			when 'cmd'
				{success} := execCmdSync 'deno', [
					'install'
					'-fgA'
					'-n', stub || 'unknown'
					'--no-config'
					'--import-map', 'import_map.jsonc'
					withExt(relPath, '.ts')
					]
				LOG "   INSTALL #{success ? 'OK' : 'FAILED'}"
			when 'lib'
				if defined(stub) && not nopp
					lUnitTests.push stub
	LOGVALUE 'lUnitTests', lUnitTests
	return

# ---------------------------------------------------------------------------
# --- What an ugly syntax, but it works! (i.e. type narrows)

assertIsCompilerConfig: (val: unknown) => asserts val is TCompilerConfig := (
		val: unknown
		): asserts val is TCompilerConfig ->

	assert isCompilerConfig(val), "Not a compiler config"

# ---------------------------------------------------------------------------

export getCompilerConfig := (
	fileName: string = 'compile.config.civet'
	): TCompilerConfig =>

	path := findSrcFile(fileName)
	if defined(path)
		DBG "load compiler config from #{OL(path)}"
		hConfig := configFromFile(path)
		assertIsCompilerConfig(hConfig)
		DBGVALUE 'hConfig', hConfig

		# --- Remove any compilers for which the
		#     compiler software has not been installed

		{hCompilers} := hConfig
		for ext of keys(hCompilers)
			{tester} := hCompilers[ext]
			pushLogLevel 'silent'
			works := tester()
			popLogLevel()

			if not works
				DBG "Deleting compiler for ext #{OL(ext)}"
				delete hCompilers[ext]
		return hConfig
	else
		return {
			hCompilers: {
				# --- keys are file extensions
				#     NOTE: compilers must be synchronous!!!

				'.svelte': {
					getOutPaths: (path: string) =>
						return [withExt(path, '.js')]

					tester: () =>
						return true

					compiler: (path: string) =>
						jsPath := withExt(path, '.js')
						rmFile jsPath
						{js, warnings} := compileSvelte slurp(path), {
							customElement: true
							runes: true
							}
						{code, map} := js
						barf jsPath, code
						return 'compiled'
					}

				'.dot': {
					getOutPaths: (path: string) =>
						return [withExt(path, '.svg')]

					tester: () =>
						return cmdSucceeds('dot', ['--version'], o'quiet')

					compiler: (path: string) =>
						svgPath := withExt(path, '.svg')
						rmFile svgPath
						execCmdSync 'dot', ['-Tsvg', path]
						return 'compiled'
					}

				'.cielo': {

					# --- We produce an intermediate .civet file,
					#     but give it a purpose of 'temp'
					#     so it won't get compiled by the compile script
					getOutPaths: (path: string) => [withExt(path, '.ts')]

					tester: () =>
						# --- we need civet to be installed
						return cmdSucceeds('civet', ['--version'], o'quiet')

					compiler: (path: string) =>
						# --- start with a *.cielo file
						civetPath := withExt(path, '.temp.civet')
						tsPath := withExt(path, '.ts')

						rmFile civetPath    # --- needed?
						rmFile tsPath       # --- needed?

						cielo2civetFile path, civetPath
						civet2tsFile civetPath, tsPath

						{fileName} := parsePath(path)
						patchFirstLine civetPath, fileName, withExt(fileName, '.temp.civet')
						patchFirstLine tsPath, fileName, withExt(fileName, '.ts')

						return 'compiled'
					}

				'.civet': {

					getOutPaths: (path: string) =>
						return [withExt(path, '.ts')]

					tester: () =>
						return cmdSucceeds('civet', ['--version'], o'quiet')

					compiler: (path: string) =>
						{purpose, fileName} := parsePath(path)
						if defined(purpose) && ['temp','debug'].includes(purpose)
							return 'temp'

						tsPath := withExt(path, '.ts')
						tsName := withExt(fileName, '.ts')

						civet2tsFile path, tsPath
						patchFirstLine tsPath, fileName, tsName
						return 'compiled'
					}
				}

			hPostProcessors: {
				# --- Keys are a purpose

				'test': (path: string): void =>
					return

				'lib': (path: string): void =>
					{stub} := parsePath(path)
					if defined(stub)
						for {success} of runUnitTestsFor(stub)
							if not success
								WARN "Unit test #{path} failed"
					return

				'cmd': (path: string): void =>
					LOG "- installing command #{path}"
					installCmd path
					return
				}
			}

# ---------------------------------------------------------------------------
# --- returns a TCompilerInfo or undef

export getCompilerInfo := (
		ext: string
		): TCompilerInfo? =>

	hConfig := getCompilerConfig()
	hInfo := hConfig.hCompilers[ext]
	if defined(hInfo)
		return hInfo
	else
		DBG "No compiler for #{ext} files"
		return undef

# ---------------------------------------------------------------------------

export getPostProcessor := (
		purpose: string
		): TPostProcessor? =>

	hConfig := getCompilerConfig()
	pp := hConfig.hPostProcessors[purpose]
	if defined(pp)
		return pp
	else
		DBG "No post processor for #{purpose} files"
		return undef

# ---------------------------------------------------------------------------
# --- src can be a full or relative path
#     throws error if file does not exist
#
#     Possible status values:
#        'temp'       - it was a temp file, not compiled
#        'nocompiler' - has no compiler, not compiled
#        'exists'     - newer compiled file already exists
#        'failed'     - compiling failed
#        'compiled'   - successfully compiled

export compileFile := (
	path: string,
	hOptions: hash={}
	): TCompileResult =>

	assert isFile(path), "No such file: #{OL(path)}"
	DBG "COMPILE: #{OL(path)}", INDENT

	type opt = {
		nopp: boolean
		}
	{nopp} := getOptions<opt> hOptions, {
		nopp: false
		}

	{relPath, stub, purpose, ext} := parsePath path

	if notdefined(ext)
		DBG "Not compiling - no file extension in #{OL(path)}", UNDENT
		return {status: 'nocompiler', path: relPath}

	hCompilerInfo := getCompilerInfo(ext)
	if notdefined(hCompilerInfo)
		DBG "Not compiling - no compiler for #{OL(ext)}", UNDENT
		return {status: 'nocompiler', path: relPath}

	{compiler, getOutPaths} := hCompilerInfo
	lOutPaths := getOutPaths(relPath)
	DBG "lOutPaths = #{OL(lOutPaths)}"

	let allNewer = true
	for outPath of lOutPaths
		if not newerDestFileExists(relPath, outPath)
			allNewer = false
			break
	if allNewer
		DBG "Not compiling, newer #{OL(lOutPaths)} exist", UNDENT
		return {status: 'exists', path: relPath, lOutPaths}

	DBG "compiling #{OL(path)} to #{OL(lOutPaths)}"
	status := compiler path
	let postProcStatus: unknown? = undef
	if (status == 'compiled') && defined(purpose) && not nopp
		postProc := getPostProcessor(purpose)
		if defined(postProc)
			DBG "post-processing file"
			try
				postProc path
			catch err
				postProcStatus = err
	DBG UNDENT
	if defined(postProcStatus)
		return {status, path: relPath, lOutPaths, postProcStatus}
	else
		return {status, path: relPath, lOutPaths}

# ---------------------------------------------------------------------------
# --- GENERATOR

export runUnitTestsFor := (
	stub: nonEmptyString
	hOptions: hash={}
	): Generator<TUnitTestResult, void, void> ->

	type opt = {
		verbose: boolean
		}
	{verbose} := getOptions<opt> hOptions, {
		verbose: false
		}

	DBG "Running unit tests for #{stub}"
	if not verbose
		pushLogLevel 'silent'

	# --- Ensure that matching lib & cmd files are compiled
	#     (no error if there is no compiler for the file)
	build stub
#	for {path} of allFilesMatching("**/#{stub}.*")
#		{status} := compileFile path, o'nopp'
#		assert (status != 'failed'), "compile of #{path} failed"

	# --- Compile and run all unit tests for stub
	for {path} of allFilesMatching("**/#{stub}*.test.*")
		{status, lOutPaths} := compileFile path, o'nopp'
		assert (status != 'failed'), "compile of #{path} failed"
		if notdefined(lOutPaths)
			continue
		for outPath of lOutPaths
			assert isFile(outPath), "File #{OL(outPath)} not found"

		# --- Compile all files in subdir if it exists
		if isDir("test/#{stub}")
			for {path} of allFilesMatching("test/#{stub}/*")
				{status, lOutPaths} := compileFile path
				assert (status != 'failed'), "Compile of #{path} failed"
				if notdefined(lOutPaths)
					WARN "File #{OL(path)} not compiled to #{OL(lOutPaths)}"

		# --- Run the unit tests, yield results
		for outPath of lOutPaths
			{success, code, signal} := execCmdSync 'deno', [
					'test',
					'-qA',
					outPath
					]
			yield {stub, success, code, signal}
	if not verbose
		popLogLevel()
	return

# ---------------------------------------------------------------------------
# --- GENERATOR

export runAllUnitTests := (
		): Generator<TUnitTestResult, void, void> ->

	DBG "Running all unit tests"

	hGlobOptions := {
		exclude: ['node_modules/**', '.git/**']
		}

	pattern := '**/*.{lib,cmd}.ts'
	DBG "pattern = #{OL(pattern)}"
	for {path, stub} of allFilesMatching(pattern, hGlobOptions)
		if (stub == undef)
			WARN "No stub found in #{OL(path)}"
		else
			DBG "UNIT TEST: #{path}"
			for hResult of runUnitTestsFor(stub)
				yield hResult
	return

# ---------------------------------------------------------------------------
# ASYNC

export installCmd := (
		path: string
		name: string? = undef
		): void =>

	if notdefined(name)
		await execCmd 'deno', [
			'install'
			'-fgA'
			'--config'
			'deno.jsonc'
			path
			]
	else
		await execCmd 'deno', [
			'install'
			'-fgA'
			'-n'
			name
			'--config'
			'deno.jsonc'
			path
			]
	return

# ---------------------------------------------------------------------------
# ASYNC

export uninstallCmd := (
		path: string
		name: string? = undef
		): void =>

	if notdefined(name)
		await execCmd 'deno', [
			'uninstall'
			'-g'
			path
			]
	else
		await execCmd 'deno', [
			'uninstall'
			'-g'
			'-n'
			name
			path
			]
	return
