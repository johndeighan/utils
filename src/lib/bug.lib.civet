# walker.lib.civet

# ---------------------------------------------------------------------------

export type TNodeInfo<T> = {
	node: T
	level: number
	parent: T?
	}

type TConstructor<T> = new (...args: any[]) => T

# ---------------------------------------------------------------------------

export class Walker<T extends object = object>

	# --- Keep track of nodes visited to avoid infinite loops

	setVisited: WeakSet<T> = new WeakSet<T>()

	# --- If constructor is provided, only objects with that
	#     constuctor will be yielded

	nodeConstructor: TConstructor<T>?

	# ..........................................................

	constructor(@nodeConstructor: TConstructor<T>? = undefined)

	# ..........................................................

	isNode(x: object): x is T

		return (
			(typeof x == 'object')
				&& (
						not @nodeConstructor
					|| (x instanceof @nodeConstructor)
					)
			)

	# ..........................................................

	useNode(x: object): boolean

		return @isNode(x)

	# ..........................................................
	# GENERATOR

	walk(
			item: unknown
			parent: T? = undefined
			level: number = 0
			): Generator<TNodeInfo<T>, void, void>

		if (typeof item == 'object') && (item != null) && @useNode item
			yield {
				node: item as T
				parent
				level
				}

		if Array.isArray item
			for x of item
				yield* @walk x, parent, level+1
		else if (typeof item == 'object') && (item != null)
			for x of Object.values(item)
				yield* @walk x, (@isNode(item) ? item : parent), level+1
