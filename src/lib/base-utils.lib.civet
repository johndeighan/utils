# base-utils.lib.civet

import {assert} from 'jsr:@std/assert'
import {relative, parse} from 'node:path'
import {existsSync} from 'jsr:@std/fs'
import {statSync} from 'node:fs'
import {expandGlobSync} from 'jsr:@std/fs/expand-glob'

export {assert}
decoder := new TextDecoder()
decode := (x: Uint8Array<ArrayBuffer>) =>
	return decoder.decode(x)

export DIR := (x: unknown): void =>
	console.dir x, {depth: null}

export type TConstructor<T> = new (...args: any[]) => T

let hasClear = false

# ---------------------------------------------------------------------------

export checkSetup := (): void =>

	rootDir: string? := Deno.env.get('PROJECT_ROOT_DIR')
	assertIsDefined(rootDir)
	assert existsSync(rootDir) && statSync(rootDir).isDirectory(),
		"Please set env var PROJECT_ROOT_DIR to a valid directory"
	return

# ---------------------------------------------------------------------------

export condClear := (
		lCmdArgs: string[] = Deno.args
		): void =>

	if (Deno.args.at(-1) == '!')
		hasClear = true
		execCmd 'clear'
	return

# ---------------------------------------------------------------------------

export stdChecks := (): void =>

	debugger
	checkSetup()
	condClear()
	return

# ---------------------------------------------------------------------------

export FAIL := (errMsg: string, n: number = 99): never =>

	console.log errMsg
	Deno.exit(n)

# ---------------------------------------------------------------------------

export SUCCEED := (msg: string? = undef): never =>

	if defined(msg)
		console.log msg
	Deno.exit(0)

# ---------------------------------------------------------------------------
#             cmd-args
# ---------------------------------------------------------------------------

export flag := (
		ch: string
		lCmdArgs: string[] = Deno.args
		): boolean =>

	assert (ch.length == 1), "Bad flag arg: #{ch}"
	re := new RegExp("^-[a-z]*#{ch}[a-z]*$")
	for str of lCmdArgs
		if re.test(str)
			return true
	return false

# ---------------------------------------------------------------------------

export mapNonOption := (str: string): string =>

	if str.startsWith('=')
		fileName := str.substring(1)
		path := findFile fileName
		assert defined(path), "No such file: #{fileName}"
		return path
	else
		return str

# ---------------------------------------------------------------------------

export nonOption := (
		pos: number,
		lCmdArgs: string[] = Deno.args
		): string? =>

	for str of lCmdArgs
		if not str.startsWith('-')
			if (pos == 0)
				return hasClear && (str == '!') ? undef : mapNonOption(str)
			else
				pos -= 1
	return undef

# ---------------------------------------------------------------------------

export allNonOptions := (
		lCmdArgs: string[] = Deno.args
		): Generator<string, void, void> ->

	for str of lCmdArgs
		if not str.startsWith('-') && ((str != '!') || not hasClear)
			yield mapNonOption(str)

# ---------------------------------------------------------------------------
#             logger
# ---------------------------------------------------------------------------

export LOG := console.log

export DBG := (msg: string): void =>
	if flag('D')
		LOG msg
	return

# ---------------------------------------------------------------------------

export LLOG := (
		label: string
		msg: string
		): void =>

	labelLen := 15
	if (label.length <= labelLen)
		spaces := ' '.repeat(labelLen-label.length)
		LOG "#{label}#{spaces} #{msg}"
	else
		LOG "#{label.substring(0, labelLen)} #{msg}"
	return

# ---------------------------------------------------------------------------

export ILOG := (msg: string): void =>

	LOG "   #{msg}"
	return

# ---------------------------------------------------------------------------
#             datatypes
# ---------------------------------------------------------------------------

export type hash
	[key: string | symbol]: unknown

export type TDefined = NonNullable<unknown>
export type TNotDefined = null | undefined

export undef := undefined

# ---------------------------------------------------------------------------

export defined := (x: unknown): x is TDefined =>

	return (x != undef) && (x != null)

# ---------------------------------------------------------------------------

export notdefined := (x: unknown): x is TNotDefined =>

	return (x == undef) || (x == null)

# ---------------------------------------------------------------------------

export function assertIsDefined(
		value: unknown
		name: string = ''
		): asserts value is TDefined =>

	if notdefined(value)
		throw new Error("value is not defined")
	return

# ---------------------------------------------------------------------------

export function assertNotDefined(
		value: unknown
		name: string = ''
		): asserts value is TNotDefined =>

	if defined(value)
		throw new Error("value is defined")
	return

# ---------------------------------------------------------------------------

export croak := (msg: string): never =>

	throw new Error(msg)

# ---------------------------------------------------------------------------
# ---------------------------------------------------------------------------

export replaceInArray := (
	lStrings: string[]
	hReplace: {[key: string]: string}
	): string[] =>

	return for str of lStrings
		if hReplace.hasOwnProperty(str)
			hReplace[str]
		else
			str

# ---------------------------------------------------------------------------
#             fsys
# ---------------------------------------------------------------------------

export isFile := (path: string): boolean =>

	return existsSync(path) && statSync(path).isFile()

# ---------------------------------------------------------------------------

export slurp := (path: string): string =>

	data := Deno.readFileSync path
	return decoder.decode(data).replaceAll('\r', '')

# ---------------------------------------------------------------------------

export rmFile := (path: string): void =>

	if existsSync path
		Deno.removeSync path
	return

# ---------------------------------------------------------------------------

export fileExt := (path: string): string =>

	if lMatches := path.match(/\.[^\.]+$/)
		return lMatches[0]
	else
		return ''

# ---------------------------------------------------------------------------

export withExt := (path: string, ext: string): string =>

	lMatches := path.match /^(.*)(\.[^\.]+)$/
	if (lMatches == null)
		croak "Bad path: '#{path}'"
		return ''
	else
		[_, headStr, orgExt] := lMatches
		return "#{headStr}#{ext}"

# ---------------------------------------------------------------------------

export normalizePath := (path: string): string =>

	npath := path.replaceAll('\\', '/')
	if (npath.charAt(1) == ':')
		return npath.charAt(0).toUpperCase() + npath.substring(1)
	else
		return npath

# ---------------------------------------------------------------------------

export relpath := (path: string): string =>

	return normalizePath(relative('', path))

# ---------------------------------------------------------------------------

export buildFileName := (
		stub: string
		purpose: string?
		ext: string
		) =>

	return (
		purpose ? "#{stub}.#{purpose}#{ext}"
		        : "#{stub}#{ext}"
		)

# ---------------------------------------------------------------------------

export buildTestFileName := (
		stub: string
		purpose: string?
		ext: string
		) =>

	return (
		purpose ? "#{stub}.#{purpose}.test#{ext}"
		        : "#{stub}.test#{ext}"
		)

# ---------------------------------------------------------------------------

export type TPathInfo = {
	root: string
	dir: string
	fileName: string

	stub: string
	purpose: string?
	ext: string
	}

export parsePath := (
		path: string
		): TPathInfo =>

	{root, dir, base} := parse(path)

	lParts := base.split('.')
	assert (lParts.length > 2), "Bad path: #{path}"
	return {
		root: normalizePath(root)
		dir: normalizePath(dir)
		fileName: base

		stub:    lParts.slice(0, -2).join('.')
		purpose: lParts.at(-2)
		ext:     ".#{lParts.at(-1)}"
		}

# ---------------------------------------------------------------------------

export type TExecResult = {
	success: boolean
	code: number
	signal?: Deno.Signal | null
	stdout?: string
	stderr?: string
	}

export type TReplaceHash = {
	[key: string]: string
	}

# ---------------------------------------------------------------------------
# ASYNC

export execCmd := (
	cmdName: string
	lCmdArgs: string[] = []
	hReplace: TReplaceHash = {}
	capture: boolean = false
	): TExecResult =>

	child := new Deno.Command(cmdName, {
		args: replaceInArray(lCmdArgs, hReplace)
		stdout: capture ? 'piped' : 'inherit'
		stderr: capture ? 'piped' : 'inherit'
		})
	if capture
		{success, code, signal, stdout, stderr} := await child.output()
		return {
			success, code
			signal: signal || undef
			stdout: decode(stdout)
			stderr: decode(stderr)
			}
	else
		{success, code, signal} := await child.output()
		return {
			success
			code
			signal: signal || undef
			}

# ---------------------------------------------------------------------------

export newerDestFileExists := (
		path: string
		ext: string
		): boolean =>

	destPath := withExt path, ext
	if not existsSync(destPath)
		return false
	srcMS := statSync(path).mtimeMs
	destMS := statSync(destPath).mtimeMs
	return (destMS > srcMS)

# ---------------------------------------------------------------------------

export cmdSucceeds := (
		cmdName: string
		lArgs: string[] = []
		): boolean =>

	child := new Deno.Command cmdName, {
		args: lArgs
		stdout: 'piped'
		stderr: 'piped'
		}
	return child.outputSync().success

# ---------------------------------------------------------------------------

export splitPatterns := (
		lAllPats: string | string[]
		): [string[], string[]] =>

	lPosPats: string[] := []
	lNegPats: string[] := []

	if (typeof lAllPats == 'string')
		# --- A single string can't be a negative pattern
		assert not lAllPats.match(/^\!/), "Bad glob pattern: #{lAllPats}"
		lPosPats.push lAllPats
	else
		for pat of lAllPats
			lMatches := pat.match(/^(\!\s*)?(.*)$/)
			if lMatches
				if lMatches[1]
					lNegPats.push lMatches[2]
				else
					lPosPats.push lMatches[2]
	return [lPosPats, lNegPats]

# ---------------------------------------------------------------------------
# GENERATOR
#
#    Use like:
#       for path of allFilesMatching(lPats)
#          OR
#       lPaths := Array.from(allFilesMatching(lPats))
#
#    NOTE: By default, searches from ./src

export allFilesMatching := (
		lPatterns: string | string[]
		hGlobOptions = {
			root: './src'
			includeDirs: false
			}
		): Generator<string, void, void> ->

	[lPosPats, lNegPats] := splitPatterns lPatterns
	if flag('D')
		LOG "PATTERNS:"
		for pat of lPosPats
			ILOG "POS: #{pat}"
		for pat of lNegPats
			ILOG "NEG: #{pat}"

	setSkip := new Set<string>()
	for pat of lNegPats
		for {path} of expandGlobSync(pat, hGlobOptions)
			setSkip.add path

	for pat of lPosPats
		for {path} of expandGlobSync(pat, hGlobOptions)
			if not setSkip.has path
				DBG "PATH: #{path}"
				yield path
				setSkip.add path
	return

# ---------------------------------------------------------------------------

export findFile := (fileName: string): string? =>

	lPaths := Array.from allFilesMatching("**/#{fileName}")
	switch lPaths.length
		when 1
			return normalizePath(lPaths[0])
		when 0
			return undef
		else
			for path of lPaths
				console.log path
			croak "Multiple files with name #{fileName}"
			return ''

# ---------------------------------------------------------------------------
# ASYNC

export type TProcFunc = (path: string) => Promise<unknown>
export type TProcResult = { [path: string]: unknown }

export procFiles := (
		lPatterns: string | string[]
		procFunc: TProcFunc
		): [
			TProcResult     # paths succeeded
			TProcResult?    # paths failed
			] =>

	# --- We need the paths for later
	lPaths := Array.from(allFilesMatching(lPatterns))

	lPromises := for path of lPaths
		procFunc path
	lResults := await Promise.allSettled(lPromises)

	hSucceeded: TProcResult := {}
	hFailed:    TProcResult := {}

	# --- lResults are in the same order as lPaths
	let hasFailed = false
	for res,i of lResults
		path := lPaths[i]
		if (res.status == 'fulfilled')
			hSucceeded[path] = res.value
		else
			hasFailed = true
			hFailed[path] = res.reason

	return [
		hSucceeded,
		hasFailed ? hFailed : undef
		]

# ---------------------------------------------------------------------------

type TFileRunner = (
		stub: string
		purpose: string?
		lArgs?: string[]
		hOptions?: hash
		) => Promise<void>

# ---------------------------------------------------------------------------

export getStringOption := (
		hOptions: hash
		key: string
		defVal: string? = undef
		): string? =>

	if hOptions.hasOwnProperty key
		val := hOptions[key]
		assert (typeof val == 'string'), "Not a string: #{val}"
		return val
	else
		return defVal

# ---------------------------------------------------------------------------

export getBooleanOption := (
		hOptions: hash
		key: string
		defVal: boolean = false
		): boolean =>

	if hOptions.hasOwnProperty key
		val := hOptions[key]
		assert (typeof val == 'boolean'), "Not a boolean: #{val}"
		return val
	else
		return defVal

# ---------------------------------------------------------------------------
# ASYNC

export tryCmd := (
		func: TFileRunner
		stub: string
		purpose: string?
		lArgs: string[] = []
		hOptions: hash = {}
		): void =>

	try
		await func(stub, purpose, lArgs, hOptions)
	catch err
		console.error err
		if getBooleanOption hOptions, 'exitOnFail', true
			Deno.exit(99)
		return

# ---------------------------------------------------------------------------
#      RUNNERS (all ASYNC)
#      when run using tryCmd()
#         - false return will exit the script
#         - false return will cause a log message
# ---------------------------------------------------------------------------
# ASYNC

export civet2tsFile := (
		stub: string
		purpose: string?
		): void =>

	fileName := buildFileName stub, purpose, '.civet'
	LLOG 'COMPILE', fileName

	path := findFile fileName
	assert path, "No such file: #{fileName}"

	if newerDestFileExists path, '.ts'
		ILOG "already compiled"
		return

	{success} := await execCmd 'deno', [
		'run'
		'-A'
		'npm:@danielx/civet'
		'--inline-map'
		'-o', '.ts'
		'-c', path
		]
	if success
		ILOG "OK"
	else
		ILOG "FAILED"
		rmFile withExt(fileName, '.ts')
		croak "Compile of #{fileName} failed"

	# --- Type check the *.ts file
	LOG "TYPE CHECK: #{fileName}"
	h := await execCmd 'deno', [
		'check',
		withExt(path, '.ts')
		]

	if h.success
		ILOG "OK"
	else
		ILOG "FAILED"
		rmFile withExt(fileName, '.ts')
		croak "Type Check of #{fileName} failed"
	return

# ---------------------------------------------------------------------------
# ASYNC

export doUnitTest := (
		stub: string
		purpose: string?      # purpose of the file being tested
		lArgs: string[] = []
		): void =>

	debugger
	fileName := buildTestFileName stub, purpose, '.civet'
	LLOG "UNIT TEST", fileName

	testPath := findFile fileName
	if notdefined(testPath)
		ILOG "There is no unit test for #{fileName}"
		return
	DBG "TEST FILE: #{relpath(testPath)}"

	if not newerDestFileExists(testPath, '.ts')
		LLOG 'COMPILE', relpath(testPath)
		{success} := await execCmd 'deno', [
			'run'
			'-A'
			...(flag('d') ? ['--inspect-brk'] : [])
			'npm:@danielx/civet'
			'--inline-map'
			'-o', '.ts'
			'-c', testPath
			]
		if not success
			croak "   Compile of #{testPath} failed!"

	tsTestPath := relpath(withExt(testPath, '.ts'))
	verbose := flag('v')
	lCmdArgs := (
		  verbose
		? ['test', '-A', '--coverage-raw-data-only', tsTestPath]
		: ['test', '-A', '--coverage-raw-data-only', '--reporter', 'dot', tsTestPath]
		)

	h := await execCmd 'deno', lCmdArgs
	assert h.success, "   deno #{lCmdArgs.join(' ')} FAILED"
	return

# ---------------------------------------------------------------------------
# ASYNC

export doInstallCmd := (
		stub: string,
		purpose: string? = 'cmd'
		lArgs: string[] = []
		hOptions: hash = {}
		): void =>

	fileName := buildFileName stub, purpose, '.ts'
	LOG "INSTALL CMD: #{fileName}"

	path := findFile fileName
	assert path, "No such file: #{fileName}"

	name := getStringOption(hOptions, 'name') || parsePath(path).stub
	h := await execCmd 'deno', [
		'install',
		'-fgA',
		'-n', name,
		'--no-config',
		'--import-map', 'import_map.jsonc',
		path
		]
	assert h.success, "   FAILED"
	LOG "   OK"
	return

# ---------------------------------------------------------------------------
# ASYNC

export doRun := (
		stub: string
		purpose: string?
		lArgs: string[] = []
		): void =>

	fileName := buildFileName stub, purpose, '.ts'
	LOG centered("RUN: #{fileName}", 64, '-')

	path := findFile fileName
	assert path, "No such file: #{fileName}"

	h := await execCmd 'deno', [
		'run'
		'-A'
		...(flag('d') ? ['--inspect-brk'] : [])
		path
		'--'
		lArgs...
		]

	assert h.success, "   FAILED"
	return

# ---------------------------------------------------------------------------

export sep := (
		label: string? = undef
		char: string = '-'
		width: number = 64
		): string =>

	if defined(label)
		return centered(label, width, char)
	else
		return char.repeat(width)

# ---------------------------------------------------------------------------
# --- valid options:
#        char - char to use on left and right
#        buffer - num spaces around text when char <> ' '

export centered := (
	text: string,
	width: number,
	char: string = ' ',
	numBuffer: number = 2
	): string =>

	totSpaces := width - text.length
	if (totSpaces <= 0)
		return text
	numLeft := Math.floor(totSpaces / 2)
	numRight := totSpaces - numLeft
	if (char == ' ')
		return ' '.repeat(numLeft) + text + ' '.repeat(numRight)
	else
		buf := ' '.repeat(numBuffer)
		left := char.repeat(numLeft - numBuffer)
		right := char.repeat(numRight - numBuffer)
		return left + buf + text + buf + right

# ---------------------------------------------------------------------------

export lAllLibs := [
	'base-utils', 'datatypes', 'llutils', 'db', 'indent', 'unicode',
	'to-nice', 'extract', 'log-levels', 'log-formatter', 'logger',
	'text-table', 'env-stack',

	'parser', 'cmd-args',
	'walker', 'fsys', 'pll', 'exec', 'from-nice'

	'source-map', 'symbols', 'typescript', 'civet', 'cielo',
	'automate', 'v8-stack', 'unit-test',
	]
