# tokens.lib.civet

import {undef, isEmpty, nonEmpty} from './datatypes.lib.ts'
import {allLinesInBlock, escapeStr} from './llutils.lib.ts'
import {DBG} from './logger.lib.ts'
import {indentLevel, splitLine} from './indent.lib.ts'
import {TextTable} from './text-table.lib.ts'

# ---------------------------------------------------------------------------
# ---------------------------------------------------------------------------
# --- Common token types:
#        'line', 'empty', 'indent', 'undent'

export type Token = {
	kind: string
	str: string
	}

# ---------------------------------------------------------------------------

export type tokenGenerator = (line: string) => Generator<Token, void, void>

identTokenGen: tokenGenerator := (line: string) ->
	yield {kind: 'line', str: line}
	return

export allTokensIn := (
		iterable: Iterable<string>,
		gen: tokenGenerator = identTokenGen
		): Generator<Token, void, void> ->

	let level = 0
	for str of iterable
		DBG "LINE: '#{escapeStr(str)}'"
		if isEmpty(str)
			yield {kind: 'empty', str}
		else
			[indent, line] := splitLine(str)
			while (indent > level)
				level += 1
				yield {kind: 'indent', str: ''}
			while (indent < level)
				level -= 1
				yield {kind: 'undent', str: ''}
			for tok of gen(line)
				yield tok
	while (level > 0)
		yield {kind: 'undent', str: ''}
		level -= 1
	return

# ---------------------------------------------------------------------------

export allTokensInBlock := (
		block: string
		gen: tokenGenerator = identTokenGen
		): Generator<Token, void, void> ->

	for tok of allTokensIn(allLinesInBlock(block), gen)
		yield tok
	return

# ---------------------------------------------------------------------------

export tokenTable := (
		lTokens: Token[]
		title='Tokens'
		): string =>

	table := new TextTable 'l l'
	table.fullsep '='
	table.title title
	table.fullsep '='
	table.labels ['kind', 'str']
	table.sep()
	for tok of lTokens
		table.data [tok.kind, tok.str]
	table.fullsep '='
	return table.asString()
