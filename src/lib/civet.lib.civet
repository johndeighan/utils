# civet.lib.civet

import {Node, SourceFile} from 'npm:typescript'

import {
	undef, defined, notdefined, hash, assert,
	isString, isHash,
	} from 'datatypes'
import {getOptions, o} from 'llutils'
import {OL, ML} from 'to-nice'
import {DBG, DBGVALUE} from 'logger'
import {
	isFile, fileExt, withExt, slurp, barf, barfTempFile,
	parsePath, findSrcFile, rmFile,
	} from 'fsys'
import {
	TCmdDesc, TExecResult, execCmdSync, execCmd, execCmds,
	} from 'exec'
import {stripSrcMap} from 'source-map'
import {ts2ast, analyze} from 'typescript'

# ---------------------------------------------------------------------------
# ASYNC

export compileCivetFiles := (
		lStubs: string[]
		purpose: string = 'lib'
		): TExecResult[] =>

	lCmds: TCmdDesc[] := []
	for stub of lStubs
		path := findSrcFile "#{stub}.#{purpose}.civet"
		assert defined(path), "No such file: #{OL(path)}"
		if defined(path)
			lCmds.push ['deno', [
				'run'
				'-A'
				'npm:@danielx/civet'
				'--inline-map'
				'-o', '.ts'
				'-c', path
				]]

	lResults := await execCmds lCmds
	return lResults

# ---------------------------------------------------------------------------

export civet2tsFile := (
		path: string
		tsPath: string = withExt(path, '.ts')
		hOptions: hash = {}
		): string =>

	assert isFile(path), "No such file: #{OL(path)} (civet2tsFile)"
	assert (fileExt(path) == '.civet'), "Not a civet file: #{OL(path)}"

	type opt = {
		nomap: boolean
		}
	{nomap} := getOptions<opt> hOptions, {
		nomap: false
		}

	execCmdSync 'deno', [
		'run'
		'-A'
		'npm:@danielx/civet'
		... nomap ? [] : ['--inline-map']
		'-o',
		tsPath,
		'-c',
		path
		]
	assert isFile(tsPath), "File not created: #{OL(tsPath)}"
	return tsPath

# ---------------------------------------------------------------------------

export civet2ts := (
		civetCode: string
		hOptions: hash = {}
		): string =>

	tempFilePath := barfTempFile civetCode
	tsFilePath := withExt tempFilePath, '.ts'
	civet2tsFile tempFilePath, tsFilePath, hOptions
	contents := slurp tsFilePath
	return contents

# ---------------------------------------------------------------------------

export civet2ast := (civetCode: string): Node =>

	tsCode := civet2ts civetCode
	return ts2ast tsCode

# ---------------------------------------------------------------------------
# --- template literals to simplify displaying
#     the analysis of civet code

export a := (lStrings: TemplateStringsArray): string =>
	return analyze(civet2ts(lStrings[0])).asString()

export A := (lStrings: TemplateStringsArray): string =>
	return analyze(civet2ts(lStrings[0]), o'dump').asString()

# ---------------------------------------------------------------------------
